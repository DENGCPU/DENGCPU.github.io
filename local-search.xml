<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面试06-setState是同步更新还是异步更新？</title>
    <link href="/2020/12/22/%E9%9D%A2%E8%AF%9506-setState%E6%98%AF%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%EF%BC%9F/"/>
    <url>/2020/12/22/%E9%9D%A2%E8%AF%9506-setState%E6%98%AF%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="面试场景6：setState是同步更新还是异步更新？"><a href="#面试场景6：setState是同步更新还是异步更新？" class="headerlink" title="面试场景6：setState是同步更新还是异步更新？"></a>面试场景6：setState是同步更新还是异步更新？</h4><p>分析问题：“是A还是B”是一个面试中经常问的问题，这种题可能在不同的场景中会有不同的选择：</p><ul><li>可能是A</li><li>也可能是B</li><li>甚至是A和B同时存在</li></ul><p>所以需要把问题放在具体的场景中探讨，一定不要想当然，不要觉得肯定是XXX啊。在面对类似的问题，要先把场景理清楚，再思考如何回答。</p><p>回到setState本身上来，setState用于变更状态，触发组件重新渲染，更新试图UI。在分析场景之前，需要先了解一个概念<font color=blue>合成事件</font>，它也经常在React面试中被问到。合成事件与setState的触发有千丝万缕的联系。</p><h4 id="一、合成事件"><a href="#一、合成事件" class="headerlink" title="一、合成事件"></a>一、合成事件</h4><p>在没有合成事件之前，大家是怎么处理事件的呢？先看一个很常见的场景：假设ul标签下有10000个li标签，现在需要添加点击事件，通过点击li获取当前li标签中的文本。之前大家的做法是：为每一个li标签添加onclick事件。</p><pre><code class="hljs js">&lt;ul&gt;    &lt;li onclick=<span class="hljs-string">&#x27;getText(this&#x27;</span>)&gt;<span class="hljs-number">1</span>&lt;/li&gt;    &lt;li onclick=<span class="hljs-string">&#x27;getText(this&#x27;</span>)&gt;<span class="hljs-number">2</span>&lt;/li&gt;    &lt;li onclick=<span class="hljs-string">&#x27;getText(this&#x27;</span>)&gt;<span class="hljs-number">3</span>&lt;/li&gt;    ...    &lt;li onclick=<span class="hljs-string">&#x27;getText(this&#x27;</span>)&gt;<span class="hljs-number">10000</span>&lt;/li&gt;&lt;/ul&gt;</code></pre><p>这是一种非常不友好的方式，会对页面的性能产生影响。</p><p>如何优化呢?最恰当的处理方式是采用<font color=blue>事件委托</font>。通过将事件绑定在ul标签上，当li被点击的时候，由事件冒泡到父级的ul标签上触发，并在ul的onclick事件中，确认是哪一个li标签触发的点击事件。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;test&#x27;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    ...    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>10000<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEventTarget</span>(<span class="hljs-params">e</span>) </span>&#123;</span><span class="javascript">        <span class="hljs-comment">//处理兼容性</span></span><span class="javascript">        e = e||<span class="hljs-built_in">window</span>.event;</span><span class="javascript">        <span class="hljs-keyword">return</span> e.target || e.srcElement;</span>    &#125;<span class="javascript">    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test&#x27;</span>);</span><span class="javascript">    ul.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>&#123;</span><span class="javascript">        <span class="hljs-keyword">var</span> target = getEventTarget(event);</span>        alert(target.innerHTML);    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>同样地，出于性能考虑，合成事件也是类似的做法：</p><ol><li>React给document挂上事件监听</li><li>DOM事件触发后冒泡到document</li><li>React找到对应的组件，造成一个合成事件出来</li><li>并按组件树模拟一遍事件冒泡</li></ol><p><img src="https://pic.downk.cc/item/5fe1dd603ffa7d37b37d3071.jpg" alt="React17之前的事件冒泡流程图"></p><p>由于事件挂在了document上，这样在一个页面中只能有一个版本的react。如果有多个版本，事件就乱套了。React17中解决了这个问题，事件委托不再挂在document上，而是挂在DOM容器上，也就是ReactDOM.render所调用的根节点上。<br><img src="https://pic.downk.cc/item/5fe1de423ffa7d37b37e2fb4.jpg" alt="React17后的事件冒泡流程图"></p><p>那么到底哪些事件会被捕获生成事件呢？可以从React的源码中一探究竟。下面的测试快照中罗列了大量的事件名，只有这些事件会被捕获成合成事件。</p><pre><code class="hljs js"><span class="hljs-comment">// react/packages/react-dom/src/__tests__/__snapshots__/ReactTestUtils-test.js.snap</span><span class="hljs-built_in">Array</span> [      <span class="hljs-string">&quot;abort&quot;</span>,  <span class="hljs-string">&quot;animationEnd&quot;</span>,  <span class="hljs-string">&quot;animationIteration&quot;</span>,  <span class="hljs-string">&quot;animationStart&quot;</span>,  <span class="hljs-string">&quot;auxClick&quot;</span>,  <span class="hljs-string">&quot;beforeInput&quot;</span>,  <span class="hljs-string">&quot;blur&quot;</span>,  <span class="hljs-string">&quot;canPlay&quot;</span>,  <span class="hljs-string">&quot;canPlayThrough&quot;</span>,  <span class="hljs-string">&quot;cancel&quot;</span>,  <span class="hljs-string">&quot;change&quot;</span>,  <span class="hljs-string">&quot;click&quot;</span>,  <span class="hljs-string">&quot;close&quot;</span>,  <span class="hljs-string">&quot;compositionEnd&quot;</span>,  <span class="hljs-string">&quot;compositionStart&quot;</span>,  <span class="hljs-string">&quot;compositionUpdate&quot;</span>,  <span class="hljs-string">&quot;contextMenu&quot;</span>,  <span class="hljs-string">&quot;copy&quot;</span>,  <span class="hljs-string">&quot;cut&quot;</span>,  <span class="hljs-string">&quot;doubleClick&quot;</span>,  <span class="hljs-string">&quot;drag&quot;</span>,  <span class="hljs-string">&quot;dragEnd&quot;</span>,  <span class="hljs-string">&quot;dragEnter&quot;</span>,  <span class="hljs-string">&quot;dragExit&quot;</span>,  <span class="hljs-string">&quot;dragLeave&quot;</span>,  <span class="hljs-string">&quot;dragOver&quot;</span>,  <span class="hljs-string">&quot;dragStart&quot;</span>,  <span class="hljs-string">&quot;drop&quot;</span>,  <span class="hljs-string">&quot;durationChange&quot;</span>,  <span class="hljs-string">&quot;emptied&quot;</span>,  <span class="hljs-string">&quot;encrypted&quot;</span>,  <span class="hljs-string">&quot;ended&quot;</span>,  <span class="hljs-string">&quot;error&quot;</span>,  <span class="hljs-string">&quot;focus&quot;</span>,  <span class="hljs-string">&quot;gotPointerCapture&quot;</span>,  <span class="hljs-string">&quot;input&quot;</span>,  <span class="hljs-string">&quot;invalid&quot;</span>,  <span class="hljs-string">&quot;keyDown&quot;</span>,  <span class="hljs-string">&quot;keyPress&quot;</span>,  <span class="hljs-string">&quot;keyUp&quot;</span>,  <span class="hljs-string">&quot;load&quot;</span>,  <span class="hljs-string">&quot;loadStart&quot;</span>,  <span class="hljs-string">&quot;loadedData&quot;</span>,  <span class="hljs-string">&quot;loadedMetadata&quot;</span>,  <span class="hljs-string">&quot;lostPointerCapture&quot;</span>,  <span class="hljs-string">&quot;mouseDown&quot;</span>,  <span class="hljs-string">&quot;mouseEnter&quot;</span>,  <span class="hljs-string">&quot;mouseLeave&quot;</span>,  <span class="hljs-string">&quot;mouseMove&quot;</span>,  <span class="hljs-string">&quot;mouseOut&quot;</span>,  <span class="hljs-string">&quot;mouseOver&quot;</span>,  <span class="hljs-string">&quot;mouseUp&quot;</span>,  <span class="hljs-string">&quot;paste&quot;</span>,  <span class="hljs-string">&quot;pause&quot;</span>,  <span class="hljs-string">&quot;play&quot;</span>,  <span class="hljs-string">&quot;playing&quot;</span>,  <span class="hljs-string">&quot;pointerCancel&quot;</span>,  <span class="hljs-string">&quot;pointerDown&quot;</span>,  <span class="hljs-string">&quot;pointerEnter&quot;</span>,  <span class="hljs-string">&quot;pointerLeave&quot;</span>,  <span class="hljs-string">&quot;pointerMove&quot;</span>,  <span class="hljs-string">&quot;pointerOut&quot;</span>,  <span class="hljs-string">&quot;pointerOver&quot;</span>,  <span class="hljs-string">&quot;pointerUp&quot;</span>,  <span class="hljs-string">&quot;progress&quot;</span>,  <span class="hljs-string">&quot;rateChange&quot;</span>,  <span class="hljs-string">&quot;reset&quot;</span>,  <span class="hljs-string">&quot;scroll&quot;</span>,  <span class="hljs-string">&quot;seeked&quot;</span>,  <span class="hljs-string">&quot;seeking&quot;</span>,  <span class="hljs-string">&quot;select&quot;</span>,  <span class="hljs-string">&quot;stalled&quot;</span>,  <span class="hljs-string">&quot;submit&quot;</span>,  <span class="hljs-string">&quot;suspend&quot;</span>,  <span class="hljs-string">&quot;timeUpdate&quot;</span>,  <span class="hljs-string">&quot;toggle&quot;</span>,  <span class="hljs-string">&quot;touchCancel&quot;</span>,  <span class="hljs-string">&quot;touchEnd&quot;</span>,  <span class="hljs-string">&quot;touchMove&quot;</span>,  <span class="hljs-string">&quot;touchStart&quot;</span>,  <span class="hljs-string">&quot;transitionEnd&quot;</span>,  <span class="hljs-string">&quot;volumeChange&quot;</span>,  <span class="hljs-string">&quot;waiting&quot;</span>,  <span class="hljs-string">&quot;wheel&quot;</span>,]</code></pre><h4 id="二、调用顺序"><a href="#二、调用顺序" class="headerlink" title="二、调用顺序"></a>二、调用顺序</h4><p>setState是不是异步的？我们从头梳理</p><p><strong>异步场景</strong></p><p>通常情况我们认为setState是异步的，看一个简单的例子：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    state = &#123;        count: <span class="hljs-number">0</span>    &#125;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">this</span>.setState(&#123;           count: <span class="hljs-number">1</span>         &#125;, <span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count) <span class="hljs-comment">//1</span>         &#125;);        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count) <span class="hljs-comment">// 0</span>    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;          ...    &#125;&#125;</code></pre><p>由于我们认为setState是异步的，所以会认为回调函数是异步回调，控制台先输出0后输出1。<br>再看一个例子：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    state = &#123;        count: <span class="hljs-number">0</span>    &#125;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">this</span>.setState(&#123;           count: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span>         &#125;, <span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count) <span class="hljs-comment">//1</span>         &#125;);         <span class="hljs-built_in">this</span>.setState(&#123;           count: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span>         &#125;, <span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count) <span class="hljs-comment">//1</span>         &#125;);    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        ...    &#125;&#125;</code></pre><p>在这个例子中，连续调用两次setState，但是React在同一个周期内会对多个setState进行批处理。相同于：</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.assign(    previousState,    &#123;<span class="hljs-attr">count</span>: state.count + <span class="hljs-number">1</span>&#125;,    &#123;<span class="hljs-attr">count</span>: state.count + <span class="hljs-number">1</span>&#125;)</code></pre><p>后调用的setState()将覆盖同一周期内先调用setState的值，因此count其实只增加1次。如果后续状态取决于当前状态，setState(updater[,callback]) 中的第一个参数建议使用函数形式的代替。</p><pre><code class="hljs js"><span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.count + <span class="hljs-number">1</span>&#125;&#125;)</code></pre><p>再看一个具有迷惑性的例子：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    state = &#123;        count: <span class="hljs-number">0</span>    &#125;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-comment">//第一次setState</span>        <span class="hljs-built_in">this</span>.setState(          preState=&gt; (&#123;            count:preState.count + <span class="hljs-number">1</span>        &#125;),<span class="hljs-function">()=&gt;</span>&#123;           <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count);<span class="hljs-comment">//2</span>        &#125;);        <span class="hljs-comment">//第二次setState</span>        <span class="hljs-built_in">this</span>.setState(          preState=&gt;(&#123;            count:preState.count + <span class="hljs-number">1</span>        &#125;),<span class="hljs-function">()=&gt;</span>&#123;           <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count);<span class="hljs-comment">//2</span>        &#125;);    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        ...    &#125;&#125;</code></pre><p>这里为什么又会输出2，2呢？当调用seState函数时，就会把当前的操作放入一个队列中。React根据队列内容，<strong>合并state数据</strong>，合并完成后再逐一执行回调，根据结果渲染虚拟DOM，触发渲染.所以回调时,state已经合并计算完成了,输出的结果就是2, 2了。</p><p>为什么React团队采用这样一种行为模式，而不是同步进行呢？一种常见的说法是：为了优化。通过异步操作的方式，累计更新后批量合并处理，减少渲染次数，提升性能。但是同步就不能批量处理吗？github上有人提出了<a href="https://github.com/facebook/react/issues/11527">为什么setState是异步的</a>这个问题，官方团队进行了回答：</p><ol><li><p>保持内部一致性。如果改为同步更新的方式，尽管setState变成了同步，但是props不是（you can’t know props until you rerender the parent component ,and if you do this synchronously, batching goes out of the window–props是同步的话，批处理将无法进行）</p></li><li><p>为后续的架构升级启用并发更新。为了完成异步渲染，react会在setState时，根据它们的数据来源分配不同的优先级，这些数据来源有：事件回调句柄、动画效果等，再根据优先级并发处理，提升渲染性能。</p></li></ol><p>从React17的角度分析，异步的设计是合理的，它可以使得异步渲染等最终能在React落地。那什么情况下它是同步的呢？</p><h4 id="三、同步场景"><a href="#三、同步场景" class="headerlink" title="三、同步场景"></a>三、同步场景</h4><p>上面的异步场景让我们觉得：setState是异步的，但是下面这个案例中，将setState放在setTimeout中，情况又完全不同了。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    state = &#123;        count: <span class="hljs-number">0</span>    &#125;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span> &#125;);        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count);<span class="hljs-comment">//0</span>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span> &#125;);          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;setTimeout: &quot;</span> + <span class="hljs-built_in">this</span>.state.count); <span class="hljs-comment">//1</span>        &#125;, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        ...    &#125;&#125;</code></pre><p>为什么会输出0，1呢？因为setState并不是真正的异步函数，<strong>它实际上是通过队列延迟执行操作实现的</strong>，通过isBatchingUpdates来判断setState是先存进state队列还是直接更新。isBatchingUpdates值为true,则执行异步操作，isBatchingUpdates值为false,则直接更新。<br><img src="https://ae02.alicdn.com/kf/Hae4f7b71dba44f14b0405b74c565c191R.png" alt="setState的执行机制"></p><p>在onClick,onFocus等事件中，由于合成事件封装了一层，所以可以将isBatchingUpdates的状态更新为true; 在React自己的生命周期和合成事件中，可以拿到isBatchingUpdates的控制权，将状态放进队列，控制执行节奏。而在外部的原生事件中，并没有外层封装和拦截，无法更新isBatchingUpdates的状态为true。这就造成isBatchingUpdates的状态只会为false, 且立即执行。所以在addEventListener、setTimeout、setInterval这些原生事件中都会同步更新。</p><h4 id="四、回答问题"><a href="#四、回答问题" class="headerlink" title="四、回答问题"></a>四、回答问题</h4><blockquote><p>setState 并非真异步，只是看上去像异步。在源码中，通过isBatchingUpdates来判断setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。</p><p>那么什么情况下 isBatchingUpdates 会为 true 呢?</p><p>A. 在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。</p><p>B. 但在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。</p><p>一般认为，做异步设计是为了性能优化、减少渲染次数，React 团队还补充了两点。</p><ol><li><p>保持内部一致性。如果将 state 改为同步更新，那尽管 state 的更新是同步的，但是 props不是。</p></li><li><p>启用并发更新，完成异步渲染。</p></li></ol></blockquote><p>可以看出，setState是异步还是同步的关键在于：更新队列。将上述过程整理为思维导图如下：</p><p><img src="https://ae02.alicdn.com/kf/Hac1e627114684a4db843b27cdfaf12edm.png" alt="setState的执行场景"></p><p><font color=green>进阶</font> — 再看一道题</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  state  = &#123;      count: <span class="hljs-number">0</span>  &#125;;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span>&#125;);    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count);<span class="hljs-comment">//0</span>    <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span>&#125;);    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count);<span class="hljs-comment">//0</span>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span>&#125;);      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count);<span class="hljs-comment">//2</span>      <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span>&#125;);      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count);<span class="hljs-comment">//3</span>    &#125;, <span class="hljs-number">0</span>);  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  &#125;&#125;;</code></pre><p>输出：0 0 2 3</p><p>分析：</p><ul><li>首先第一次和第二次的 console.log，都在 React 的生命周期事件中，所以是异步的处理方式，则输出都为 0；</li><li>而在 setTimeout 中的 console.log 处于原生事件中，所以会同步的处理再输出结果，但需要注意，虽然 count 在前面经过了两次的 this.state.count + 1，但是由于前面说的批处理和覆盖的特点，setTimeout中拿到的值是1，那么后续在 setTimeout 中的输出则是 2 和 3</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试05-如何设计React组件？</title>
    <link href="/2020/12/17/%E9%9D%A2%E8%AF%9505-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1React%E7%BB%84%E4%BB%B6%EF%BC%9F/"/>
    <url>/2020/12/17/%E9%9D%A2%E8%AF%9505-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1React%E7%BB%84%E4%BB%B6%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="面试场景5：如何设计React组件？"><a href="#面试场景5：如何设计React组件？" class="headerlink" title="面试场景5：如何设计React组件？"></a>面试场景5：如何设计React组件？</h4><p>分析问题：“如何设计React组件？”其实就是在考察你是否了解React的设计模式。</p><p>如果在实际开发中，缺乏一个指导性的设计模式，代码会非常凌乱，经常出现下面的情况：</p><ul><li>将一个页面写成一个组件</li><li>一个组件包含上千行代码</li></ul><p>这些都没有明显的模块划分，缺乏组合的思想。所以，如何将组件更好地组合，这是第一个需要探讨的问题。基于不同的业务场景，组件的组合形式是不一样的。所以，回答这个问题，可以结合具体的场景来谈。</p><h4 id="一、React组件的分类"><a href="#一、React组件的分类" class="headerlink" title="一、React组件的分类"></a>一、React组件的分类</h4><p>React社区中非常经典的分类模式：</p><ul><li><font color=blue>展示组件</font>：把只做展示、独立运行，不额外增加功能的组件称为<strong>哑组件</strong>，或<strong>无状态组件</strong>，也叫做<strong>展示组件</strong>。</li><li><font color=blue>灵巧组件</font>：把处理业务逻辑与数据状态的组件称为有<strong>状态组件</strong>，或<strong>灵巧组件</strong>（灵巧组件一定包含至少一个灵巧组件或者展示组件）</li></ul><p>展示组件的复用性更强，灵巧组件更专注于业务本身。<br><img src="https://i.bmp.ovh/imgs/2020/12/bbe88509298c9a03.png" alt="组件设计模式"></p><h4 id="二、展示组件"><a href="#二、展示组件" class="headerlink" title="二、展示组件"></a>二、展示组件</h4><p>展示组件是没有状态管理的，完全受制于外部的props控制。展示组件的<strong>通用性和复用率很高</strong>，甚至可以做到跨项目级的复用。</p><p>展示组件中最常用的是代理组件。</p><h5 id="2-1、代理组件"><a href="#2-1、代理组件" class="headerlink" title="2.1、代理组件"></a>2.1、代理组件</h5><p>代理组件用于封装常用属性，减少重复代码。</p><p>举个例子，当需要定义一个按钮的时候，需要在按钮上添加button属性：</p><pre><code class="hljs js">&lt;button type=<span class="hljs-string">&#x27;button&#x27;</span> /&gt;</code></pre><p>但是在React中使用的时候，不可能每次都写这样一段代码，过于麻烦。常见的做法就是封装：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> Button = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span>    &lt;button type=<span class="hljs-string">&#x27;button&#x27;</span> &#123;...props&#125;&gt;</code></pre><p>在开发中使用Button组件代替原生button,可以确保type一致。</p><p>在使用Antd进行开发时，也可以采用类似的设计模式：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;Button <span class="hljs-keyword">as</span> AntdButton&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;<span class="hljs-keyword">const</span> Button = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span>     &lt;AntdButton size=<span class="hljs-string">&#x27;small&#x27;</span> type=<span class="hljs-string">&#x27;primary&#x27;</span> &#123;...props&#125;/&gt;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Button;</code></pre><p>进行封装可以切断外部组件库的强依赖特性。在大厂中引入外部组件库通常要考虑两点：</p><ul><li><p>如果当前组件库不能使用了，是否可以实现业务上的无痛切换？</p></li><li><p>如果需要进行批量修改基础组件的字段，如何解决？</p></li></ul><p>代理组件的设计模式很好地解决了这两个问题。从业务上看，代理组件隔绝了Antd，仅仅是一个组件Props API层地交互。这一层如果未来需要更换，可以保证兼容、快速替换。其次，如果要修改基础组件的颜色、大小、间距，代理组件也可以相对优雅地解决。</p><p>基于这个思想，可以封装类似的其他组件，比如样式组件。</p><h5 id="2-2、样式组件"><a href="#2-2、样式组件" class="headerlink" title="2.2、样式组件"></a>2.2、样式组件</h5><p>样式组件也是一种代理组件，只是焦点放在了处理样式上。在工程实践中，我们并不会因为一个className而封装一个组件：</p><pre><code class="hljs js"><span class="hljs-comment">//一般不会这样做</span><span class="hljs-keyword">const</span> Button = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span>(    &lt;button type=<span class="hljs-string">&#x27;button&#x27;</span> className=<span class="hljs-string">&#x27;btn btn-primary&#x27;</span>&gt;)</code></pre><p>真实工程中的样式管理往往比较复杂，类似于下面这样：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> classNames <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;classNames&#x27;</span>;<span class="hljs-keyword">const</span> StyleButton =<span class="hljs-function">(<span class="hljs-params">&#123;className, primary, isHeight,...props&#125;</span>) =&gt;</span> (    &lt;Button        type=<span class="hljs-string">&#x27;button&#x27;</span>        className=&#123;classNames(<span class="hljs-string">&#x27;btn&#x27;</span>,&#123;btn-primary:primary,<span class="hljs-attr">highLight</span>:isHighLighted,&#125;className)&#125;        &#123;...props&#125;    / &gt;)</code></pre><p>如果直接使用Button,在属性上修改，对于工程代码而言就是编写大量的面条代码。而StyleButton的思路是将样式判断逻辑分离到自身上，更友好。</p><h5 id="2-3、布局组件"><a href="#2-3、布局组件" class="headerlink" title="2.3、布局组件"></a>2.3、布局组件</h5><p>布局组件的基本设计与样式组件完全一样，但是它基于自身特性做了一个小优化。</p><p>布局组件主要用于安放其他组件，类似于这样：</p><pre><code class="hljs js">&lt;Layout    Top=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">NavBar</span> /&gt;</span></span>&#125;    Content=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Article</span> /&gt;</span></span>&#125;    Bottom=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">BottomBar</span> /&gt;</span></span>&#125;/&gt;</code></pre><p>布局本身是确定的，不需要根据外部状态变化去修改内部组件，所以这也是一个减少渲染的优化点。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Layout</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-comment">//由于布局组件无需更新，就可以把shouldComponentUpdate的返回值写死，从而阻断渲染过程</span>    <span class="hljs-function"><span class="hljs-title">shouldComponentUpdate</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        &lt;div&gt;            &lt;div&gt;&#123;<span class="hljs-built_in">this</span>.props.NavBar&#125;&lt;/div&gt;            &lt;div&gt;&#123;<span class="hljs-built_in">this</span>.props.Article&#125;&lt;/div&gt;            &lt;div&gt;&#123;<span class="hljs-built_in">this</span>.props.BottomBar&#125;&lt;/div&gt;        &lt;/div&gt;    &#125;&#125;</code></pre><h4 id="三、灵巧组件"><a href="#三、灵巧组件" class="headerlink" title="三、灵巧组件"></a>三、灵巧组件</h4><p>由于灵巧组件面向业务，相对于展示组件来说，其功能更加丰富、复杂性更高，所以其复用性更低。<strong>展示组件专注于组件本身特性，灵巧组件更专注于组合组件</strong>。最常见的案例就是容器组件。</p><h5 id="3-1、容器组件"><a href="#3-1、容器组件" class="headerlink" title="3.1、容器组件"></a>3.1、容器组件</h5><p>容器组件几乎没有复用性，它主要用于：拉取数据与组合组件。<br>一个例子：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> CardList = <span class="hljs-function">(<span class="hljs-params">&#123;cards&#125;</span>) =&gt;</span> (    &lt;div&gt;        &#123;cards.map(<span class="hljs-function"><span class="hljs-params">card</span>=&gt;</span>(            &lt;CardLayout                header=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&#123;card.avatarUrl&#125;</span> /&gt;</span></span>&#125;                Content=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Card</span> &#123;<span class="hljs-attr">...card</span>&#125; /&gt;</span></span>&#125;            /&gt;            &#123;comment.body&#125; - &#123;comment.author&#125;        ))&#125;    &lt;/div&gt;)</code></pre><p>上述代码中的CardList组件，负责将cards数据渲染出来。接下来就是获取网络数据：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CardListContainer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    state=&#123; <span class="hljs-attr">cards</span>: []&#125;    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/api/cards&#x27;</span>)        <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">cards</span>:response &#125;)    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CardList</span> <span class="hljs-attr">cards</span>=<span class="hljs-string">&#123;this.state.cards&#125;</span> /&gt;</span></span>    &#125;&#125;</code></pre><p>这样切分代码后，容器组件内非常干净，没有冗余得样式和逻辑处理。其实这也用到了“关注点分离”的策略。那么面对复用性更强的业务逻辑用什么处理呢？</p><h5 id="3-2、高阶组件"><a href="#3-2、高阶组件" class="headerlink" title="3.2、高阶组件"></a>3.2、高阶组件</h5><p>React官方文档中将高阶组件称为是react中<strong>复用组件逻辑的高级技术</strong>。高阶组件本身并不是React API的一部分，它是一种基于React的组合特性而形成的设计模式。实际上，高阶组件就是以组件为参数，返回一个新组件的函数。</p><p>这听起来非常像<strong>高阶函数</strong>：如果一个函数可以接收另一个函数作为参数，且在执行后返回一个函数，则称其为高阶函数。 react团队在组件方向也汲取了同样的设计模式，源自高阶函数的高阶组件，可以优雅地抽取公共逻辑。</p><p>参考：<a href="https://zh-hans.reactjs.org/docs/higher-order-components.html#gatsby-focus-wrapper">React官网-高阶组件</a></p><p><strong>高阶组件抽取公共逻辑</strong>：</p><p>一个常见的例子，登录态的判断。假设当前项目有订单页面、用户信息页面及购物车首页，那么订单页面和用户信息页面都需要检查当前是否已登录。如果没有登录，则应该跳转至登录页面。</p><p>一般思路如下：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> checkLogin = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-comment">//!!XXX用于转为布尔值</span>    <span class="hljs-keyword">return</span> !!LocalStorage.getItem(<span class="hljs-string">&#x27;token&#x27;</span>)&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    ...&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">!checkLogin</span>)</span>&#123;            <span class="hljs-comment">//重定向到登录页面</span>        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">!checkLogin</span>)</span>&#123;            <span class="hljs-comment">//重定向到登录页面</span>        &#125;    &#125;&#125;</code></pre><p>上述代码虽然将登录态的判断抽取到了一个函数中，但是还是需要在相应的页面加上判断逻辑。如果有高阶组件的话，情况会完全不同：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> checkLogin = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-keyword">return</span> !!LocalStorage.getItem(<span class="hljs-string">&#x27;token&#x27;</span>)&#125;<span class="hljs-keyword">const</span> checkLogin = <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> checkLogin() ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span>: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoginPage</span>/&gt;</span></span>    &#125;&#125;<span class="hljs-comment">//1、函数写法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RawUserPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;    ...&#125;<span class="hljs-keyword">const</span> UserPage = checkLogin(RawUserPage);<span class="hljs-comment">//2、装饰器写法</span>@checkLogin<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    ...&#125;@checkLogin<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    ...&#125;</code></pre><p>可以看出，使用了高阶组件后，无论采用函数写法还是装饰器写法，重复代码量都下降了一个维度。<br>还有一个非常经典的常见就是<strong>页面埋点统计</strong>：如果采用装饰器写，大致如下：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> trakPageView = <span class="hljs-function">(<span class="hljs-params">pageName</span>) =&gt;</span>&#123;    <span class="hljs-comment">//发送埋点信息</span>&#125;<span class="hljs-keyword">const</span> PV = <span class="hljs-function">(<span class="hljs-params">pageName</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>)=&gt;</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;            <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;                trackPageView(pageName)            &#125;            <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;                <span class="hljs-keyword">return</span> (                    &lt;WrappedComponent &#123;...this.props&#125; /&gt;                );            &#125;        &#125;    &#125;;&#125;@PV(<span class="hljs-string">&#x27;用户页面&#x27;</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    ...&#125;@PV(<span class="hljs-string">&#x27;购物车页面&#x27;</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    ...&#125;@PV(<span class="hljs-string">&#x27;订单页面&#x27;</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    ...&#125;</code></pre><p>这样就连埋点的繁琐操作都变得优雅了起来。如果我想同时判断登录态和埋点呢？就是同时使用checkLogin 与 PV应该怎么做呢？这里涉及了一个新的概念：链式调用。</p><p><strong>链式调用</strong>：</p><p>由于高阶组件返回的是一个新的组件，所以链式调用是默认支持的。基于checkLogin 与 PV两个例子，链式使用是这样的：</p><pre><code class="hljs js"><span class="hljs-comment">//函数调用方式</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RawUserPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    ...&#125;<span class="hljs-keyword">const</span> UserPage = checkLogin(PV(<span class="hljs-string">&#x27;用户页面&#x27;</span>)(RawUserPage));<span class="hljs-comment">//装饰器调用方式</span>@checkLogin@PV(<span class="hljs-string">&#x27;用户界面&#x27;</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    ...&#125;</code></pre><p><strong>渲染劫持</strong>：</p><p>渲染劫持可以通过控制render函数修改输出内容，常见的场景是显示加载元素：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withLoding</span>(<span class="hljs-params">WrappedComponent</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WrappedComponent</span></span>&#123;        <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-built_in">this</span>.props.isLoding</span>)</span> &#123;                <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Loading</span> /&gt;</span></span>            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.render();            &#125;        &#125;    &#125;&#125;</code></pre><p>上述代码通过高阶组件继承原组件的方式，劫持修改render函数，篡改返回值，达到显示Loading的效果。但是高阶组件并非万能，它同样也有缺陷。</p><p><strong>高阶组件缺陷</strong>：</p><ol><li><font color=green>丢失静态函数</font>。 由于被包裹了一层，所以静态函数在外层是无法获取的。<pre><code class="hljs js"><span class="hljs-comment">//Userpage.jsx</span>@PV(<span class="hljs-string">&#x27;用户页面&#x27;</span>)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getUser</span>(<span class="hljs-params"></span>)</span>&#123;        ...    &#125;&#125;</code></pre>这里的getUser是无法被调用的，如果希望外界可以调用它，那么可以在PV函数中将静态函数复制过来。</li></ol><pre><code class="hljs js"><span class="hljs-keyword">const</span> PV = <span class="hljs-function">(<span class="hljs-params">pageName</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span>&#123;        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;            <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;                trackPageView(pageName)            &#125;            <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;                <span class="hljs-keyword">return</span> (                    &lt;WrappedComponent &#123;...props&#125; /&gt;                )            &#125;        &#125;        Wrap.getUser = WrappedComponent.getUser;        <span class="hljs-keyword">return</span> Wrap;    &#125;&#125;</code></pre><p>但是一个类的静态函数可能有很多，不可能都这样进行手动复制。于是，社区中出现了现成的工具：通过hoist-non-react-statics处理，可以自动复制所有静态函数。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> hoistNonReactStatics <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;hoist-non-react-statics&#x27;</span>;<span class="hljs-keyword">const</span> PV = <span class="hljs-function">(<span class="hljs-params">pageName</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> &#123;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;      <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;        trackPageView(pageName)      &#125;      <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> (          &lt;WrappedComponent &#123;...this.props&#125; /&gt;        );      &#125;    &#125;     hoistNonReactStatics(Wrap, WrappedComponent);     <span class="hljs-keyword">return</span> Wrap;  &#125;; &#125;</code></pre><ol start="2"><li><font color=green>refs属性不能透传。</font> ref属性由于被高阶组件包裹了一次，所以需要进行特殊处理才能获取。React为我们提供了一个React.forwardRef 的API来解决这个问题，以下是官方文档的一个案例：</li></ol><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withLog</span>(<span class="hljs-params">Component</span>) </span>&#123;  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogProps</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params">prevProps</span>)</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;old props:&#x27;</span>, prevProps);      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;new props:&#x27;</span>, <span class="hljs-built_in">this</span>.props);    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;      <span class="hljs-keyword">const</span> &#123;forwardedRef, ...rest&#125; = <span class="hljs-built_in">this</span>.props;      <span class="hljs-comment">// 将自定义的 prop 属性 “forwardedRef” 定义为 ref</span>      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;forwardedRef&#125;</span> &#123;<span class="hljs-attr">...rest</span>&#125; /&gt;</span></span>;    &#125;  &#125;  <span class="hljs-comment">// 注意 React.forwardRef 回调的第二个参数 “ref”。</span>  <span class="hljs-comment">// 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”</span>  <span class="hljs-comment">// 然后它就可以被挂载到被 LogProps 包裹的子组件上。</span>  <span class="hljs-keyword">return</span> React.forwardRef(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LogProps</span> &#123;<span class="hljs-attr">...props</span>&#125; <span class="hljs-attr">forwardedRef</span>=<span class="hljs-string">&#123;ref&#125;</span> /&gt;</span></span>;  &#125;);&#125;</code></pre><p>这段代码读起来会有点儿头皮发麻，它正确的阅读顺序应该是从最底下的 React.forwardRef 部分开始，通过 forwardedRef 转发 ref 到 LogProps 内部。</p><p>参考：<a href="https://zh-hans.reactjs.org/docs/react-api.html#reactforwardref">React官网 - React.forwardRef</a></p><h4 id="四、工程实践"><a href="#四、工程实践" class="headerlink" title="四、工程实践"></a>四、工程实践</h4><p>通过以上的梳理，我们来看一下如何在目录中给组件安排位置。</p><pre><code class="hljs js">src├── components│   ├── basic(基本展示组件)│   ├── container(容器组件)│   └── hoc(高阶组件)└── pages</code></pre><p>在实际开发中，针对basic组件，可以使用StoryBook的工具进行组件管理。它可以有组织地、高效地构建基础组件。可参考<a href="https://storybook.js.org/">Storybook官网</a>。</p><h4 id="五、答题"><a href="#五、答题" class="headerlink" title="五、答题"></a>五、答题</h4><p>经过上面几个章节的归类分析，关于React组件的设计，我们应该从设计与工程实际两个方向探讨。</p><blockquote><p>从设计上而言，社区主流分类的方案是展示组件与灵巧组件。</p><p>展示组件内部没有状态管理，仅仅用于最简单的展示表达。展示组件中最基础的一类组件称作代理组件。代理组件常用于封装常用属性、减少重复代码。很经典的场景就是引入 Antd 的 Button 时，你再自己封一层。如果未来需要替换掉 Antd 或者需要在所有的 Button 上添加一个属性，都会非常方便。基于代理组件的思想还可以继续分类，分为样式组件与布局组件两种，分别是将样式与布局内聚在自己组件内部。</p><p>灵巧组件由于面向业务，其功能更为丰富，复杂性更高，复用度低于展示组件。最经典的灵巧组件是容器组件。在开发中，我们经常会将网络请求与事件处理放在容器组件中进行。容器组件也为组合其他组件预留了一个恰当的空间。还有一类灵巧组件是高阶组件。高阶组件被 React 官方称为 React 中复用组件逻辑的高级技术，它常用于抽取公共业务逻辑或者提供某些公用能力。常用的场景包括检查登录态，或者为埋点提供封装，减少样板代码量。高阶组件可以组合完成链式调用，如果基于装饰器使用，就更为方便了。高阶组件中还有一个经典用法就是反向劫持，通过重写渲染函数的方式实现某些功能，比如场景的页面加载圈等。但高阶组件也有两个缺陷，第一个是静态方法不能被外部直接调用，需要通过向上层组件复制的方式调用，社区有提供解决方案，使用 hoist-non-react-statics 可以解决；第二个是 refs 不能透传，使用 React.forwardRef API 可以解决。</p><p>从工程实践而言，通过文件夹划分的方式切分代码。我初步常用的分割方式是将页面单独建立一个目录，将复用性略高的 components 建立一个目录，在下面分别建立 basic、container 和 hoc 三类。这样可以保证无法复用的业务逻辑代码尽量留在 Page 中，而可以抽象复用的部分放入 components 中。其中 basic 文件夹放展示组件，由于展示组件本身与业务关联性较低，所以可以使用 Storybook 进行组件的开发管理，提升项目的工程化管理能力。</p></blockquote><p>整理为思维导图如下：<br><img src="https://pic.downk.cc/item/5fdc10213ffa7d37b31b801d.jpg" alt="React组件设计"></p><p><strong>总结</strong>:</p><p>在本讲中主要对 React 组件的设计模式进行了梳理与回顾，并探讨了设计模式在工程实践中的作用。</p><p>在面试中面试官不仅希望听到设计模式有哪些，社区的推荐方式有哪些，更希望听到模式具体用在哪儿。如果你知道具体的场景，就会显得更有经验。设计模式并非有确定的标准答案，社区流行的分类方式也并非万能。如果你有自己的见解，在面试中与面试官进行探讨，也是非常值得鼓励的。</p>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试04-类组件与函数组件有什么区别呢？</title>
    <link href="/2020/12/10/%E9%9D%A2%E8%AF%9504-%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F/"/>
    <url>/2020/12/10/%E9%9D%A2%E8%AF%9504-%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="面试场景4：类组件与函数组件有什么区别？（比较题）"><a href="#面试场景4：类组件与函数组件有什么区别？（比较题）" class="headerlink" title="面试场景4：类组件与函数组件有什么区别？（比较题）"></a>面试场景4：类组件与函数组件有什么区别？（比较题）</h4><p>描述区别，就是求同存异的过程：</p><ul><li>在确认共性的基础上，才能找到它独特的个性</li><li>通过具体的场景逐个阐述它的个性。</li></ul><p>针对“ 类组件与函数组件有什么区别呢？”这个面试题，面试官想知道的是：</p><ul><li>你对组件的两种编写模式是否了解</li><li>你是否具备在合适的场景下选用合适技术栈的能力</li></ul><h4 id="一、函数组件与类组件的相同点"><a href="#一、函数组件与类组件的相同点" class="headerlink" title="一、函数组件与类组件的相同点"></a>一、函数组件与类组件的相同点</h4><p>&emsp;组件是Rect可复用的最小代码片段，它们会返回要在页面中渲染的React元素。也正因为组件时React的最小编码单位，所以无论时类组件还是函数组件，在基本使用方式和最终呈现的效果上都时完全一致的。<strong>函数组件和类组件作为组件本省的所有基础功能都是一致的，都可以用它们作为基础组件展示UI。</strong></p><p>&emsp;从使用者的角度看，很难从使用体验上区分两者，而且在现代浏览器中，闭包和类的性能只有在极端场景下才有明显的差别。你甚至可以将一个类组件改写为函数组件，或者把函组件改成一个类组件（虽然不推荐这种重构）</p><p>&emsp;基本上可以认为两种组件时完全一致的。</p><h4 id="二、函数组件与类组件的不同点"><a href="#二、函数组件与类组件的不同点" class="headerlink" title="二、函数组件与类组件的不同点"></a>二、函数组件与类组件的不同点</h4><p><strong>1、两种组件代表了两种不同的设计思想与心智模式。</strong></p><ul><li>类组件的根基是OOP(面向对象编程)，所以它有继承、有属性、有内部状态的管理。</li><li>函数组件的根基是FP（函数式编程），它属于结构化编程的一种，与数学函数思想类似。也就是假定输入与输出存在某种特定的映射关系，那么在输入一定的情况下，输出必然是确定的。</li></ul><p>本质上两者最大的不同：<strong>相比较于类组件，函数组件更纯粹、简单、易于测试。</strong></p><p>（函数组件的确定性：在函数组件的闭包中，它捕获的值永远是确定且安全的。也叫<font color=green>值捕获特性</font>）</p><p><strong>2、类组件的独有能力 VS  函数组件+Hooks</strong></p><p><strong>类组件可以通过生命周期包装业务逻辑，这是类组件所特有的。</strong> 我们可以在componentDidMount、componentWillUnmout、shouldComponentUpdate等生命周期完成一些业务逻辑。 </p><p>在还没有Hooks的年代，函数组件的能力很弱，只能用高阶组件包裹函数组件模拟生命周期，但是这样做并没有解决业务逻辑掺杂在生命周期中的问题。后来React团队引入了Hooks,并基于Hooks创建了一个完全耳目一新的方案：不是让函数组件去模仿类组件的功能，而是提供新的开发模式，让组件渲染和业务逻辑更加分离。</p><p>小结：在Hooks的加持下，函数式组件也可以实现类似生命周期的能力，类组件所特有的生命周期也不再是其独有的功能。类组件与函数组件的边界模糊化。</p><p><strong>3、设计模式</strong></p><p>在设计模式上，因为类本身的特点，类组件是可以实现继承的，而函数组件缺少继承的能力。 但是React本身有条铁律：<strong>组合优于继承</strong>。并不推崇继承已有组件，因为继承的灵活性更差，细节屏蔽过多。</p><p><strong>4、性能优化</strong></p><p>类组件和函数组件进行性能优化的方式: </p><ul><li>类组件的优化主要是依靠 shouldComponentUpdate函数去阻断渲染</li><li>函数组件一般是靠React.memo来优化。React.memo并不是去阻断渲染，具体参考<a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo">官方文档-React.memo</a></li></ul><p><strong>5、未来的趋势</strong></p><p>由于React Hooks的推出，<strong>函数组件成了社区未来主推的方案</strong>。React从实际业务出发，探索了时间切片与并发模式，考虑性能的进一步优化与组件间合理的代码拆分结构后，认为类组件并不能很好的适应未来的趋势，并给出了3个原因：</p><ul><li>this指代的模糊性</li><li>业务逻辑散落在生命周期中</li><li>React的组件代码缺乏标准的拆分方式</li></ul><p>而使用了Hooks的函数组件可以提供比原先更细粒度的逻辑组织与复用，且能更好地适用于时间切片与并发模式。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><img src="https://pic.downk.cc/item/5fd4636c3ffa7d37b3de82b8.jpg" alt="函数组件与类组件的区别"></p><p><font color=red>答题：</font></p><blockquote><p>作为组件而言，类组件与函数组件在使用与呈现上没有任何不同，性能上在现代浏览器中也不会有明显差异。<br>它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。</p><p>之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。</p><p>但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。</p><p>其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。</p><p>性能优化上，类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能，而函数组件依靠 React.memo 缓存渲染结果来提升性能。</p><p>从上手程度而言，类组件更容易上手，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的方案。</p><p>类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>React05-受控组件与非受控组件</title>
    <link href="/2020/12/09/React05-%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/"/>
    <url>/2020/12/09/React05-%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="Controlled-Components-VS-unControlled-Components"><a href="#Controlled-Components-VS-unControlled-Components" class="headerlink" title="Controlled Components VS unControlled Components"></a>Controlled Components VS unControlled Components</h3><h4 id="一、非受控组件"><a href="#一、非受控组件" class="headerlink" title="一、非受控组件"></a>一、非受控组件</h4><p>先看一个非受控组件的例子：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span>(    &lt;div&gt;        &lt;label&gt;            My uncontrolled Input:            &lt;input type=<span class="hljs-string">&#x27;text&#x27;</span>/&gt;        &lt;/label&gt;    &lt;/div&gt;)</code></pre><p>上述代码中的input是不受控制的HTML元素，通常我们也将封装了这种元素的APP组件称为是 “非受控组件”。</p><p>🐖：判断一个组件受控与否，跟它是函数组件还是类组件没有关系！</p><p>这里的input是不受控的，因为当我们启动这个application后，我们可以在输入框种编辑任何内容，但是我们编辑出来的东西没有展示在其他任何地方，也没有任何行为看可以去改变我们打进去的值。毕竟，这里的input就是一个原生的HTML元素，它自己管理自己的内部状态，而不受任何外界的控制。</p><p>我们再来看另外一个例子，这个例子更容易让我们混淆受控组件与非受控组件：</p><pre><code class="hljs js"><span class="hljs-comment">//添加state management 和 React Hooks</span><span class="hljs-keyword">import</span> React, &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">const</span> [value, setValue] = useState(<span class="hljs-string">&#x27;&#x27;</span>);    <span class="hljs-keyword">const</span> handleChange = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> setValue(event.target.value);    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;label&gt;                My still uncontrolled Input:                &lt;input type=<span class="hljs-string">&#x27;text&#x27;</span> onChange=&#123;handleChange&#125; /&gt;            &lt;/label&gt;            &lt;p&gt;                &lt;strong&gt;Output: &lt;/strong&gt; &#123;value&#125;            &lt;/p&gt;        &lt;/div&gt;    );&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>我们把在输入框编辑的内容展示到一个段落中（output的后面），当我们启动这个程序后，input输入框编辑什么，output后面也会展示什么。但是，它依然是个非受控组件。这是为什么呢？下面我们把initialState里面写入内容，来解释这个问题：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">const</span> [value, setValue] = useState(<span class="hljs-string">&#x27;Hello React&#x27;</span>);    <span class="hljs-keyword">const</span> handleChange = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> setValue(event.target.value);    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;label&gt;                My still uncontrolled Input:                &lt;input type=<span class="hljs-string">&#x27;text&#x27;</span> onChange=&#123;handleChange&#125; /&gt;            &lt;/label&gt;            &lt;p&gt;                &lt;strong&gt;Output: &lt;/strong&gt; &#123;value&#125;            &lt;/p&gt;        &lt;/div&gt;    );&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>运行这个程序后，我们可以看到区别了：<br><img src="https://pic.downk.cc/item/5fd0c0543ffa7d37b335df1a.jpg"></p><p>我们可以看到 input框里是空的，可是output后面却是有内容的（output后面展示的就是initial state）。只有当我们往输入框中输入东西时，二者才似乎重新开始保持“同步”。但其实，<strong>input框的内容仍然是它自己的内部状态，而output后面的内容却来自于真实的React state</strong>(from handler function)。所以when typing, output后面展示的内容虽然看起来似乎和我们在输入框打进去的一样，但其实它们俩的来源不同：</p><ul><li>input filed receives its value from internal DOM node state;</li><li>output paragraph receives its value from React’s state。</li></ul><p>在我们的React应用中使用非受控组件，可能会导致很多意想不到的bug。如果想利用一种事实来源（one source of truth)来驱动UI，就应该使用props或者是state。对于一个组件来说，有相同的props和state，就应该渲染出相同的UI界面：<strong>（props, state) =&gt; view</strong></p><h4 id="二、受控组件"><a href="#二、受控组件" class="headerlink" title="二、受控组件"></a>二、受控组件</h4><p>既然非受控组件可能导致bug, 那么我们就应该把input这种不受控制的元素改为受控元素。亦即，我们为input提供一个value (它的值来源于 React state)：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>; <span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> [value, setValue] = useState(<span class="hljs-string">&#x27;Hello React&#x27;</span>);   <span class="hljs-keyword">const</span> handleChange = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> setValue(event.target.value);   <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;label&gt;        My controlled Input:        &lt;input type=<span class="hljs-string">&quot;text&quot;</span> value=&#123;value&#125; onChange=&#123;handleChange&#125; /&gt;      &lt;/label&gt;       &lt;p&gt;        &lt;strong&gt;Output:&lt;/strong&gt; &#123;value&#125;      &lt;/p&gt;    &lt;/div&gt;  );&#125;; <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>通过给input输入框提供一个来源于react state的value值，它就不再使用自己本身的内部状态了。现在，我们再来启动这个程序时，input输入框里的值和output后面展示的内容就完全一致了！（因为它们都来自于react state）<br><img src="https://pic.downk.cc/item/5fd0c4643ffa7d37b33a6f41.jpg"></p><p>参考：<a href="https://www.robinwieruch.de/react-controlled-components">What are Controlled Components in React?</a></p>]]></content>
    
    
    <categories>
      
      <category>React学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>React04-函数组件</title>
    <link href="/2020/12/09/React04-%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6/"/>
    <url>/2020/12/09/React04-%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="React-Function-Components"><a href="#React-Function-Components" class="headerlink" title="React Function Components"></a>React Function Components</h3><p>&emsp; React函数组件是编写现代React应用程序的常用方式，自从React Hook被引入之后，使得完全使用函数式组件来编写一个React应用程序成为可能。函数式组件的核心：就是一个返回JSX的JavaScript函数。</p><h4 id="一、一个简单的函数组件的例子"><a href="#一、一个简单的函数组件的例子" class="headerlink" title="一、一个简单的函数组件的例子"></a>一、一个简单的函数组件的例子</h4><p>函数式组件的例子：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> greeting = <span class="hljs-string">&#x27;hello function component!&#x27;</span>;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;greeting&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>从上述代码中，我们可以注意到函数式组件中并没有类class组件里有的render()函数。实际上，函数主体里面定义的内容都是render函数，该函数最后返JSX。</p><p>如果想在React函数组件里面，再渲染一个组件，可以像下面这样写：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">//将Headline组件作为HTML元素，以JSX的方式渲染出来</span>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Headine</span> /&gt;</span></span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Headeline</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> greeting = <span class="hljs-string">&#x27;hello function component!&#x27;</span>;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;greeting&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><h4 id="二、函数组件的参数Props"><a href="#二、函数组件的参数Props" class="headerlink" title="二、函数组件的参数Props"></a>二、函数组件的参数Props</h4><p>&emsp;在React中，props被用于组件与组件之间传递信息（父组件通过props传递信息给子组件）。Essentially props in React are always passed down the component tree;</p><p>一个使用props的例子：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> greeting = <span class="hljs-string">&#x27;hello function component&#x27;</span>;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Headline</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&#123;greeting&#125;</span> /&gt;</span></span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Headline</span>(<span class="hljs-params">props</span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;props.value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>由于props通常都是一个对象，我们也可以使用JS 对象解构的方式从props中抽取我们想要的信息。比如上面的Headline组件也可以写成下面的形式：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Headline</span>(<span class="hljs-params">&#123;value&#125;</span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&#125;<span class="hljs-comment">//需要解构多个信息出来时：</span><span class="hljs-comment">//function Headline(&#123;value1,value2&#125;)&#123;...&#125;</span></code></pre><p>关于props的更多使用：可以参考<a href="https://www.robinwieruch.de/react-pass-props-to-component">How to pass props to components in React</a></p><h4 id="三、React-箭头函数组件"><a href="#三、React-箭头函数组件" class="headerlink" title="三、React 箭头函数组件"></a>三、React 箭头函数组件</h4><p>&emsp;箭头函数组件 Arrow Funciton Components(or Lambda Function Component)，是随着ES6箭头函数的出现，引入到React中的。</p><p>用箭头函数重构上面的函数组件例子：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App=<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">const</span> greeting = <span class="hljs-string">&#x27;hello function components!&#x27;</span>;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Headline</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;greeting&#125;</span> /&gt;</span></span>&#125;;<span class="hljs-keyword">const</span> Headline=<span class="hljs-function">(<span class="hljs-params">&#123;value&#125;</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&#125;;<span class="hljs-comment">//根据箭头函数的简写规则，上面的Headline可以简写为：</span><span class="hljs-keyword">const</span> Headline = <span class="hljs-function">(<span class="hljs-params">&#123;value&#125;</span>) =&gt;</span>     &lt;h1&gt;&#123;value&#125;&lt;/h1&gt;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><h4 id="四、Stateless-Function-Component"><a href="#四、Stateless-Function-Component" class="headerlink" title="四、Stateless Function Component"></a>四、Stateless Function Component</h4><p>&emsp;到目前为止，我们写的例子里都是无状态的函数组件。它们仅仅接收一个props,然后返回一个输出【以JSX：（props)=&gt;JSX】。 这种类型的组件不需要管理state，也没有任何副作用（例如，接受浏览器的本地存储），所以我们称为“Stateless Function Component”，因为它们是无状态的且以一个函数的形式表达出来。然而，React Hooks使得函数式组件有state成为可能。</p><h4 id="五、有state的函数组件"><a href="#五、有state的函数组件" class="headerlink" title="五、有state的函数组件"></a>五、有state的函数组件</h4><p>&emsp;现在我们先移除上面例子中函数组件里的所有props:</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>; <span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Headline</span> /&gt;</span></span>;&#125;; <span class="hljs-keyword">const</span> Headline = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> greeting = <span class="hljs-string">&#x27;Hello Function Component!&#x27;</span>;   <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;greeting&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;&#125;; <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>这样，使用这个application的用户就没法和它进行任何交互，也无法改变greeting变量。The application is static and not interactive at all。  State就是让React组件变得可交互，React Hooks 帮助我们实现函数式组件也可以使用state。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App=<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Headline</span> /&gt;</span></span>;&#125;<span class="hljs-keyword">const</span> Headline=<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">const</span> [greeting , setGreeting] = useState(        <span class="hljs-string">&#x27;hello function component!&#x27;</span>    );    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;greeting&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>useState hook函数将初始状态作为参数，返回一个数组（当前的state是这个数组的第一个元素，用于改变state的函数时这个数组的第二个元素）。我们使用了数组解构的方式来获取这个数组的元素。而且数组解构允许我们自己为变量命名。</p><p>现在，让我们添加一个input field 来改变state（使用setGreeting):</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App=<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Headline</span> /&gt;</span></span>;&#125;<span class="hljs-keyword">const</span> Headline=<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">const</span> [greeting , setGreeting] = useState(        <span class="hljs-string">&#x27;hello function component!&#x27;</span>    );    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;h1&gt;&#123;greeting&#125;&lt;h1&gt;                        &lt;input                type=<span class="hljs-string">&#x27;text&#x27;</span>                value=&#123;greeting&#125;                onChange=&#123;<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> setGreeting(event.target.value)&#125;            /&gt;        &lt;/div&gt;    )&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>上述代码中，我们通过在input中添加一个event handler，这样当input中的值变化时我们就可以利用回调函数做一些事情。回调函数的参数event是一个拥有当前input域中value值的<a href="https://reactjs.org/docs/events.html">synthetic React event</a>，亦即event.target.value，被用来更新函数组件的state。后续，我们会将这个onChange事件提取出来。</p><p>🐖：这个input field 可以接受这个组件的state值。当我们想控制input的value（state）而不想让原生的HTML元素的内部状态接管input中的值时，我们可以使用组件的state值。这时，这个input就成为了”受控组件”<a href="https://www.robinwieruch.de/react-controlled-components">controlled component</a>。</p><h4 id="六、函数组件：event-handler"><a href="#六、函数组件：event-handler" class="headerlink" title="六、函数组件：event handler"></a>六、函数组件：event handler</h4><p>在第五节中，我们给input元素添加了一个onChange事件，这样我们随时可以观察到input内容的变化。但是上一节中我们使用的是内联的箭头函数给onChange事件赋值。我们可以把它抽取出来作为一个命名函数:</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Headline</span> /&gt;</span></span>;&#125;<span class="hljs-keyword">const</span> Headline = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-keyword">const</span> [greeting, setGreeting] = useState(<span class="hljs-string">&#x27;hello function component&#x27;</span>)&#125;<span class="hljs-comment">//这里就是提取出来的命名函数</span><span class="hljs-keyword">const</span> handleChange = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span>setGreeting(event.target.value);<span class="hljs-keyword">return</span>(    &lt;div&gt;        &lt;h1&gt;&#123;greeting&#125;&lt;/h1&gt;        &lt;input type=<span class="hljs-string">&#x27;text&#x27;</span> value=&#123;greeting&#125; onChange = &#123;handleChange&#125; /&gt;    &lt;/div&gt;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><h4 id="七、父组件给子组件传值-包括callback-function"><a href="#七、父组件给子组件传值-包括callback-function" class="headerlink" title="七、父组件给子组件传值(包括callback function)"></a>七、父组件给子组件传值(包括callback function)</h4><p>在第六节中的例子中，我们把所有的逻辑（包括变量和函数）都放在了子组件，也就是Headline中。父组件没有向子组件传递props,。这一节，我们将把greeting和onChange事件的处理逻辑都放在父组件App中，再通过props传递给子组件Headline。如下所示：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React,&#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-keyword">const</span> [greeting, setGreeting] = useState(<span class="hljs-string">&#x27;hello function component&#x27;</span>);    <span class="hljs-keyword">const</span> handleChange = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> setGreeting(event.target.value);    <span class="hljs-keyword">return</span> (        &lt;Headline headline = &#123;greeting&#125; onChangeHeadline = &#123;handleChange&#125; /&gt;    )&#125;<span class="hljs-keyword">const</span> Headline = <span class="hljs-function">(<span class="hljs-params">&#123;headline,onChangeHeadline&#125;</span>) =&gt;</span> (    &lt;div&gt;        &lt;h1&gt;&#123;headline&#125;&lt;/h1&gt;        &lt;input type=<span class="hljs-string">&#x27;text&#x27;</span> value=&#123;headline&#125; onChange=&#123;onChangeHeadline&#125;/&gt;    &lt;/div&gt;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>进一步地，我们还可以把input抽取出来，使其到单独成为一个组件。从而，我们有个一个父组件App，两个子组件Headline和Input。父组件向两个子组件传递props:</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React,&#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-keyword">const</span> [greeting, setGreeting] = useState(<span class="hljs-string">&#x27;hello function component&#x27;</span>);    <span class="hljs-keyword">const</span> handleChange = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span>setGreeting(event.target.value);    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;Headline headline=&#123;greeting&#125; /&gt;            &lt;Input value=&#123;greeting&#125; onChangeInput=&#123;handleChange&#125;&gt;<span class="hljs-built_in">Set</span> Greeting: &lt;/Input&gt;        &lt;/div&gt;    )&#125;;<span class="hljs-keyword">const</span> Headline = <span class="hljs-function">(<span class="hljs-params">&#123;headline&#125;</span>) =&gt;</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;headline&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-keyword">const</span> Input = <span class="hljs-function">(<span class="hljs-params">&#123;value,onChangeInput, children&#125;</span>) =&gt;</span>(    &lt;label&gt;    &#123;children&#125;    &lt;input type=<span class="hljs-string">&#x27;text&#x27;</span> value=&#123;value&#125; onChange = &#123;onChangeInput&#125; /&gt;    &lt;/label&gt;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><h4 id="八、设置props的默认值"><a href="#八、设置props的默认值" class="headerlink" title="八、设置props的默认值"></a>八、设置props的默认值</h4><p>当父组件给子组件传递props的时候，我们可以在子组件中为这些props设置默认值（default value）去override传递的值。亦即，当父组件传递的props不为空时，我们就使用传递过来的，否则我们就使用子组件的默认值。</p><p>给子组件的props设置默认值,有以下三种方式：</p><pre><code class="hljs js"><span class="hljs-comment">//第一种：</span><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-keyword">const</span> sayHello = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">handleClick</span>=<span class="hljs-string">&#123;sayHello&#125;</span> /&gt;</span></span>&#125;;<span class="hljs-keyword">const</span> Button = <span class="hljs-function">(<span class="hljs-params">&#123;handleClick&#125;</span>) =&gt;</span>&#123;    <span class="hljs-keyword">const</span> sayDefault = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;default&#x27;</span>);    <span class="hljs-keyword">const</span> onClick = handleClick || sayDefault;    <span class="hljs-keyword">return</span> (        &lt;button type=<span class="hljs-string">&#x27;button&#x27;</span> onClick=&#123;onClick&#125;&gt;            Button        &lt;/button&gt;    )&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>我们也可以在子组件的函数签名（小括号内）为props设置默认值：</p><pre><code class="hljs js"><span class="hljs-comment">//第二种：</span><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> sayHello = <span class="hljs-function">() =&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello&#x27;</span>);    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">handleClick</span> = <span class="hljs-string">&#123;sayHello&#125;</span> /&gt;</span></span>&#125;;<span class="hljs-keyword">const</span> Button = (&#123;handleClick = <span class="hljs-function">()=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;default&#x27;</span>)&#125;) =&gt; (    &lt;button onClick=&#123;handleClick&#125;&gt;        Button    &lt;/button&gt;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>最后一种，我们也可以通过为函数组件增加defaultProps属性的方式来设置默认值：</p><pre><code class="hljs js"><span class="hljs-comment">//第三种：</span><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> sayHello = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello&#x27;</span>);   <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">handleClick</span>=<span class="hljs-string">&#123;sayHello&#125;</span> /&gt;</span></span>;&#125;; <span class="hljs-keyword">const</span> Button = <span class="hljs-function">(<span class="hljs-params">&#123;handleClick&#125;</span>) =&gt;</span>(    &lt;button onClick=&#123;handleClick&#125;&gt;        Button    &lt;/button&gt;);Button.defaultProps = &#123;    handleClick: <span class="hljs-function">()=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;default&#x27;</span>);&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><h4 id="九、React组件中的异步函数"><a href="#九、React组件中的异步函数" class="headerlink" title="九、React组件中的异步函数"></a>九、React组件中的异步函数</h4><p>让我们先来看一个异步函数的例子：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-comment">//通过setTimeout实现一个异步延迟执行</span>    <span class="hljs-keyword">const</span> sayHello = <span class="hljs-function">() =&gt;</span>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>),<span class="hljs-number">1000</span>);    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">handleClick</span> = <span class="hljs-string">&#123;sayHello&#125;</span> /&gt;</span></span>&#125;;<span class="hljs-keyword">const</span> Button = <span class="hljs-function">(<span class="hljs-params">&#123;handleClick&#125;</span>) =&gt;</span>(    &lt;button onClick=&#123;handleClick&#125;&gt;        Button    &lt;/button&gt;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;<span class="hljs-string">``</span><span class="hljs-string">` </span><span class="hljs-string"></span><span class="hljs-string">下面再看一个例子，通过使用setTimeout造成延迟执行的情况下，如何更新state。</span><span class="hljs-string"></span><span class="hljs-string">`</span><span class="hljs-string">``</span>js<span class="hljs-keyword">import</span> React, &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);    <span class="hljs-keyword">const</span> handleIncrement = <span class="hljs-function">() =&gt;</span>            <span class="hljs-built_in">setTimeout</span>(                <span class="hljs-comment">//这里很容易写成setCount(count+1),错！</span>                ()=&gt;setCount(<span class="hljs-function"><span class="hljs-params">count</span>=&gt;</span>count+<span class="hljs-number">1</span>),                <span class="hljs-number">1000</span>            );        <span class="hljs-keyword">const</span> handleDecrement = <span class="hljs-function">() =&gt;</span>            <span class="hljs-built_in">setTimeout</span>(                <span class="hljs-comment">//这里很容易写成setCount(count-1),错！</span>                ()=&gt;setCount(<span class="hljs-function"><span class="hljs-params">count</span>=&gt;</span>count-<span class="hljs-number">1</span>),                <span class="hljs-number">1000</span>            );    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;            &lt;Button handleClick=&#123;handleIncrement&#125;&gt;增加<span class="hljs-number">1</span>&lt;/Button&gt;            &lt;Button handleClick=&#123;handleDecrement&#125;&gt;减少<span class="hljs-number">1</span>&lt;/Button&gt;        &lt;/div&gt;    );    <span class="hljs-keyword">const</span> Button = <span class="hljs-function">(<span class="hljs-params">&#123;handleClick,children&#125;</span>) =&gt;</span>(        &lt;button onClick=&#123;handleClick&#125;&gt;&#123;children&#125;&lt;/button&gt;    );<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>注意观察上述代码是如何更新当前的count值的，我们通过使用setCount 状态函数来更新state。由于来源于useState的setter function 本质上是异步执行的，因此必须确保是对当前状态而不是任何过时状态执行更新。</p><p>了解更多，可参考<a href="https://www.robinwieruch.de/react-hooks-fetch-data"> how to fetch data with Function Components with React Hooks.</a></p><h4 id="十、函数组件中的生命周期实现——LifeCyrcle"><a href="#十、函数组件中的生命周期实现——LifeCyrcle" class="headerlink" title="十、函数组件中的生命周期实现——LifeCyrcle"></a>十、函数组件中的生命周期实现——LifeCyrcle</h4><p>如果你之前使用过类组件，一定用过componentDidMout、componentWillUnmount、shouldComponentUpdate等生命周期方法。但是在函数组件中没有这些方法，让我们看看如何在函数式组件中实现它们。</p><p>首先，在函数组件中没有constructor。在类组件中，constructor通常被用来设置initial state。但是在函数组件中我们使用useState hook就可以设置initial state，并且可以同时得到一个setter function 用于之后的业务逻辑。<br><img src="https://pic.downk.cc/item/5fd185883ffa7d37b3e1c35a.jpg"></p><p><strong>1.Funcitonal Component:  Mount</strong></p><p>react组件在第一次渲染的时候，会有一个mounting的阶段。如果你想在函数式组件里，当组件<strong>did mount</strong>的时候执行一些逻辑，可以使用<strong>useEffect</strong> hook:</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React ,&#123; useState, useEffect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);    <span class="hljs-keyword">const</span> handleIncrement = <span class="hljs-function">() =&gt;</span>        setCount(<span class="hljs-function"><span class="hljs-params">currentCount</span> =&gt;</span> currntCount+<span class="hljs-number">1</span>);        <span class="hljs-keyword">const</span> handleDecrement = <span class="hljs-function">() =&gt;</span>        setCount(<span class="hljs-function"><span class="hljs-params">currentCount</span> =&gt;</span> currntCount-<span class="hljs-number">1</span>);    useEffect(<span class="hljs-function">()=&gt;</span>setCount(<span class="hljs-function"><span class="hljs-params">currentCount</span> =&gt;</span> currentCount + <span class="hljs-number">1</span>),[]);    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;            &lt;button onClick=&#123;handleIncrement&#125;&gt;Increment&lt;/button&gt;            &lt;button onClick=&#123;handleDecrement&#125;&gt;Decrement&lt;/button&gt;        &lt;/div&gt;    )&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>当我们运行这段代码的时候，这个组件第一次渲染时会显示count的初始状态值0，然后当component did mount后，Effect hook 会将count设置为1。</p><p>🐖：Effect hook中的第二个参数（1个空数组）是非常重要的，它确保了只有在这个组件加载（mount)或者组件卸载（unmount)时才触发事件。如果不小心漏掉了这个空数组，我们会陷入count不断加1的死循环，因为当state更新了Effect hook总是会执行。然后Effect执行又会触发state更新，这样就会不停地对count+1<br><font color=green>todo: 这里为什么要用空数组而不是别的呢？？</font></p><p><strong>2.Funcitonal Component:  Update</strong></p><p>每次当入参props或者是组件本身的state变化时，react组件就会重新渲染以展示最新的status(from props and state)。在函数式组件中，一次render会执行函数体的所有内容。</p><p>如果函数组件没有正确地按照预期更新，我们可以在组件中使用console.log控制台输出state和props的值来debug。如果这两者的值都没有发生变化，就不会有新的render执行。<br><img src="https://pic.downk.cc/item/5fd1ca843ffa7d37b32b3cee.jpg"></p><p>如果我们想对组件重新渲染进行操作，我们可以再一次使用 Effect Hook (在组件did update之后)：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;useEffect, useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-comment">//count的初始值来源于本地存储中的值或0</span>    <span class="hljs-keyword">const</span> initialCount = +<span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&#x27;storageCount&#x27;</span>)||<span class="hljs-number">0</span>;    <span class="hljs-keyword">const</span> [count,setCount]=useState(initialCount);    <span class="hljs-keyword">const</span> handleIncrement = <span class="hljs-function">() =&gt;</span>        setCount(<span class="hljs-function"><span class="hljs-params">currentCount</span> =&gt;</span> currentCount + <span class="hljs-number">1</span>);     <span class="hljs-keyword">const</span> handleDecrement = <span class="hljs-function">() =&gt;</span>        setCount(<span class="hljs-function"><span class="hljs-params">currentCount</span> =&gt;</span> currentCount - <span class="hljs-number">1</span>);    <span class="hljs-comment">//每次组件重新渲染时，count都会被存入浏览器的本地存储</span>    useEffect(<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&#x27;storageCount&#x27;</span>,count));    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;            &lt;button onClick=&#123;handleIncrement&#125;&gt;+<span class="hljs-number">1</span>&lt;/button&gt;            &lt;button onClick=&#123;handleDecrement&#125;&gt;-<span class="hljs-number">1</span>&lt;/button&gt;        &lt;/div&gt;    )&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>你还可以通过给Effect Hook 传递第二个参数（是个数组）的方式，来控制它什么时候运行。每当第二个参数中的变量发生变化时，Effect Hook就会run。下面这个例子，只有当count发生变化的时候，才将其存入localStorage:<br><img src="https://pic.downk.cc/item/5fd1cdb33ffa7d37b32ef914.jpg"></p><p>现在我们可以总结，Effect Hook函数中第二个参数值的用法：（通过第二个参数值来控制它何时run)</p><ul><li>every time(no argument，不传第二个参数)</li><li>only on mount or unmount ([]argument, 空数组)</li><li>only when a certain variable changes(例如[count]，数组中放入指定变量)</li></ul><p>🐖：forceUpdate API可以强制让组件重新渲染，但是我们应该谨慎使用 ，参考<a href="https://zh-hans.reactjs.org/docs/react-component.html#forceupdate">forceUpdate</a>以及 <a href="https://reactjs.org/docs/hooks-faq.html#is-there-something-like-forceupdate">Is there something like forceUpdate</a></p><h4 id="十一、纯函数组件——Pure-React-Funtion-Component"><a href="#十一、纯函数组件——Pure-React-Funtion-Component" class="headerlink" title="十一、纯函数组件——Pure React Funtion Component"></a>十一、纯函数组件——Pure React Funtion Component</h4><p>类组件中，可以通过使用PureComponent 或者 shouldComponentUpdate 来避免重新渲染导致的性能瓶颈【<a href="https://www.robinwieruch.de/react-prevent-rerender-component">avoid performance bottlenecks in React by preventing rereders</a>】。让我们先看一个例子：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App =<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">const</span> [greeting,setGreeting]=useState(<span class="hljs-string">&#x27;hello react&#x27;</span>);    <span class="hljs-keyword">const</span>[count,setCount]=useState(<span class="hljs-number">0</span>);    <span class="hljs-keyword">const</span> handleIncrement = <span class="hljs-function">()=&gt;</span>        setCount(<span class="hljs-function"><span class="hljs-params">currentCount</span>=&gt;</span>currentCount+<span class="hljs-number">1</span>);    <span class="hljs-keyword">const</span> handleDecrement = <span class="hljs-function">()=&gt;</span>        setCount(<span class="hljs-function"><span class="hljs-params">currentCount</span>=&gt;</span>currentCount-<span class="hljs-number">1</span>);        <span class="hljs-keyword">const</span> handleChange = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> setGreeting(event.target.value);    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;input onChange=&#123;handleChange&#125; /&gt;            &lt;Count count=&#123;count&#125; /&gt;            &lt;button onClick=&#123;handleIncrement&#125;&gt;Increment&lt;/button&gt;            &lt;button onClick=&#123;handleDecrement&#125;&gt;Decrement&lt;/button&gt;        &lt;/div&gt;    )&#125;;<span class="hljs-keyword">const</span> Count=<span class="hljs-function">(<span class="hljs-params">&#123;count&#125;</span>)=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Does it (re)render?&#x27;</span>);    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>在这个例子中，每当我们向input输入框输入内容时，这个App组件就会更新它的stater然后重新渲染。与此同时，Count组件也会重新渲染（在控制台中我们可以看到，每次我们在输入框里操作，就会打印“Does it (re)render?”这句）。为了避免这种情况，react函数组件使用React Memo【<a href="https://reactjs.org/docs/react-api.html">React’s top level APIs</a>】来阻止当props没有变化时的重新渲染。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React,&#123;useState, memo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> APP=<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">const</span> [greeting,setGreeting] = useState(<span class="hljs-string">&#x27;hello react&#x27;</span>);    <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);    <span class="hljs-keyword">const</span> handleIncrement = <span class="hljs-function">() =&gt;</span>        setCount(<span class="hljs-function"><span class="hljs-params">currentCount</span> =&gt;</span> currentCount + <span class="hljs-number">1</span>);     <span class="hljs-keyword">const</span> handleDecrement = <span class="hljs-function">() =&gt;</span>        setCount(<span class="hljs-function"><span class="hljs-params">currentCount</span> =&gt;</span> currentCount - <span class="hljs-number">1</span>);   <span class="hljs-keyword">const</span> handleChange = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> setGreeting(event.target.value);   <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;input type=<span class="hljs-string">&quot;text&quot;</span> onChange=&#123;handleChange&#125; /&gt;       &lt;Count count=&#123;count&#125; /&gt;       &lt;button type=<span class="hljs-string">&quot;button&quot;</span> onClick=&#123;handleIncrement&#125;&gt;        Increment      &lt;/button&gt;      &lt;button type=<span class="hljs-string">&quot;button&quot;</span> onClick=&#123;handleDecrement&#125;&gt;        Decrement      &lt;/button&gt;    &lt;/div&gt;  );&#125;<span class="hljs-comment">//memo时把整个箭头函数的内容包裹起来</span><span class="hljs-keyword">const</span> Count = memo(<span class="hljs-function">(<span class="hljs-params">&#123;count&#125;</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;does it (re)render?&#x27;</span>);    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&#125;);<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>现在我们再来运行这个程序，当我们向input输入框输入内容时，只有App组件会rerender, Count组件不再rerender了！当然，这种性能优化不应该作为默认设置。当重新渲染组件时间过长遇到问题时可以进行类似的检查。（比如，rendering和updating Table组件中的大量内容）</p><h4 id="十二、React-Function-Component-Ref"><a href="#十二、React-Function-Component-Ref" class="headerlink" title="十二、React Function Component: Ref"></a>十二、React Function Component: Ref</h4><p>refs一般只在少数场景下使用：</p><ul><li>管理焦点，文本选择或者时媒体播放</li><li>触发强制动画</li><li>集成第三方DOM库</li></ul><p>在函数式组件中使用refs，要引入useRef。下面这个例子，input输入框将获得焦点（after component did mount)</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React,&#123;useState, useEffect, useRef&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App=<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">const</span> [greeting, setGreeting] = useState(<span class="hljs-string">&#x27;hello React！&#x27;</span>);    <span class="hljs-keyword">const</span> handleChange = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span>setGreeting(event.target.value);    <span class="hljs-keyword">return</span>(        &lt;div&gt;            &lt;h1&gt;&#123;greeting&#125;&lt;/h1&gt;            &lt;Input value=&#123;greeting&#125; handleChange=&#123;handleChange&#125; /&gt;        &lt;/div&gt;    )&#125;;<span class="hljs-keyword">const</span> Input=<span class="hljs-function">(<span class="hljs-params">&#123;value,handleChange&#125;</span>)=&gt;</span>&#123;    <span class="hljs-keyword">const</span> ref=useRef();    useEffect(<span class="hljs-function">()=&gt;</span>ref.current.focus(),[]);    <span class="hljs-keyword">return</span> (        &lt;input             type=<span class="hljs-string">&#x27;text&#x27;</span>             value=&#123;value&#125;             onChange=&#123;handleChange&#125;             ref=&#123;ref&#125;        /&gt;    )&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>但是不能给一个函数组件提供一个ref作为props的一部分！The ref will be assigned to the component but not to the actual DOM node!<br><img src="https://pic.downk.cc/item/5fd1e2873ffa7d37b34ab442.jpg"></p><p>这样写会报错！因为ref指代的不是一个真实的dom节点，而是一个组件实例。</p><p><img src="https://pic.downk.cc/item/5fd1e2e03ffa7d37b34b4e87.jpg"></p><p>从上面的例子也可以看出，我们并不推荐父组件向子组件传递一个ref，这也就是为什么我们说”React function component can’t have  refs”。然而，如果我们不得不向一个函数组件传递一个ref(例如，我们想测量一个函数组件DOM节点的数量)，这种情况下我们可以<a href="https://reactjs.org/docs/forwarding-refs.html">forward the ref</a></p><p><img src="https://pic.downk.cc/item/5fd1e4643ffa7d37b3519759.jpg" alt="forwardRef"></p><p>想知道更多关于ref的问题，可以参考<a href="https://www.robinwieruch.de/react-ref-attribute-dom-node">How to use Ref in React</a> 以及 <a href="https://reactjs.org/docs/refs-and-the-dom.html">React 官方文档——Refs and the DOM</a></p><p>全文参考：<a href="https://www.robinwieruch.de/react-function-component">React Function Components</a></p>]]></content>
    
    
    <categories>
      
      <category>React学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS01-理解JavaScript函数调用和this</title>
    <link href="/2020/12/08/JS01-%E7%90%86%E8%A7%A3JavaScript%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8Cthis/"/>
    <url>/2020/12/08/JS01-%E7%90%86%E8%A7%A3JavaScript%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8Cthis/</url>
    
    <content type="html"><![CDATA[<h4 id="理解JavaScript函数调用与this的语义"><a href="#理解JavaScript函数调用与this的语义" class="headerlink" title="理解JavaScript函数调用与this的语义"></a>理解JavaScript函数调用与this的语义</h4><p>&emsp;我们经常对JS的函数调用，以及this在函数调用中的指代有很多的困惑。通过理解核心函数调用的原语可能会有助于消除很多此类的疑惑，也可以把其他函数调用方式看成是最原始函数调用的语法糖。The basic idea is the same.</p><h5 id="一、-The-Core-Primitive-核心原语："><a href="#一、-The-Core-Primitive-核心原语：" class="headerlink" title="一、 The Core Primitive 核心原语："></a>一、 The Core Primitive 核心原语：</h5><p>First, let’s look at the core function invocation primitive, a Function’s call method[1]. The call method is relatively straight forward.</p><ol><li>Make an argument list (<strong>argList</strong>) out of parameters 1 through the end</li><li>The first parameter is <strong>thisValue</strong></li><li>Invoke the function with <strong>this</strong> set to <strong>thisValue</strong> and the <strong>argList</strong> as its argument list<br>例子：<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params">thing</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;say hello&#x27;</span> + thing);&#125;hello.call(<span class="hljs-string">&#x27;Yehuda&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>);<span class="hljs-comment">//Yehuda says hello world</span></code></pre></li></ol><p>As you can see, we invoked the <strong>hello</strong> method with this set to “Yehuda” and a single argument “world”. This is the core primitive of JavaScript function invocation. You can think of all other function calls as desugaring to this primitive. (to “desugar” is to take a convenient syntax and describe it in terms of a more basic core primitive).</p><h5 id="二、简单函数调用"><a href="#二、简单函数调用" class="headerlink" title="二、简单函数调用"></a>二、简单函数调用</h5><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params">thing</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello&#x27;</span> + thing);&#125;<span class="hljs-comment">//简单函数调用</span>hello(<span class="hljs-string">&#x27;world&#x27;</span>);<span class="hljs-comment">//desugars to:</span>hello.call(<span class="hljs-built_in">window</span>, <span class="hljs-string">&#x27;world&#x27;</span>)<span class="hljs-comment">//在ES5的严格模式中，desugars to:</span>hello.call(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;world&#x27;</span>)</code></pre><p>在内联声明的函数中，也有相同的“解糖”：<br>(function() {})()  = (function() {}).call(window或undefined)</p><h5 id="三、成员函数"><a href="#三、成员函数" class="headerlink" title="三、成员函数"></a>三、成员函数</h5><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = &#123;    name: <span class="hljs-string">&#x27;Eich&#x27;</span>,    hello: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thing</span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;say hello&#x27;</span> + thing)    &#125;&#125;<span class="hljs-comment">//成员函数调用</span>person.hello(<span class="hljs-string">&#x27;world&#x27;</span>);<span class="hljs-comment">//desugars to:</span>person.hello.call(person,<span class="hljs-string">&#x27;world&#x27;</span>)</code></pre><p>如果为一个对象动态的添加成员函数，也有相同的“解糖”：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params">thing</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;say hello&#x27;</span> + thing);&#125;person = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Eich&#x27;</span>&#125;;person.hello = hello;person.hello(<span class="hljs-string">&#x27;world&#x27;</span>);<span class="hljs-comment">//still desugars to :</span><span class="hljs-comment">//person.hello.call(person,&#x27;world&#x27;)</span>hello(<span class="hljs-string">&#x27;world&#x27;</span>);<span class="hljs-comment">//&quot;[object DOMwindow] say hello world&quot;</span></code></pre><p>🐖：Notice that the function doesn’t have a persistent notion of its ‘this’. It is always set at call time based upon the way it was invoked by its caller.</p><h5 id="四、使用函数原型绑定-Function-prototype-bind"><a href="#四、使用函数原型绑定-Function-prototype-bind" class="headerlink" title="四、使用函数原型绑定 Function.prototype.bind"></a>四、使用函数原型绑定 Function.prototype.bind</h5><p>&emsp;因为有时使用持久化this值引用函数可能会很方便，所以人们一直以来都使用简单的闭包技巧将函数转换成不变的this值。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = &#123;    name: <span class="hljs-string">&#x27;Eich&#x27;</span>,    hello: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">this</span></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;says hello&#x27;</span> +thing);    &#125;&#125;<span class="hljs-keyword">var</span> boundHello = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thing</span>)</span>&#123;    <span class="hljs-comment">//使用原始的call方法把this转换为我们想要它指代的值</span>    <span class="hljs-keyword">return</span> person.hello.call(person,thing)&#125;boundHello(<span class="hljs-string">&#x27;world&#x27;</span>);<span class="hljs-comment">//desugars to: boundHello.call(window, &#x27;world&#x27;)</span></code></pre><p>我们还可以进一步改进，让上面的写法更加通用：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> bind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">func,thisValue</span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> func.apply(thisValue, <span class="hljs-built_in">arguments</span>);    &#125;&#125;<span class="hljs-keyword">var</span> boundHello = bind(person.hello, person);boundHello(<span class="hljs-string">&#x27;world&#x27;</span>)<span class="hljs-comment">//&#x27;Eich says hello world&#x27;</span></code></pre><p>上述代码中，arguments是类数组对象，代表所有被传入函数的参数值。apply() 方法跟call类似，除了它接收的是类数组对象作为参数，而call接收的是一个一个参数组成的列表 call(thisArg, arg1,arg2,…)。<br>对上述代码的解释：Our <strong>bind</strong> method simply returns a new function. When it is invoked, our new function simply invokes the original function that was passed in, setting the original value as <strong>this</strong>. It also passes through the arguments.</p><p>参考文章： <a href="https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/">Understanding JavaScript Function Invocation and “this”</a></p>]]></content>
    
    
    <categories>
      
      <category>JS学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试03-如何避免生命周期中的坑？</title>
    <link href="/2020/12/07/%E9%9D%A2%E8%AF%9503-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E7%9A%84%E5%9D%91%EF%BC%9F/"/>
    <url>/2020/12/07/%E9%9D%A2%E8%AF%9503-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E7%9A%84%E5%9D%91%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="面试场景3：如何避免生命周期中的坑？（经验题）"><a href="#面试场景3：如何避免生命周期中的坑？（经验题）" class="headerlink" title="面试场景3：如何避免生命周期中的坑？（经验题）"></a>面试场景3：如何避免生命周期中的坑？（经验题）</h4><p>如何避免坑？换种思维也就是”为什么会有坑?”,在代码编写中，遇到的坑通常有两种：</p><ul><li>1.在不恰当的时机调用了不合适的代码</li><li>2.在需要调用时，却忘了调用</li></ul><p>那么针对生命周期的坑，可以通过梳理生命周期，明确周期函数职责，确认什么时候该做什么事，依次来避免坑。因此现在主要思考两个问题：</p><ul><li>1.基于周期类型的梳理，确认生命周期函数的<strong>使用方式</strong></li><li>2.基于职责的梳理，确认生命周期函数的<strong>适用范围</strong></li></ul><p><img src="https://pic.downk.cc/item/5fcdeaf03ffa7d37b3c10890.jpg" alt="生命周期的梳理"></p><h5 id="一、生命周期的概念"><a href="#一、生命周期的概念" class="headerlink" title="一、生命周期的概念"></a>一、生命周期的概念</h5><p>当我们在讨论React组件生命周期的时候，一定是在讨论类组件（Class Component)。函数式组件并没有生命周期的概念，它本身就是一个函数，只会从头执行到尾。</p><p>生命周期其实是一个抽象的概念，提到生命周期我们第一时间想到的是componentDidMount, componenetWillMount等函数。然而这些函数并不等同于组件的生命周期，只是在生命周期中按顺序被调用的函数。<strong>挂载 -&gt; 更新 -&gt;卸载</strong>，这一完整的流程，才是React组件的生命周期。</p><h5 id="二、生命周期流程梳理"><a href="#二、生命周期流程梳理" class="headerlink" title="二、生命周期流程梳理"></a>二、生命周期流程梳理</h5><p><strong>1.挂载阶段</strong><br>&emsp;挂载阶段是指组件从初始化到完成加载的过程。</p><ul><li>✨<strong>constructor函数</strong>：constructor是类通用的构造函数，常用于初始化（通常是初始化state,以及绑定函数）<pre><code class="hljs js"><span class="hljs-comment">//过去的写法</span><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;        <span class="hljs-built_in">super</span>(props);        <span class="hljs-built_in">this</span>.state=&#123;            count:<span class="hljs-number">0</span>        &#125;        <span class="hljs-built_in">this</span>.handleClick=<span class="hljs-built_in">this</span>.handleClick.bind(<span class="hljs-built_in">this</span>);    &#125;    <span class="hljs-function"><span class="hljs-title">handleClick</span>(<span class="hljs-params"></span>)</span>&#123;        ...    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;&#125;<span class="hljs-string">``</span><span class="hljs-string">` </span><span class="hljs-string">当类属性开始流行后，现在React社区的写法发生了变化，去除了constructor。</span><span class="hljs-string"></span><span class="hljs-string">`</span><span class="hljs-string">``</span>js<span class="hljs-comment">//现在的写法</span><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    state=&#123;        count:<span class="hljs-number">0</span>,    &#125;    <span class="hljs-comment">//类属性第三阶段提案，这种不再需要额外绑定</span>    handleClick=<span class="hljs-function">()=&gt;</span>&#123;        ...    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;&#125;</code></pre>React社区去除constructor的原因：</li></ul><ol><li>constructor本身并不属于React的生命周期，它只是Class组件的初始化函数</li><li>constructor中并不推荐去处理初始化以外的逻辑</li><li>通过去除constructor，代码变得更加简洁</li></ol><ul><li>✨<strong>getDerivedStateFromProps函数</strong>： 使组件在props变化时更新state</li></ul><p>它的触发时机是：</p><ol><li>当props被传入时</li><li>state发送变化时</li><li>forceUpdate被调用时</li></ol><p>🐖：一个常见错误是认为只有props发送变化时，getDerivedStateFromProps才会被调用，实际上只要父组件重新渲染时，getDerivedStateFromProps就会被调用，外部参数props传入时就会发生变化。以下是官方文档给出的例子：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-comment">// 在构造函数中初始化 state，</span>  <span class="hljs-comment">// 或者使用属性初始化器。</span>  state = &#123;    isScrollingDown: <span class="hljs-literal">false</span>,    lastRow: <span class="hljs-literal">null</span>,  &#125;;  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getDerivedStateFromProps</span>(<span class="hljs-params">props, state</span>)</span> &#123;    <span class="hljs-keyword">if</span> (props.currentRow !== state.lastRow) &#123;      <span class="hljs-keyword">return</span> &#123;        isScrollingDown: props.currentRow &gt; state.lastRow,        lastRow: props.currentRow,      &#125;;    &#125;    <span class="hljs-comment">// 返回 null 表示无需更新 state。</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  &#125;&#125;</code></pre><p>按照官方的说话，它的使用场景是非常有限的。由于太多使用错误的案例，React团队还因此写了<a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html">你可能不需要使用派生state</a>，文中列举了错误使用getDerivedStateFromProps的两个典型反面案例：</p><ol><li>直接复制prop到state</li><li>在props变化后修改state</li></ol><p>这两种写法除了增加代码的维护成本外，没有带来任何好处。</p><ul><li>✨<strong>UNSAFE_componentWillMount函数</strong>： 也就是componentWillMount，用于组件加载前做某些操作。在React的异步渲染机制下，该方法可能会被多次调用，所以目前被标记为弃用。</li></ul><p>一个常见的错误是componentWillMount跟服务器端同构渲染时，如果在该函数里面发起网络请求，拉取数据，那么会在服务器端和客户端分别执行一次。所以更推荐使用componentDidMount中完成拉取数据的操作。</p><ul><li><p>✨<strong>render函数</strong>： render函数返回的JSX结构，用于描述具体的渲染内容。但是，render函数并没有真正的去渲染组件，渲染是依靠React操作JSX结构完成的。<br>🐖：render函数应该是一个纯函数，不能在里面产生副作用，比如调用setState或者绑定事件。① 不能setState是因为render函数在每次渲染时都会被调用，而setState会触发渲染，就会造成死循环。② 不能绑定事件是因为容易被频繁调用注册。</p></li><li><p>✨<strong>componentDidMount函数</strong>： 主要用于组件加载完成后进行某些操作，比如发起网络请求或者绑定事件，该函数是接着render之后调用的。但是componentDidMount一定是在真实DOM绘制完成之后调用吗？在浏览器端可以这么认为。但是在其他场景下，尤其是React Native场景下，componentDidMount并不意味着真实的界面已经绘制完毕。（由于机器的性能限制，视图可能还在绘制中）</p></li></ul><p><strong>2.更新阶段</strong><br>&emsp;更新阶段是指外部props传入，或者state发生变化时的阶段。这个阶段主要有以下6个函数：</p><ul><li>💖<strong>UNSAFE_componentWillReceiveProps函数</strong>： 该函数已经被标记弃用，因为其功能可被getDerivedStateFromProps所替代。当getDerivedStateFromProps存在时，UNSAFE_componentWillReceiveProps不会被调用。</li><li>💖<strong>getDerivedStateFromProps函数</strong>: 同挂载阶段的变现一致。</li><li>💖<strong>shouldComponentUpdate函数</strong>: 该方法通过返回true或者false来确定是否需要触发新的渲染，因为渲染触发最后一道关卡，所以也是性能优化的必争之地。通过添加判断条件来阻止不必要的渲染。</li></ul><p>React官方提供了一个通用的优化方案，也就是PureComponent。PureComponent的核心原理是默认实现了shouldComponentUpdate函数，在这个函数中对props和state进行浅比较，用来判断是否触发更新。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">shouldComponentUpdate</span>(<span class="hljs-params">nextProps, nextState</span>)</span> &#123;  <span class="hljs-comment">// 浅比较仅比较值与引用，并不会对 Object 中的每一项值进行比较</span>  <span class="hljs-keyword">if</span> (shadowEqual(nextProps, <span class="hljs-built_in">this</span>.props) || shadowEqual(nextState, <span class="hljs-built_in">this</span>.state) ) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre><ul><li><p>💖<strong>UNSAFE_componentWillUpdate函数</strong>: 同样已废弃，因为在后续的React异步渲染设计中，可能会出现组件暂停更新渲染的情况。</p></li><li><p>💖<strong>render函数</strong>: 跟挂载阶段的表现一致</p></li><li><p>💖<strong>getSnapshotBeforeUpdate函数</strong>: getSnapshotBeforeUpdate是配合React新的异步渲染机制，在DOM更新发生之前被调用，返回值作为对componentDidUpdate的第三个参数。官方示例如下：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScrollingList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props);    <span class="hljs-built_in">this</span>.listRef = React.createRef();  &#125;  <span class="hljs-function"><span class="hljs-title">getSnapshotBeforeUpdate</span>(<span class="hljs-params">prevProps, prevState</span>)</span> &#123;    <span class="hljs-comment">// Are we adding new items to the list?</span>    <span class="hljs-comment">// Capture the scroll position so we can adjust scroll later.</span>    <span class="hljs-keyword">if</span> (prevProps.list.length &lt; <span class="hljs-built_in">this</span>.props.list.length) &#123;      <span class="hljs-keyword">const</span> list = <span class="hljs-built_in">this</span>.listRef.current;      <span class="hljs-keyword">return</span> list.scrollHeight - list.scrollTop;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  &#125;  <span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState, snapshot</span>)</span> &#123;    <span class="hljs-comment">// If we have a snapshot value, we&#x27;ve just added new items.</span>    <span class="hljs-comment">// Adjust scroll so these new items don&#x27;t push the old ones out of view.</span>    <span class="hljs-comment">// (snapshot here is the value returned from getSnapshotBeforeUpdate)</span>    <span class="hljs-keyword">if</span> (snapshot !== <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">const</span> list = <span class="hljs-built_in">this</span>.listRef.current;      list.scrollTop = list.scrollHeight - snapshot;    &#125;  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> (      &lt;div ref=&#123;<span class="hljs-built_in">this</span>.listRef&#125;&gt;&#123;<span class="hljs-comment">/* ...contents... */</span>&#125;&lt;/div&gt;    );  &#125;</code></pre></li><li><p>💖<strong>componentDidUpdate函数</strong>: 正如上面的案例，getSnapshotBeforeUpdate的返回值会作为componentDidUpdate的第三个参数使用。componentDidUpdate函数中可以使用setState来触发重新渲染，但是一定要小心，避免死循环！</p></li></ul><p><strong>3.挂载阶段</strong><br>&emsp;挂载阶段，只有一个回调函数。</p><ul><li>✌<strong>componentWillUnmount函数</strong>：该函数主要用于清理工作，一个比较常见的bug是忘记在componentWillUnmount中取消定时器，导致定时操作依然在组件销毁后不停地执行。所以在该阶段一定要完成事件解绑，取消定时器。</li></ul><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p> 根据上面的内容，可以做一个思维导图：<br> <img src="https://pic.downk.cc/item/5fce2a393ffa7d37b3f47cbd.jpg" alt="React生命周期思维导图"></p><h5 id="二、生命周期职责梳理"><a href="#二、生命周期职责梳理" class="headerlink" title="二、生命周期职责梳理"></a>二、生命周期职责梳理</h5><p> 职责梳理主要是搞清楚两个事情：<br> 1、什么情况下会触发重新渲染？<br> 2、渲染中发生报错后会怎样？</p><p> <strong>1.触发重新渲染的三种情况</strong>：</p><ul><li><p>😊<strong>函数组件</strong>： 函数组件在任何情况下都有可能重新渲染。它没有生命周期，但是官方提供了一个优化手段，那就是React.memo:</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> MyComponent = React.memo(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params">props</span>)</span>&#123;    <span class="hljs-comment">/*使用props渲染*/</span>&#125;)</code></pre><p>React.memo并不阻断渲染，而是跳过渲染组件的操作并直接复用最新一次渲染的结果，这与shouldComponentUpdate是完全不同的。</p></li><li><p>😊<strong>React.Component</strong>：如果不实现shouldComponentUpdate函数，那么有两种情况触发渲染：<br>1、当state发生变化时。（最常见的情况）<br>2、当父组件的Props传入时。（无论Props有没有发生变化，只有传入就会引发重新渲染）</p></li><li><p>😊<strong>React.PureComponent</strong>: PureComponent默认实现了shouldComponentUpdate函数，所以仅在props与state进行浅比较后，确认有变更时才会触发重新渲染。</p></li><li><p>*2.错误边界**： </p></li></ul><p>&emsp;错误边界是一种React组件，这种组件可以捕获并打印发生在其子组件树上任何位置的JavaScript错误，并且，它会渲染出备用UI，如下官方示例：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props);    <span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> &#125;;  &#125;  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getDerivedStateFromError</span>(<span class="hljs-params">error</span>)</span> &#123;    <span class="hljs-comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> &#125;;  &#125;  <span class="hljs-function"><span class="hljs-title">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>)</span> &#123;    <span class="hljs-comment">// 你同样可以将错误日志上报给服务器</span>    logErrorToMyService(error, errorInfo);  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state.hasError) &#123;      <span class="hljs-comment">// 你可以自定义降级后的 UI 并渲染</span>      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Something went wrong.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.props.children;   &#125;&#125;</code></pre><p>无论是React,还是React Native,如果没有错误边界，在用户侧看到的现象是：在执行某个错误操作时，触发了bug, 引发了崩溃，页面会突然白屏。</p><p>🐖：在渲染时的报错，只能通过componentDidCatch捕获。这是在做线上页面报错监控时，及其容易忽略的点。</p><h5 id="三、答题："><a href="#三、答题：" class="headerlink" title="三、答题："></a>三、答题：</h5><p>经过上面的梳理,现在可以回答开头的问题了。</p><blockquote><p>避免生命周期中的坑需要做好两件事：</p><p>1.不在恰当的时候调用了不该调用的代码；<br>2.在需要调用时，不要忘了调用。</p></blockquote><p>那么，有7种情况容易造成React生命周期的坑：</p><blockquote><p>1.getDerivedStateFromProps 容易编写反模式代码，使受控组件与非受控组件区分模糊。</p></blockquote><blockquote><p>2.componentWillMount 在 React 中已被标记弃用，不推荐使用，主要原因是新的异步渲染架构会导致它被多次调用。所以网络请求及事件绑定代码应移至 componentDidMount中。</p></blockquote><blockquote><p>3.componentWillReceiveProps 同样被标记弃用，被 getDerivedStateFromProps 所取代，主要原因是性能问题。</p></blockquote><blockquote><p>4.shouldComponentUpdate 通过返回 true 或者 false 来确定是否需要触发新的渲染。主要用于性能优化。</p></blockquote><blockquote><p>5.componentWillUpdate 同样是由于新的异步渲染机制，而被标记废弃，不推荐使用，原先的逻辑可结合 getSnapshotBeforeUpdate 与 componentDidUpdate 改造使用。</p></blockquote><blockquote><p>6.如果在 componentWillUnmount 函数中忘记解除事件绑定，取消定时器等清理操作，容易引发 bug。</p></blockquote><blockquote><p>7.如果没有添加错误边界处理，当渲染发生异常时，用户将会看到一个无法操作的白屏，所以一定要添加。</p></blockquote><h5 id="四、进阶提问：React-的请求应该放在哪里，为什么"><a href="#四、进阶提问：React-的请求应该放在哪里，为什么" class="headerlink" title="四、进阶提问：React 的请求应该放在哪里，为什么?"></a>四、进阶提问：React 的请求应该放在哪里，为什么?</h5><p> 对于异步请求，应该放在componentDidUpdate中操作。从时间顺序上看，似乎还有两个选择，但是它们都有各自的弊端：</p><ul><li><p>constructor：可以放，但是从设计上看不推荐，constructor主要用于初始化state和函数绑定，并不应该承载业务逻辑。而且随着类属性的流行，constructor已经很少使用了。</p></li><li><p>componentWillMout: 已经被标废弃，在新的异步渲染机制下回触发多次渲染，容易引发bug,不利于React升级后的代码维护。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>npm01--dependencies与devDependencies的区别</title>
    <link href="/2020/12/06/npm01-dependencies%E4%B8%8EdevDependencies%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/12/06/npm01-dependencies%E4%B8%8EdevDependencies%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="dependencies-与-devDependencies"><a href="#dependencies-与-devDependencies" class="headerlink" title="dependencies 与 devDependencies"></a>dependencies 与 devDependencies</h4><p>&emsp;当我们在使用npm install 安装node模块时，有两种命令参数将这些node模块的信息写入到package.json文件中：</p><ul><li>npm install *** –save，这个命令是将依赖包的信息添加到package.json文件的dependencies键下。</li><li>npm install *** –save-dev，这个命令是将依赖包的信息添加到devDependencies键下。</li></ul><h4 id="1-不同点："><a href="#1-不同点：" class="headerlink" title="1.不同点："></a>1.不同点：</h4><p><strong>devDependencies是开发环境</strong>，我们使用的一些构建工具如webpack、glup等只是在开发过程中用的包，上线后就和它们没有关系了，所以这种都写入devDependencies（还有一些单元测试工具也卸载这里）</p><p><strong>dependencies是生产环境</strong>，比如我们写一个项目需要依赖React/Vue/jQuery才能执行，没有这个包的依赖运行就会出错，这时候就必须把依赖写入dependencies里。</p><h4 id="2-相同点："><a href="#2-相同点：" class="headerlink" title="2.相同点："></a>2.相同点：</h4><p>dependencies和 devDependencies相同的地方在于：就是当我们clone别人的库进行开发测试的时候，可以通过npm install 一键安装这两个目录下的所有依赖，而不需要一行行地查找别人到底在文件中引用了哪些依赖。</p><p>参考：<a href="https://docs.npmjs.com/cli/v6/configuring-npm/package-json#dependencies">npm官方文档–dependencies</a></p>]]></content>
    
    
    <categories>
      
      <category>npm学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试02-为什么React要用JSX？</title>
    <link href="/2020/12/02/%E9%9D%A2%E8%AF%9502-%E4%B8%BA%E4%BB%80%E4%B9%88React%E8%A6%81%E7%94%A8JSX%EF%BC%9F/"/>
    <url>/2020/12/02/%E9%9D%A2%E8%AF%9502-%E4%B8%BA%E4%BB%80%E4%B9%88React%E8%A6%81%E7%94%A8JSX%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="面试场景2：为什么React要用JSX？（论证题）"><a href="#面试场景2：为什么React要用JSX？（论证题）" class="headerlink" title="面试场景2：为什么React要用JSX？（论证题）"></a>面试场景2：为什么React要用JSX？（论证题）</h4><p>&emsp;针对”为什么采用改技术方案？”类型的题，其实主要在考察两个方面：</p><ul><li>技术广度，深挖知识面涉猎广度，对流行框架的模板方案是否知悉了解。</li><li>技术方案调研能力</li></ul><p>所以，针对这类问题，可以采用 “一句话解释，核心概念，方案对比” 三步走的技巧来作答：</p><p>1、一句话解析JSX。用一句话说清楚JSX到底是什么。<br>2、核心概念。JSX用于解决什么问题？如何使用？<br>3、方案对比。与其他方案进行对比，说明React选用JSX的必要性。</p><h5 id="一、一句话解释"><a href="#一、一句话解释" class="headerlink" title="一、一句话解释"></a>一、一句话解释</h5><p>&emsp;按照React官方解释，<strong>JSX是一个JavaScript的语法扩展，或者说是一个类似于XML的ECMAScript语法扩展</strong>，它本身没有太多的语法定义，也不期望引入更多的标准。</p><h5 id="二、核心概念"><a href="#二、核心概念" class="headerlink" title="二、核心概念"></a>二、核心概念</h5><p>&emsp;其实React本身并不强制使用JSX，在没有JSX的时候，React实现一个组件依赖于使用React.createElement函数。代码如下：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> React.createElment(            <span class="hljs-string">&#x27;div&#x27;</span>,            <span class="hljs-literal">null</span>,            <span class="hljs-string">`Hello <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.props.toWhat&#125;</span>`</span>        );    &#125;&#125;ReactDOM.render(    React.createElement(<span class="hljs-string">&#x27;Hello,&#123;toWhat:&#x27;</span>World<span class="hljs-string">&#x27;&#125;),</span><span class="hljs-string">    document.getElementById(&#x27;</span>root<span class="hljs-string">&#x27;)</span><span class="hljs-string">)</span></code></pre><p>而JSX更像是语法糖，通过类似XML的描述方式，描写函数对象。采用JSX之后，上述代码会变成如下：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello,&#123;this.props.toWhat&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    &#125;&#125;ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Hello</span> <span class="hljs-attr">toWhat</span>=<span class="hljs-string">&#x27;world&#x27;</span>/&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>))</code></pre><p>通过这样对比，显然可以看出，<strong>JSX使得代码变得更为简洁，而且代码结构层次更为清晰。</strong></p><p>因为React需要将组件转化为虚拟DOM树，所以我们手写代码时，其实是在手写一颗结构树。而XML在树结构的描述上天然具有可读性强优势。<br>🐖：实际在运行的时候，会使用Babel插件将JSX语法的代码还原为React.createElement的代码。</p><h5 id="三、方案对比"><a href="#三、方案对比" class="headerlink" title="三、方案对比"></a>三、方案对比</h5><p><strong>1.React设计初衷</strong></p><p>React的设计初衷是：关注点分离（Separation of concerns)。在React种，关注点的基本单位是组件。React单个组件时高内聚的，而组件与组件之间时低耦合的。</p><blockquote><p>关注点分离：是计算机科学里面的一个重要概念。主要思想是将代码分隔为不同部分，每一部分都有各自的关注点。优点： 当关注点分开时，各部分可以重复使用，独立开发和更新。具有特殊价值的部分能够稍后改进或修改一段代码，而无须知道其他部分的细节做出的相应更改。</p></blockquote><p><strong>2.React为什么不使用模板呢？</strong></p><p>React团队认为引入模板是一种不佳的实现。因为模板分离了技术栈，而非关注点的模板同时又引入了很多的概念，比如新的模板语法、模板指令等。以AngularJS为例，可以看下有多少新概念：</p><pre><code class="hljs js">&lt;!doctype html&gt;&lt;html ng-app=<span class="hljs-string">&quot;docsBindExample&quot;</span>&gt;  &lt;head&gt;    &lt;script src=<span class="hljs-string">&quot;http://code.angularjs.org/1.2.25/angular.min.js&quot;</span>&gt;&lt;/script&gt;    &lt;script src=<span class="hljs-string">&quot;script.js&quot;</span>&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div ng-controller=<span class="hljs-string">&quot;Ctrl1&quot;</span>&gt;      Hello &lt;input ng-model=<span class="hljs-string">&#x27;name&#x27;</span>&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span></span>      &lt;span ng-bind=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;<span class="hljs-regexp">/span&gt; &lt;br/</span>&gt;      &lt;span ng:bind=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;<span class="hljs-regexp">/span&gt; &lt;br/</span>&gt;      &lt;span ng_bind=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;<span class="hljs-regexp">/span&gt; &lt;br/</span>&gt;      &lt;span data-ng-bind=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;<span class="hljs-regexp">/span&gt; &lt;br/</span>&gt;      &lt;span x-ng-bind=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;<span class="hljs-regexp">/span&gt; &lt;br/</span>&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;angular.module(<span class="hljs-string">&#x27;docsBindExample&#x27;</span>, [])  .controller(<span class="hljs-string">&#x27;Ctrl1&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Ctrl1</span>(<span class="hljs-params">$scope</span>) </span>&#123;    $scope.name = <span class="hljs-string">&#x27;Max Karl Ernst Ludwig Planck (April 23, 1858 – October 4, 1947)&#x27;</span>;  &#125;);</code></pre><p>看完会发现这段代码很难懂，因为它引入了非常多的AngularJS独有的概念，但是JSX却不会有很多新概念，它依然是JavaScript，就连条件表达式和循环都仍然是JavaScript的方式。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> App=<span class="hljs-function">(<span class="hljs-params">props</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span>(        &lt;div&gt;            &#123;props.isShow?<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>show<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>:<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>hidden<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>&#125;            &#123;props.names.map(<span class="hljs-function"><span class="hljs-params">name</span>=&gt;</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>)&#125;        &lt;/div&gt;    )&#125;</code></pre><p>这样比较下来，可以看出React代码更简洁，更具有可读性，更贴近HTML。</p><p>那模板字符串也可以套用HTML，为什么不用模板字符串呢？</p><p><strong>3.React为什么不使用模板字符串呢？</strong></p><p>来看一个模板字符串的例子：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> box = jsx<span class="hljs-string">`</span><span class="hljs-string"></span><span class="hljs-string">  &lt;<span class="hljs-subst">$&#123;Box&#125;</span>&gt;</span><span class="hljs-string"></span><span class="hljs-string">    <span class="hljs-subst">$&#123;</span></span><span class="hljs-string"><span class="hljs-subst"></span></span><span class="hljs-string"><span class="hljs-subst">      shouldShowAnswer(user) ?</span></span><span class="hljs-string"><span class="hljs-subst"></span></span><span class="hljs-string"><span class="hljs-subst">      jsx<span class="hljs-string">`&lt;<span class="hljs-subst">$&#123;Answer&#125;</span> value=<span class="hljs-subst">$&#123;<span class="hljs-literal">false</span>&#125;</span>&gt;no&lt;/<span class="hljs-subst">$&#123;Answer&#125;</span>&gt;`</span> :</span></span><span class="hljs-string"><span class="hljs-subst"></span></span><span class="hljs-string"><span class="hljs-subst">      jsx<span class="hljs-string">`</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">        &lt;<span class="hljs-subst">$&#123;Box.Comment&#125;</span>&gt;</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">         Text Content</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">        &lt;/<span class="hljs-subst">$&#123;Box.Comment&#125;</span>&gt;</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">      `</span></span></span><span class="hljs-string"><span class="hljs-subst"></span></span><span class="hljs-string"><span class="hljs-subst">    &#125;</span></span><span class="hljs-string"></span><span class="hljs-string">  &lt;/<span class="hljs-subst">$&#123;Box&#125;</span>&gt;</span><span class="hljs-string"></span><span class="hljs-string">`</span>;</code></pre><p>显然代码结构还是非常复杂（存在多次内部嵌套），也不利于开发工具的代码提示。</p><p><strong>4.React为什么不使用JXON呢？</strong></p><p>JXON很像目前使用的JSX，它的结构如下：</p><pre><code class="hljs js">&lt;catalog&gt;  &lt;product description=<span class="hljs-string">&quot;Cardigan Sweater&quot;</span>&gt;   &lt;catalog_item gender=<span class="hljs-string">&quot;Men&#x27;s&quot;</span>&gt;     &lt;item_number&gt;QWZ5671&lt;/item_number&gt;     &lt;price&gt;<span class="hljs-number">39.95</span>&lt;/price&gt;     &lt;size description=<span class="hljs-string">&quot;Medium&quot;</span>&gt;       &lt;color_swatch image=<span class="hljs-string">&quot;red_cardigan.jpg&quot;</span>&gt;Red&lt;/color_swatch&gt;       &lt;color_swatch image=<span class="hljs-string">&quot;burgundy_cardigan.jpg&quot;</span>&gt;Burgundy&lt;/color_swatch&gt;     &lt;/size&gt;     &lt;size description=<span class="hljs-string">&quot;Large&quot;</span>&gt;       &lt;color_swatch image=<span class="hljs-string">&quot;red_cardigan.jpg&quot;</span>&gt;Red&lt;/color_swatch&gt;       &lt;color_swatch image=<span class="hljs-string">&quot;burgundy_cardigan.jpg&quot;</span>&gt;Burgundy&lt;/color_swatch&gt;     &lt;/size&gt;   &lt;/catalog_item&gt;   &lt;catalog_item gender=<span class="hljs-string">&quot;Women&#x27;s&quot;</span>&gt;     &lt;item_number&gt;RRX9856&lt;/item_number&gt;     &lt;discount_until&gt;Dec <span class="hljs-number">25</span>, <span class="hljs-number">1995</span>&lt;/discount_until&gt;     &lt;price&gt;<span class="hljs-number">42.50</span>&lt;/price&gt;     &lt;size description=<span class="hljs-string">&quot;Medium&quot;</span>&gt;       &lt;color_swatch image=<span class="hljs-string">&quot;black_cardigan.jpg&quot;</span>&gt;Black&lt;/color_swatch&gt;     &lt;/size&gt;   &lt;/catalog_item&gt;  &lt;/product&gt;  &lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;&lt;![CDATA[<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchwo</span>(<span class="hljs-params">a,b</span>) </span>&#123;    <span class="hljs-keyword">if</span> (a &lt; b &amp;&amp; a &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;    <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;&#125;]]&gt;&lt;/script&gt;&lt;/catalog&gt;</code></pre><p>最后放弃JXON这一方案的原因是，大括号不能作为元素在树种开始和结束的位置，无法提供很好的语法提示。</p><p>最后总结下，React为什么使用JSX?</p><p><img src="https://pic.downk.cc/item/5fc752d5394ac523789ece3c.jpg" alt="react使用JSX原因"></p><p>==答题==： </p><blockquote><p>首先，JSX 是一个 JavaScript 的语法扩展，结构类似 XML。<br>（JSX 主要用于声明 React 元素，但 React 中并不强制使用 JSX。即使使用了 JSX，也会在构建过程中，通过 Babel 插件编译为 React.createElement。所以 JSX 更像是 React.createElement 的一种语法糖。<br>React团队并不想引入JavaScript本身以外的开发体系，而是希望通过合理的关注点分离保持组件开发的纯粹性。）</p></blockquote><blockquote><p>然后，是JSX与其他三种技术方案的对比：<br>1.模板。 React 团队认为模板不应该是开发过程中的关注点，因为引入了模板语法、模板指令等概念，是一种不佳的实现方案。<br>2.模板字符串。 模板字符串编写的结构会造成多次内部嵌套，使整个结构变得复杂，并且优化代码提示也会变得困难重重。<br>3.JXON。 同样因为代码提示困难的原因而被放弃</p></blockquote><p>✨所以，React选择了JSX，因为JSX与其设计思想最为吻合，不需要引入过多的新概念，对编辑器代码提示也很友好。</p>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>React03-React.cloneElement函数</title>
    <link href="/2020/12/01/React03-React-cloneElement%E5%87%BD%E6%95%B0/"/>
    <url>/2020/12/01/React03-React-cloneElement%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="React-cloneElement-element-props-…children"><a href="#React-cloneElement-element-props-…children" class="headerlink" title="React.cloneElement(element,[props],[…children])"></a>React.cloneElement(element,[props],[…children])</h4><p>&emsp;这个API以element元素为样板克隆并返回新的React元素。</p><ul><li>返回元素的props是将新的props与原始元素的props浅层合并后的结果。</li><li>新的子元素将取代现有的子元素，而来自原始元素的key和ref将被保留。</li></ul><p>React.cloneElement() 基本等同于：</p><pre><code class="hljs js">&lt;element.type &#123;...element.props&#125;&#123;...props&#125;&gt;&#123;children&#125;&lt;/element.type&gt;</code></pre><p>参考：<a href="https://zh-hans.reactjs.org/docs/react-api.html#cloneelement">React.cloneElement官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>React学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试01-你真的了解React吗？</title>
    <link href="/2020/11/30/%E9%9D%A2%E8%AF%9501-%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3React%E5%90%97%EF%BC%9F/"/>
    <url>/2020/11/30/%E9%9D%A2%E8%AF%9501-%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3React%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="面试场景1：谈谈你对React的理解？（概念题）"><a href="#面试场景1：谈谈你对React的理解？（概念题）" class="headerlink" title="面试场景1：谈谈你对React的理解？（概念题）"></a>面试场景1：谈谈你对React的理解？（概念题）</h4><p>针对这种概念题，一般采用四字口诀：“讲说理列”</p><ul><li>讲概念: 一句话讲清楚该技术是什么。  </li><li>说用途：描述该技术的用途（结合具体场景，拓展性的描述)</li><li>理思路：梳理该技术的核心思路或运作流程。</li><li>列优缺：对该技术的优点缺点进行列举（与其他技术方案进行横向对比，但切忌踩一捧一！）</li></ul><h5 id="1、讲React概念"><a href="#1、讲React概念" class="headerlink" title="1、讲React概念"></a>1、讲React概念</h5><p><strong>React是通过组件化的方式解决视图层开发复用的问题，本质是一个组件化框架。</strong></p><p>简单概括为： View = fn(props)， 给定相同的输入状态，函数总会生成一致的组件。如果变量多一些，也可以扩展为 View = fn(props,state,context)</p><h5 id="2、说React用途"><a href="#2、说React用途" class="headerlink" title="2、说React用途"></a>2、说React用途</h5><p><strong>React的用途就是：构建视图。</strong> React的生态丰富了它的使用场景：</p><ul><li>首先，PC网页和移动端网页，React都支持</li><li>其次，React Native 可用于开发ios与Android应用</li><li>React 360可以开发VR应用</li><li>冷门的ink,可以使用React开发命令行应用。</li></ul><h5 id="3、理React思路"><a href="#3、理React思路" class="headerlink" title="3、理React思路"></a>3、理React思路</h5><p><strong>React的核心思路：声明式、组件化、通用性</strong>（官方称，一次学习，随处编写）</p><ul><li><strong>声明式</strong>：优势在于直观，可以做到一目了然，也便于组合。</li></ul><p>命令式编程：</p><pre><code class="hljs js"><span class="hljs-comment">//HTML</span>&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&#x27;block&#x27;</span>&gt;&lt;/div&gt;<span class="hljs-comment">//JS</span><span class="hljs-keyword">const</span> block=$(<span class="hljs-string">&#x27;.block&#x27;</span>)block.css(<span class="hljs-string">&#x27;color&#x27;</span>,<span class="hljs-string">&#x27;red&#x27;</span>)</code></pre><p>声明式编程：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> Block=<span class="hljs-function">(<span class="hljs-params">props</span>)=&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;color:</span>&#x27;<span class="hljs-attr">red</span>&#x27;&#125;&#125;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre><p>可以发现，声明式编程更容易阅读，而且更容易与其他组件代码组合。</p><ul><li><p><strong>组件化</strong>：组件化优势在于可以降低系统间功能的耦合性，提高功能内部的聚合性。这样便于代码复用。</p></li><li><p><strong>通用性</strong>：React将DOM抽象为虚拟DOM，开发者并不是直接操作DOM。正因为这一层封装的存在，使得React不再局限于web开发，而是出现更繁荣的生态。不论VR，Native,还是shell命令，只有兼容虚拟DOM层，都可以直接运行React。</p></li></ul><h5 id="4、列React优缺"><a href="#4、列React优缺" class="headerlink" title="4、列React优缺"></a>4、列React优缺</h5><ul><li><p>优点：其实就是React的核心设计思路：声明式，组件化，通用性。</p></li><li><p>缺点：React不是一个一揽子框架，比如路由一类的功能，React团队希望交给社区解决。导致技术选型和学习使用上有较高的成本，在开发大型前端应用时需要向社区寻找并整合解决方案。（非官方的一揽子解决方案是有的，比如DvaJS、React-coat等）</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>React02-setState的使用</title>
    <link href="/2020/11/27/React02-setState%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/27/React02-setState%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="setState-updater-callback"><a href="#setState-updater-callback" class="headerlink" title="setState(updater, [callback])"></a>setState(updater, [callback])</h3><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>1、setState()将对组件state的更新排入队列，并通知React需要使用更新后的state重新渲染此组件及其子组件。这是用于更新用户界面以响应事件处理器和处理服务器数据的主要方式。</p><p>2、<strong>将setState()视为请求而不是立即更新组件的命令</strong>。为了更好的感知性能，React会延迟调用它，然后通过一次传递更新多个组件。React并不会保证state的变更会立即生效。</p><p>3、<strong>setState()并不总是立即更新组件，它会批量推迟更新</strong>。这使得在调用setState()后立即读取this.state成为了隐患。为了消除隐患，应当使用componentDidUpdate或者setState的回调函数，这两种方式都可以保证在应用更新后触发。如果需要基于之前的state来设置当前的state，查看关于updater部分的描述。</p><p>4、除非shouldComponentUpate()返回false,否则setState()将始终执行重新渲染操作。</p><h4 id="二、参数1：updater函数"><a href="#二、参数1：updater函数" class="headerlink" title="二、参数1：updater函数"></a>二、参数1：updater函数</h4><pre><code class="hljs js">(state,props) =&gt; stateChange</code></pre><p>其中，state是对应用变化时组件状态的引用，它不应该直接被修改。应当使用基于state和props构建的新对象来表示变化。例如，我们需要使用props.step来增加state：</p><pre><code class="hljs js"><span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state, props</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">counter</span>: state.counter + props.step&#125;&#125;)</code></pre><p>updater函数中接收的state和props都保证为最新。updater的返回值会与state进行浅合并。</p><p>🐖：setState()的第一个参数除了接受函数外，还接受对象类型：</p><pre><code class="hljs js">setState(stateChange[,callback])</code></pre><p>stateChange会将传入的对象浅合并到新的state中，例子：</p><pre><code class="hljs js"><span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">counter</span>: <span class="hljs-number">2</span>&#125;)</code></pre><p>这种形式的setState()也是异步的！并且在同一个周期内对多个setState进行批处理。例如，如果在同一个时期多次设置商品数量增加,则相当于：</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.assign(    previousState,    &#123;<span class="hljs-attr">quantiity</span>: state.quantity + <span class="hljs-number">1</span>&#125;,    &#123;<span class="hljs-attr">quantiity</span>: state.quantity + <span class="hljs-number">1</span>&#125;)</code></pre><p>此时，后调用的setState()将覆盖同一周期内先调用setState的值，因此商品数仅增加1次。如果后续状态取决于当前的状态，建议使用updater函数的形式代替：</p><pre><code class="hljs js"><span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">quantity</span>: state.quantity + <span class="hljs-number">1</span>&#125;;&#125;)</code></pre><h4 id="三、参数2：回调函数callback-（可选）"><a href="#三、参数2：回调函数callback-（可选）" class="headerlink" title="三、参数2：回调函数callback （可选）"></a>三、参数2：回调函数callback （可选）</h4><p>这个回调函数，<strong>将在setState完成合并并重新渲染组件后执行</strong>。通常，建议使用componentDidUpdate()方式来代替这个回调函数的使用。</p>]]></content>
    
    
    <categories>
      
      <category>React学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>React01--ref的使用</title>
    <link href="/2020/11/24/React01-ref%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/24/React01-ref%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="ref的详细用法"><a href="#ref的详细用法" class="headerlink" title="ref的详细用法"></a>ref的详细用法</h2><p>在react典型的数据流中，props传递时父子组件交互的唯一方式：通过传递一个新的props值来使子组件重新render，从而达到父子组件通信。但是，某些情况下，你需要在典型数据流之外强制修改子组件。比如：</p><ul><li>管理焦点，文本选择或者媒体播放</li><li>触发强制动画</li><li>集成第三方DOM库</li></ul><p>这些情况下，react提供了新的方案：ref</p><h4 id="一、ref简介"><a href="#一、ref简介" class="headerlink" title="一、ref简介"></a>一、ref简介</h4><p>React提供的ref属性，<strong>表示对组件真正实例的引用</strong>，其实就是ReactDOM.render()返回的组件实例。需要区分一下：ReactDOM.render()渲染组件时返回的是组件实例；而渲染dom元素时，返回的是具体的dom节点。</p><p>例如，下面的代码：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> domCom = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<span class="hljs-keyword">const</span> refDom = ReactDOM.render(domCom,container);<span class="hljs-keyword">const</span> refCom = ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">myComponent</span> /&gt;</span></span>,container);<span class="hljs-built_in">console</span>.log(refDom);<span class="hljs-built_in">console</span>.log(refCom);</code></pre><p>上述代码运行如下：<br><img src="https://pic.downk.cc/item/5fbcde31b18d6271133f9065.jpg"></p><p>ref可以挂在任何组件上，可以挂在组件上也可以是dom元素上：</p><ul><li><font face='黑体' size=4 color=red>挂在组件上（指有状态组件）的ref表示对组件实例的引用</li><li>挂载到dom元素上时表示具体的dom节点 </font></li></ul><h4 id="二、ref可以设置回调函数"><a href="#二、ref可以设置回调函数" class="headerlink" title="二、ref可以设置回调函数"></a>二、ref可以设置回调函数</h4><p>ref属性可以设置为一个回调函数，这也是官方推荐的做法。这个函数的执行时机为：</p><ul><li><font color=blue>组件被挂载后</font>，回调函数立即执行，回调函数的参数为该组件的具体实例。</li><li><font color=blue>组件被卸载或者原有的ref属性本身发生变化时</font>，回调也会被立即执行，此时回调函数参数为null，以避免内存泄漏。</li></ul><p>例子：</p><pre><code class="hljs js"><span class="hljs-comment">//使用ref存储DOM节点的引用：</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomTextInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">construtor</span>(<span class="hljs-params">props</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props);    <span class="hljs-comment">//创建一个ref来存储 textInput 的DOM元素</span>    <span class="hljs-built_in">this</span>.textInput = React.createRef();    <span class="hljs-built_in">this</span>.focusTextInput = <span class="hljs-built_in">this</span>.focusTextInput.bind(<span class="hljs-built_in">this</span>);  &#125;  <span class="hljs-function"><span class="hljs-title">focusTextInput</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-comment">//直接使用原生的API来使得 text输入框获得焦点</span>    <span class="hljs-comment">//注意：我们通过“current” 来访问DOM节点</span>    <span class="hljs-built_in">this</span>.textInput.current.focus();  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-comment">//告诉Reacts 我们想把&lt;input&gt; ref</span>    <span class="hljs-comment">//关联到constructor里面的&#x27;textInput&#x27;上</span>    <span class="hljs-keyword">return</span> (      &lt;div&gt;        &lt;input  type=<span class="hljs-string">&#x27;text&#x27;</span> ref=&#123;<span class="hljs-built_in">this</span>.textInput&#125;/&gt;        &lt;input type=<span class="hljs-string">&#x27;button&#x27;</span> value=<span class="hljs-string">&#x27;focus the text input&#x27;</span> onClick=&#123;<span class="hljs-built_in">this</span>.focusTextInput&#125; /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><p>上述代码中，React将在组件挂载时，会调用ref回调函数并传入DOM元素，当卸载时也调用它并传入null。在componentDidMount 或 componentDidUpdate触发前，React会保证refs一定是最新的。</p><h4 id="三、ref可以设置字符串-了解"><a href="#三、ref可以设置字符串-了解" class="headerlink" title="三、ref可以设置字符串 (了解)"></a>三、ref可以设置字符串 (了解)</h4><p>&emsp;ref还可以设置为字符串值，不过这种方式基本不再推荐使用。</p><pre><code class="hljs js">&lt;input ref=<span class="hljs-string">&#x27;title&#x27;</span> /&gt;</code></pre><p>&emsp;然后再其他地方如事件回调中通过<strong>this.refs</strong>可以访问该组件实例，其实就是dom节点</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> element = <span class="hljs-built_in">this</span>.refs.title;</code></pre><p>我的github里react-demos项目下，question分支模仿知乎问答的例子，就使用了ref的这个用法。<a href="https://github.com/DENGCPU/React-demos/blob/question/README.md">简单知乎问答demo</a></p><h4 id="四、创建与访问Refs"><a href="#四、创建与访问Refs" class="headerlink" title="四、创建与访问Refs"></a>四、创建与访问Refs</h4><p><strong>1.创建refs:</strong></p><p>&emsp;refs是使用<font color=green>React.createRef()</font>创建的，并通过ref属性附加到React元素。在构建组件时，通常将refs分配给组件实例属性，以便在整个组件中都引用它们。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props);    <span class="hljs-built_in">this</span>.myRef = React.createRef();  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.myRef&#125;</span> /&gt;</span></span>;  &#125;&#125;</code></pre><p><strong>2.访问refs:</strong></p><p>&emsp;当ref被传递给render中的元素时，对该节点的引用可以在ref的<font color=red>current</font>属性中被访问。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> node = <span class="hljs-built_in">this</span>.myRef.current;</code></pre><p>ref的值根据节点类型不同而有所不同：</p><ul><li>当ref属性用于HTML元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性。</li><li>当ref属性用于自定义class组件时，ref对象接收组件的挂载实例作为其current属性。</li></ul><p>🐖：不能在函数组件上使用ref属性，因为他们没有实例！</p><p>参考：<a href="https://juejin.cn/post/6844903749211652104">React ref的基本使用</a> 以及 <a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html">React官方文档–Refs and The Dom</a></p>]]></content>
    
    
    <categories>
      
      <category>React学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>28-时刻考虑性能问题</title>
    <link href="/2020/11/21/28-%E6%97%B6%E5%88%BB%E8%80%83%E8%99%91%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/21/28-%E6%97%B6%E5%88%BB%E8%80%83%E8%99%91%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="一、如何避免性能问题："><a href="#一、如何避免性能问题：" class="headerlink" title="一、如何避免性能问题："></a>一、如何避免性能问题：</h4><p>1、了解常见的性能问题场景（解决最可能产生性能问题的场景）</p><ul><li>  键盘输入过程卡顿</li><li>  鼠标的移动过程卡顿</li></ul><p>2、时刻注意代码的潜在性能问题</p><ul><li>什么时候拆分组件</li><li>组件粒度是否够细</li></ul><p>3、注意可重构的代码</p><ul><li>代码的耦合性必须低，功能模块非常独立</li></ul><p>4、了解如何使用工具定位性能问题：</p><ul><li>React-devTool</li><li>Chrome-devTool</li></ul><h4 id="二、网络性能优化：自动化按需加载"><a href="#二、网络性能优化：自动化按需加载" class="headerlink" title="二、网络性能优化：自动化按需加载"></a>二、网络性能优化：自动化按需加载</h4><p>如何在react中实现按需加载：<br>1、按需加载：用户当前需要用什么功能就只加载这个功能对应的代码。<br>2、使用Webpack的import API<br>3、使用react-loadable库实现React异步加载</p><p><img src="https://pic.downk.cc/item/5fb913a4b18d627113603f84.jpg" alt="按需加载"></p><h4 id="三、使用Reselect避免重复计算"><a href="#三、使用Reselect避免重复计算" class="headerlink" title="三、使用Reselect避免重复计算"></a>三、使用Reselect避免重复计算</h4><p>Reselect:创建自动缓存的数据处理流程（只有数据变化时才重新计算，否则使用缓存的结果）</p><p><strong>原则</strong>:所有能够计算得到的数据一定是通过计算拿到</p><p><img src="https://pic.downk.cc/item/5fb91595b18d62711360ba51.jpg" alt="自动缓存"></p><h4 id="四、React异步渲染"><a href="#四、React异步渲染" class="headerlink" title="四、React异步渲染"></a>四、React异步渲染</h4><p><img src="https://pic.downk.cc/item/5fb918ffb18d62711361b0b2.jpg"></p><p><strong>时间分片：</strong><br>1、虚拟DOM的diff操作可以分片进行<br>2、React新API：unstable_deferredUpdates<br>3、Chrome新API：requestIdleCallback 浏览器什么时候空闲</p><p><strong>渲染挂起：</strong></p><p>1、unstable_deferUpdate<br>2、React的新内置组件：Timeout组件</p><h4 id="五、使用工具发现性能问题"><a href="#五、使用工具发现性能问题" class="headerlink" title="五、使用工具发现性能问题"></a>五、使用工具发现性能问题</h4><p>1、使用React DevTool找到多余渲染<br>2、使用Chrome DevTool定位性能瓶颈</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>27-React中拖放的实现</title>
    <link href="/2020/11/21/27-React%E4%B8%AD%E6%8B%96%E6%94%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/11/21/27-React%E4%B8%AD%E6%8B%96%E6%94%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>第三方库实现拖放的缺陷：</strong></p><ul><li>第三方库实现拖放不够灵活，</li><li>很多场景比较简单，并不需要引入第三方库</li><li>增加额外的体积会影响性能。</li></ul><p><strong>实现拖放的技术要点：</strong></p><p>1、如何使用React的鼠标事件系统<br>2、如何判断拖放开始和结束<br>3、如何让实现拖放元素的位置移动<br>4、拖放状态在组件中如何维护</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>26-React集成第三方JS库（d3.js为例）</title>
    <link href="/2020/11/21/26-React%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9JS%E5%BA%93%EF%BC%88d3-js%E4%B8%BA%E4%BE%8B%EF%BC%89/"/>
    <url>/2020/11/21/26-React%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9JS%E5%BA%93%EF%BC%88d3-js%E4%B8%BA%E4%BE%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h4 id="集成第三方JS库的技术要点："><a href="#集成第三方JS库的技术要点：" class="headerlink" title="集成第三方JS库的技术要点："></a>集成第三方JS库的技术要点：</h4><p>1、使用ref获取原生DOM节点引用<br>2、手动将组件状态更新到DOM节点<br>3、组件销毁时移除原生节点DOM事件</p><p>d3.js用来画图形的第三方库，操作原生DOM节点，也是以数据驱动（与React非常吻合）。</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>25-使用React-Router实现分布操作</title>
    <link href="/2020/11/21/25-%E4%BD%BF%E7%94%A8React-Router%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/11/21/25-%E4%BD%BF%E7%94%A8React-Router%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="向导页面需要考虑的技术要点："><a href="#向导页面需要考虑的技术要点：" class="headerlink" title="向导页面需要考虑的技术要点："></a>向导页面需要考虑的技术要点：</h4><p>例子：一个向导页面<br><img src="https://pic.downk.cc/item/5fb8dbeab18d62711350c62f.jpg"></p><p>1、使用URL进行导航<br>2、表单数据如何管理<br>3.页面状态如何切换（根据数据的状态决定UI的状态）</p><h4 id="基于路由实现菜单导航："><a href="#基于路由实现菜单导航：" class="headerlink" title="基于路由实现菜单导航："></a>基于路由实现菜单导航：</h4><p>技术要点：<br>1.菜单导航只改变URL状态<br>2.根据当前URL显示菜单的当前状态。</p><p>可以使用react-router的NavLink,展示当前的选中状态 （NavLink的activeClassName属性）</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>24-页面数据来源于多个请求</title>
    <link href="/2020/11/21/24-%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90%E4%BA%8E%E5%A4%9A%E4%B8%AA%E8%AF%B7%E6%B1%82/"/>
    <url>/2020/11/21/24-%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90%E4%BA%8E%E5%A4%9A%E4%B8%AA%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h4 id="一、页面数据来自多个请求："><a href="#一、页面数据来自多个请求：" class="headerlink" title="一、页面数据来自多个请求："></a>一、页面数据来自多个请求：</h4><p>1、请求之间无依赖关系时，多个请求可以并发进行</p><p>2、请求之间有依赖关系时，需要依次进行</p><p>3、请求完成之前，页面显示Loding状态<br>（Loding可能并不需要特别设为一个状态值，可以根据数据的状态来判断是否显示’Loding..’)</p><h4 id="二、内容页的加载与缓存"><a href="#二、内容页的加载与缓存" class="headerlink" title="二、内容页的加载与缓存"></a>二、内容页的加载与缓存</h4><p><img src="https://pic.downk.cc/item/5fb8da68b18d627113503356.jpg"></p><p><strong>内容页和列表页的数据关系：</strong></p><ul><li>简单业务：列表页数据包含内容页的数据</li><li>复杂业务：内容页数据需要额外获取</li><li>内容页数据的缓存</li></ul><p>🐖：内容页不能只依靠列表页进行，用户可能刷新页面，所以它自己也需要定义一个访问接口的action。</p><p><img src="https://pic.downk.cc/item/5fb8d9d7b18d627113500886.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>23-在React中实现列表页</title>
    <link href="/2020/11/20/23-%E5%9C%A8React%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E9%A1%B5/"/>
    <url>/2020/11/20/23-%E5%9C%A8React%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E9%A1%B5/</url>
    
    <content type="html"><![CDATA[<h4 id="一、列表页：搜索、数据缓存和分页"><a href="#一、列表页：搜索、数据缓存和分页" class="headerlink" title="一、列表页：搜索、数据缓存和分页"></a>一、列表页：搜索、数据缓存和分页</h4><p>开发列表页需要考虑的技术要点：</p><ul><li>如何翻页</li><li>如何进行内容搜索</li><li>如何缓存数据</li><li>何时进行页面刷新</li></ul><p><img src="https://pic.downk.cc/item/5fb76b52b18d627113ee2145.jpg" alt="列表页的数据模型"></p><p><img src="https://pic.downk.cc/item/5fb76b8eb18d627113ee2fe8.jpg" alt="Store的设计"></p><p><img src="https://pic.downk.cc/item/5fb76ccbb18d627113ee8a4b.jpg" alt="URL设计和Store同步"></p><h4 id="二、列表页：缓存更新、加载状态以及错误处理"><a href="#二、列表页：缓存更新、加载状态以及错误处理" class="headerlink" title="二、列表页：缓存更新、加载状态以及错误处理"></a>二、列表页：缓存更新、加载状态以及错误处理</h4><p><img src="https://pic.downk.cc/item/5fb76f47b18d627113ef65f6.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>22-在React中实现表单</title>
    <link href="/2020/11/20/22-%E5%9C%A8React%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%A1%A8%E5%8D%95/"/>
    <url>/2020/11/20/22-%E5%9C%A8React%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%A1%A8%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h4 id="一、实现表单：初始数据、提交和跳转"><a href="#一、实现表单：初始数据、提交和跳转" class="headerlink" title="一、实现表单：初始数据、提交和跳转"></a>一、实现表单：初始数据、提交和跳转</h4><p>1、单纯使用React的方式实现表单</p><p><img src="https://pic.downk.cc/item/5fb76076b18d627113eb2a31.jpg"></p><p>🐖：是在form中编辑onSubmit，而不是在button的点击事件里提交，这样即使你点回车也会进行提交（给出错误提示）</p><p>可以发现这样实现表单是比较麻烦的！</p><p>2、使用UI library实现表单（比如Antd)</p><p>具体参照：<a href="https://ant.design/components/form-cn/#header">Antd-Form表单</a></p><p>3、可以对API进行封装</p><h4 id="二、实现表单：错误处理、动态操作表单元素，内容动态加载"><a href="#二、实现表单：错误处理、动态操作表单元素，内容动态加载" class="headerlink" title="二、实现表单：错误处理、动态操作表单元素，内容动态加载"></a>二、实现表单：错误处理、动态操作表单元素，内容动态加载</h4><p>以Antd为例：一个demo<br><a href="https://codesandbox.io/s/6n20nrzlxz?file=/src/c29/FormBuilder.js">https://codesandbox.io/s/6n20nrzlxz?file=/src/c29/FormBuilder.js</a></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>21-ReactRouter管理登录和授权</title>
    <link href="/2020/11/20/21-ReactRouter%E7%AE%A1%E7%90%86%E7%99%BB%E5%BD%95%E5%92%8C%E6%8E%88%E6%9D%83/"/>
    <url>/2020/11/20/21-ReactRouter%E7%AE%A1%E7%90%86%E7%99%BB%E5%BD%95%E5%92%8C%E6%8E%88%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<h3 id="使用React-Router-管理路由授权"><a href="#使用React-Router-管理路由授权" class="headerlink" title="使用React-Router 管理路由授权"></a>使用React-Router 管理路由授权</h3><p>1、实现基础：React Router的动态路由机制<br>2、区分受保护路由和公开路由<br>3、访问未授权路由时重定向到登录页面或显示禁止访问</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>20-使用Rekit开发可扩展的React应用</title>
    <link href="/2020/11/20/20-%E4%BD%BF%E7%94%A8Rekit%E5%BC%80%E5%8F%91%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84React%E5%BA%94%E7%94%A8/"/>
    <url>/2020/11/20/20-%E4%BD%BF%E7%94%A8Rekit%E5%BC%80%E5%8F%91%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84React%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="Rekit-React专属IDE和工具集"><a href="#Rekit-React专属IDE和工具集" class="headerlink" title="Rekit: React专属IDE和工具集"></a>Rekit: React专属IDE和工具集</h3><p><img src="https://pic.downk.cc/item/5fb7295cb18d627113dc80e8.jpg"></p><h4 id="一、使用Rekit创建项目，代码生成和重构"><a href="#一、使用Rekit创建项目，代码生成和重构" class="headerlink" title="一、使用Rekit创建项目，代码生成和重构"></a>一、使用Rekit创建项目，代码生成和重构</h4><p>只需要写功能部分的代码，不用再自己构建骨架。</p><p><img src="https://pic.downk.cc/item/5fb729deb18d627113dca15a.jpg"></p><p><img src="https://pic.downk.cc/item/5fb72aa5b18d627113dccff5.jpg"></p><p><img src="https://pic.downk.cc/item/5fb72b4cb18d627113dcfc0c.jpg"></p><p><img src="https://pic.downk.cc/item/5fb72c21b18d627113dd4456.jpg"></p><p><img src="https://pic.downk.cc/item/5fb72c51b18d627113dd4ee6.jpg"></p><p><img src="https://pic.downk.cc/item/5fb72ceeb18d627113dd7003.jpg"></p><h4 id="二、使用Rekit遵循最佳实践和保持代码一致性"><a href="#二、使用Rekit遵循最佳实践和保持代码一致性" class="headerlink" title="二、使用Rekit遵循最佳实践和保持代码一致性"></a>二、使用Rekit遵循最佳实践和保持代码一致性</h4><p>==最佳实践:==</p><ul><li>1.以feature方式组织代码</li><li>2.拆分组件component，action和reducer</li><li>3.拆分路由配置</li></ul><p>==通过代码自动生成保持一致性：==</p><ul><li>1.文件夹结构一致性</li><li>2.文件名一致性</li><li>3.变量名一致性</li><li>4.代码逻辑一致性</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>19-拆分大型项目的复杂度</title>
    <link href="/2020/11/20/19-%E6%8B%86%E5%88%86%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2020/11/20/19-%E6%8B%86%E5%88%86%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="拆分复杂度"><a href="#拆分复杂度" class="headerlink" title="拆分复杂度"></a>拆分复杂度</h3><h4 id="一、按领域模型（feature）组织代码，降低耦合度"><a href="#一、按领域模型（feature）组织代码，降低耦合度" class="headerlink" title="一、按领域模型（feature）组织代码，降低耦合度"></a>一、按领域模型（feature）组织代码，降低耦合度</h4><p><img src="https://pic.downk.cc/item/5fb71ee0b18d627113d9dabc.jpg"></p><p><img src="https://pic.downk.cc/item/5fb71f0ab18d627113d9e304.jpg"></p><p><img src="https://pic.downk.cc/item/5fb71f24b18d627113d9e849.jpg"></p><p><strong>解决：先以业务逻辑,以功能进行划分，然后每个功能(feature)内部有自己的reducer，component，action</strong></p><p><img src="https://pic.downk.cc/item/5fb71f7db18d627113d9fdb5.jpg"></p><p>使用React技术栈如何实现这种架构？</p><p><img src="https://pic.downk.cc/item/5fb71fe1b18d627113da1548.jpg"></p><p>以功能区分，路由配置也可以分散在每个feature中，这样可扩展性和可维护性更好！</p><h4 id="二、如何组织component，action-和-reducer"><a href="#二、如何组织component，action-和-reducer" class="headerlink" title="二、如何组织component，action 和 reducer"></a>二、如何组织component，action 和 reducer</h4><p><img src="https://pic.downk.cc/item/5fb720bab18d627113da4750.jpg"></p><p>单元测试文件夹tests是单独维护的，单独放在一个地方。</p><p>常量：通常在每个feature下面有个constant.js文件</p><p><img src="https://pic.downk.cc/item/5fb72191b18d627113da77a0.jpg"></p><p>rootReducer的写法：<br><img src="https://pic.downk.cc/item/5fb721e2b18d627113da87fe.jpg"></p><p><strong>总结</strong>：</p><ul><li>按照feature组织组件component，action和reducer</li><li>使用root loader加载feature下的各个资源</li><li>做到高内聚、松耦合</li></ul><h4 id="三、如何组织React-Route的路由配置"><a href="#三、如何组织React-Route的路由配置" class="headerlink" title="三、如何组织React Route的路由配置"></a>三、如何组织React Route的路由配置</h4><p><img src="https://pic.downk.cc/item/5fb72294b18d627113dabdf7.jpg"></p><p>推荐JSON方式的路由：</p><p><img src="https://pic.downk.cc/item/5fb722f6b18d627113dae650.jpg"></p><p>解析JSON路由：<br><img src="https://pic.downk.cc/item/5fb72375b18d627113db0340.jpg"></p><p><strong>总结</strong>：</p><ul><li>每个feature都有自己的专属路由配置</li><li>顶层路由使用JSON配置更容易维护</li><li>如何解析JSON配置到React Router语法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>18-前端项目的理想架构</title>
    <link href="/2020/11/20/18-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%90%86%E6%83%B3%E6%9E%B6%E6%9E%84/"/>
    <url>/2020/11/20/18-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%90%86%E6%83%B3%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="前端项目的理想架构"><a href="#前端项目的理想架构" class="headerlink" title="前端项目的理想架构"></a>前端项目的理想架构</h3><p><img src="https://pic.downk.cc/item/5fb71b94b18d627113d91010.jpg"></p><h4 id="1、-易于开发"><a href="#1、-易于开发" class="headerlink" title="1、 易于开发"></a>1、 易于开发</h4><ul><li>开发工具是否完善</li><li>生态圈是否繁荣</li><li>社区是否活跃</li></ul><h4 id="2、易于扩展"><a href="#2、易于扩展" class="headerlink" title="2、易于扩展"></a>2、易于扩展</h4><ul><li>增加新动能是否容易</li><li>新功能是否会显著增加系统复杂度</li></ul><h4 id="3、易于维护"><a href="#3、易于维护" class="headerlink" title="3、易于维护"></a>3、易于维护</h4><ul><li>代码是否容易理解</li><li>文档是否健全</li></ul><h4 id="4、易于测试"><a href="#4、易于测试" class="headerlink" title="4、易于测试"></a>4、易于测试</h4><p>（测试后于开发，所以必须在开发时就考虑清楚）</p><ul><li>功能的分层是否清晰（Jquery那种就很难进行单元测试）</li><li>副作用少</li><li>尽量使用纯函数</li></ul><h4 id="5、易于构建"><a href="#5、易于构建" class="headerlink" title="5、易于构建"></a>5、易于构建</h4><ul><li>使用通用技术和架构</li><li>构建工具的选择（webpack等，</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>17-常用开发调试工具</title>
    <link href="/2020/11/20/17-%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <url>/2020/11/20/17-%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="常用开发调试工具："><a href="#常用开发调试工具：" class="headerlink" title="常用开发调试工具："></a>常用开发调试工具：</h3><h4 id="1-ESLint"><a href="#1-ESLint" class="headerlink" title="1.ESLint"></a>1.ESLint</h4><ul><li>使用.eslintrc进行规则的配置</li><li>告诉你哪里不符合规则</li><li>可以使用airbnb的JavaScript代码风格</li></ul><h4 id="2-Prettier"><a href="#2-Prettier" class="headerlink" title="2.Prettier"></a>2.Prettier</h4><ul><li>代码格式化的神器（可以自动修改不符合规则的）</li><li>包装更容易写出风格一致的代码</li></ul><h4 id="3-React-Dev-Tools"><a href="#3-React-Dev-Tools" class="headerlink" title="3.React Dev Tools"></a>3.React Dev Tools</h4><p><img src="https://pic.downk.cc/item/5fb71930b18d627113d88a26.jpg"></p><ul><li>可以观察React组件树的DOM结构</li><li>可以看到哪些组件render</li></ul><h4 id="4-Redux-Dev-Tools"><a href="#4-Redux-Dev-Tools" class="headerlink" title="4.Redux Dev Tools"></a>4.Redux Dev Tools</h4><p><img src="https://pic.downk.cc/item/5fb7197bb18d627113d898dd.jpg"></p><ul><li>可以观察当前Store的状态</li><li>用户发出动作后，会看到action</li><li>时间线：可以恢复到action变化之前的时间线</li><li>可以自动生成一些测试的代码，直接copy到单元测试文件中</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>16-使用Jest和Enzyme等工具进行单元测试</title>
    <link href="/2020/11/18/16-%E4%BD%BF%E7%94%A8Jest%E5%92%8CEnzyme%E7%AD%89%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/11/18/16-%E4%BD%BF%E7%94%A8Jest%E5%92%8CEnzyme%E7%AD%89%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一、React让前端单元测试变得容易："><a href="#一、React让前端单元测试变得容易：" class="headerlink" title="一、React让前端单元测试变得容易："></a>一、React让前端单元测试变得容易：</h3><p>1、React应用很少需要访问浏览器API<br>2、虚拟DOM可以在NodeJS环境运行和测试<br>3、Redux隔离了状态管理，纯数据层单元测试</p><h3 id="二、单元测试涉及的工具"><a href="#二、单元测试涉及的工具" class="headerlink" title="二、单元测试涉及的工具"></a>二、单元测试涉及的工具</h3><p>1、Jest: FaceBook开源的JS单元测试框架<br>2、JS DOM： 浏览器环境的NodeJS模拟<br>3、Enzyme： react组件渲染和测试<br>4、nock： 模拟HTTP请求<br>5、sinon： 函数模拟和调用跟踪<br>6、istanbul: 单元测试覆盖率（对已有方法修改和埋点）</p><p><img src="https://pic.downk.cc/item/5fb4bc4cb18d62711351ecbc.jpg"></p><p><img src="https://pic.downk.cc/item/5fb4bc5fb18d62711351f09e.jpg"></p><p><img src="https://pic.downk.cc/item/5fb4bc9db18d62711351fc16.jpg"></p><p><img src="https://pic.downk.cc/item/5fb4bdf1b18d6271135241c2.jpg"></p><p><img src="https://pic.downk.cc/item/5fb4be5eb18d627113525540.jpg"></p><p><img src="https://pic.downk.cc/item/5fb4bef6b18d627113527125.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单元测试工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15-使用Next.js</title>
    <link href="/2020/11/18/15-%E4%BD%BF%E7%94%A8Next-js/"/>
    <url>/2020/11/18/15-%E4%BD%BF%E7%94%A8Next-js/</url>
    
    <content type="html"><![CDATA[<p>使用next.js开发React项目的同构应用。</p><h3 id="一、什么是同构应用？"><a href="#一、什么是同构应用？" class="headerlink" title="一、什么是同构应用？"></a>一、什么是同构应用？</h3><p><img src="https://pic.downk.cc/item/5fb4b6adb18d62711350daf9.jpg"></p><p>next.js可以自动配置好同构应用的webpack配置等细节。</p><h3 id="二、next的基本用法"><a href="#二、next的基本用法" class="headerlink" title="二、next的基本用法"></a>二、next的基本用法</h3><p><img src="https://pic.downk.cc/item/5fb4b787b18d62711350fce5.jpg"></p><p><strong>在页面中使用其他的React组件：</strong></p><p>1、页面也是标准的node模块，可使用其他的React组件 （放在components目录下面）<br>2、页面会针对性打包， 仅包含起引入的组件。</p><p><img src="https://pic.downk.cc/item/5fb4b95bb18d627113515a13.jpg"></p><p>🐖：prefetch并不会预加载服务器端的数据</p><p><strong>关于lazy load:</strong><br><img src="https://pic.downk.cc/item/5fb4ba11b18d627113517eef.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14-UI组件库的对比</title>
    <link href="/2020/11/18/14-UI%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <url>/2020/11/18/14-UI%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Ant-Design"><a href="#一、Ant-Design" class="headerlink" title="一、Ant Design"></a>一、Ant Design</h3><p>服务于企业级产品的设计体系，有完善的文档</p><h3 id="二、Marterial-UI"><a href="#二、Marterial-UI" class="headerlink" title="二、Marterial-UI"></a>二、Marterial-UI</h3><p>风格更时尚，更花哨，面向消费者</p><h3 id="三、Semantic-UI"><a href="#三、Semantic-UI" class="headerlink" title="三、Semantic UI"></a>三、Semantic UI</h3><p>把UI作为language描述，提供了不同library的实现。</p><p><strong>选择UI库的考虑因素：</strong></p><ul><li>1、组件库是否齐全</li><li>2、样式风格是否符合业务需求</li><li>3、API的设计是否便捷灵活</li><li>4、技术支持是否完善（文档，issue）</li><li>5、开发是否活跃（维护，迭代）</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>bug记录</title>
    <link href="/2020/11/18/bug%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/11/18/bug%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1、-Error-“Objects-are-not-valid-as-a-React-child”"><a href="#1、-Error-“Objects-are-not-valid-as-a-React-child”" class="headerlink" title="1、 Error: “Objects are not valid as a React child”"></a>1、 Error: “Objects are not valid as a React child”</h3><p>在redux的练习中，blog这个demo报了这个错：</p><p><img src="https://pic.downk.cc/item/5fb48937b18d62711347d6df.jpg"></p><p>原代码：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> jsonPlaceholder.get(<span class="hljs-string">`/users/<span class="hljs-subst">$&#123;id&#125;</span>`</span>);dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;FETCH_USER&quot;</span>, <span class="hljs-attr">payload</span>: response.data &#125;);</code></pre><p>打开访问的API后发现，response.data是个object类型，不能直接赋值给payload<br>应该先通过JSON.stringify()将其转换为JSON格式，再进行赋值。</p><p>修改后的代码如下：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> jsonPlaceholder.get(<span class="hljs-string">`/users/<span class="hljs-subst">$&#123;id&#125;</span>`</span>);<span class="hljs-keyword">const</span> data = <span class="hljs-built_in">JSON</span>.stringify(response.data);dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;FETCH_USER&quot;</span>, <span class="hljs-attr">payload</span>: data &#125;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>bug汇总</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13-React-Router:路由不只是页面切换，更是代码组织方式</title>
    <link href="/2020/11/17/13-React-Router-%E8%B7%AF%E7%94%B1%E4%B8%8D%E5%8F%AA%E6%98%AF%E9%A1%B5%E9%9D%A2%E5%88%87%E6%8D%A2%EF%BC%8C%E6%9B%B4%E6%98%AF%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/"/>
    <url>/2020/11/17/13-React-Router-%E8%B7%AF%E7%94%B1%E4%B8%8D%E5%8F%AA%E6%98%AF%E9%A1%B5%E9%9D%A2%E5%88%87%E6%8D%A2%EF%BC%8C%E6%9B%B4%E6%98%AF%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="一、为什么需要路由？"><a href="#一、为什么需要路由？" class="headerlink" title="一、为什么需要路由？"></a>一、为什么需要路由？</h3><ul><li>1.单页应用需要进行页面切换</li><li>2.通过URL可以定位到页面</li><li>3.更有语义的组织资源</li></ul><p><img src="https://pic.downk.cc/item/5fb37daab18d62711306e930.jpg"></p><p><img src="https://pic.downk.cc/item/5fb37e3cb18d6271130703a8.jpg"></p><h3 id="二、React-Router的特性："><a href="#二、React-Router的特性：" class="headerlink" title="二、React-Router的特性："></a>二、React-Router的特性：</h3><p>1、声明式路由定义<br>2、动态路由：页面render时，path才会被解析</p><h3 id="三、实现路由的三种方式"><a href="#三、实现路由的三种方式" class="headerlink" title="三、实现路由的三种方式"></a>三、实现路由的三种方式</h3><p>1、URL路由<br>2、Hash路由： #+ 路径，支持低版本<br>3、内存路由：MemoryRouter，服务器端渲染</p><h3 id="四、基于路由配置进行资源组织"><a href="#四、基于路由配置进行资源组织" class="headerlink" title="四、基于路由配置进行资源组织"></a>四、基于路由配置进行资源组织</h3><p>1、实现业务逻辑的松耦合<br>2、易于扩展，重构和维护<br>3、路由层面实现Lazy Load</p><h3 id="五、React-Router-的几个API"><a href="#五、React-Router-的几个API" class="headerlink" title="五、React-Router 的几个API"></a>五、React-Router 的几个API</h3><p><img src="https://pic.downk.cc/item/5fb37fdab18d627113075987.jpg"></p><p><img src="https://pic.downk.cc/item/5fb37feeb18d627113075f96.jpg"></p><p><img src="https://pic.downk.cc/item/5fb38003b18d627113076520.jpg"></p><p><img src="https://pic.downk.cc/item/5fb38032b18d627113076f40.jpg"></p><p><img src="https://pic.downk.cc/item/5fb38056b18d627113077657.jpg"></p><p><img src="https://pic.downk.cc/item/5fb380a8b18d627113078667.jpg"></p><h3 id="六、通过URL传递参数"><a href="#六、通过URL传递参数" class="headerlink" title="六、通过URL传递参数"></a>六、通过URL传递参数</h3><p><img src="https://pic.downk.cc/item/5fb3827bb18d62711307e56e.jpg"></p><p><img src="https://pic.downk.cc/item/5fb3834eb18d627113081472.jpg"></p><p><img src="https://pic.downk.cc/item/5fb3842ab18d627113084eaf.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12-Redux在Rect中的用法</title>
    <link href="/2020/11/17/12-Redux%E5%9C%A8Rect%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2020/11/17/12-Redux%E5%9C%A8Rect%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>&emsp;为了方便在react中使用redux, Redux的作者封装了一个React专用的库<strong>React-Redux</strong>.</p><p>&emsp;这个库是可选的，在实际项目中应该权衡下是直接使用redux还是使用React-Redux。后者虽然方便，但是要掌握额外的API，并且要遵守它的组件拆分规则。</p><h3 id="一、UI组件"><a href="#一、UI组件" class="headerlink" title="一、UI组件"></a>一、UI组件</h3><p>&emsp;React-Redux将所有组件分为两大类：</p><ul><li>UI组件（presentational component）</li><li>容器组件（container component）</li></ul><p>&emsp;UI组件有以下特征：</p><ul><li>1、只负责UI的呈现，不带任何业务逻辑</li><li>2、没有状态（即不适用this.state这个变量）</li><li>3、所有数据都由参数（this.props)提供</li><li>4、不使用任何Redux的API</li></ul><p>一个UI组件的例子：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> Title = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></code></pre><p>&emsp;因为不含有状态，UI组件又称为‘纯组件’，即它和纯函数一样，纯粹由参数决定它的值。</p><h3 id="二、容器组件"><a href="#二、容器组件" class="headerlink" title="二、容器组件"></a>二、容器组件</h3><p>&emsp; 容器组件的特征恰恰相反：</p><ul><li>负责管理数据和业务逻辑，不负责UI的呈现</li><li>带有内部状态</li><li>使用Redux的API</li></ul><p>&emsp;总之，UI组件负责UI的呈现，容器组件负责管理数据和逻辑。</p><p>&emsp;如果一个组件既有UI又有业务逻辑，那么应该将它拆分为下面的结构：外面是一个容器组件，里面包含一个UI组件。前者负责与外部的通信，将数据传给后者，由后者渲染出试图。</p><p>&emsp;React-Redux规定，所有的UI组件由用户提供，容器组件则由React-Redux自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。</p><h3 id="三、connect"><a href="#三、connect" class="headerlink" title="三、connect()"></a>三、connect()</h3><p>&emsp;React-Redux提供connect方法，用于从UI组件生成容器组件。（connect的意思就是将这两种组件连起来）</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;connect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span><span class="hljs-keyword">const</span> VisibleTodoList = connect()(TodoList);<span class="hljs-comment">//TodoList是UI组件，VisibleTodoList就是通过connect方法自动生成的容器组件</span></code></pre><p>&emsp;但是由于没有定义业务逻辑，上面这个容器组件没有任何意义，只是UI组件的一个单纯的包装层。为了定义业务逻辑，需要给出以下信息：</p><ul><li>（1）输入逻辑：外部的数据（即state对象）如何转换为UI组件的参数。</li><li>（2）输出逻辑：用户发出的动作如何变为Action对象，从UI组件传出去。</li></ul><p>&emsp;因此，connect方法的完整API如下：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;connect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<span class="hljs-keyword">const</span> VisibleTodoList = connect(    mapStateToProps,    mapDispatchToProps)(TodoList)</code></pre><p>&emsp;connect函数接受两个参数：mapStateToProps  和 mapDispatchToProps。它们定义了UI组件的业务逻辑：前者负责输入逻辑，即将state映射到UI组件的参数（props),后者负责输出逻辑，即将用户对UI组件的操作映射为Action对象。</p><h3 id="四、mapStateToProps"><a href="#四、mapStateToProps" class="headerlink" title="四、mapStateToProps()"></a>四、mapStateToProps()</h3><p>&emsp; mapStateToProps是一个函数，它的作用就是像它的名字那样，建立一个从（外部的）state对象到（UI组件的）props对象的映射关系。</p><p>&emsp;作为函数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。<br>例子：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> mapStateToProps=<span class="hljs-function">(<span class="hljs-params">state</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123;        <span class="hljs-comment">//todos属性，代表UI组件的同名属性</span>        <span class="hljs-comment">//getVisibleTodos可以从state算出todos的值</span>        todos: getVisibleTodos(state.todos,state.visibilityFilter)    &#125;&#125;<span class="hljs-comment">//getVisibleTodos可以从state算出todos的值</span><span class="hljs-keyword">const</span> getVisibleTodos=<span class="hljs-function">(<span class="hljs-params">todos,filter</span>)=&gt;</span>&#123;    <span class="hljs-function"><span class="hljs-title">switch</span>(<span class="hljs-params">filter</span>)</span>&#123;        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;SHOW_ALL&#x27;</span>:            <span class="hljs-keyword">return</span> todos;        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;SHOW_COMPLETED&#x27;</span>:            <span class="hljs-keyword">return</span> todos.filter(<span class="hljs-function"><span class="hljs-params">t</span>=&gt;</span>t.completed);        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;SHOW_ACTIVE&#x27;</span>:            <span class="hljs-keyword">return</span> todos.filter(<span class="hljs-function"><span class="hljs-params">t</span>=&gt;</span>!t.completed);        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Unknow filter:&#x27;</span>+filter)    &#125;&#125;</code></pre><p>&emsp;mapStateToProps 会订阅Store,每当state更新的时候，会自动执行，重新计算UI组件的参数，从而触发UI组件的重新渲染。</p><p>&emsp;mapStateToProps 的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象。</p><pre><code class="hljs js"><span class="hljs-comment">//容器组件的代码</span><span class="hljs-comment">// &lt;FilterLink filter=&#x27;SHOW_ALL&#x27;&gt;ALL&lt;/FilterLink&gt;</span><span class="hljs-keyword">const</span> mapStateToProps = <span class="hljs-function">(<span class="hljs-params">state,ownProps</span>) =&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123;        active:ownProps.filter === state.visibilityFilter    &#125;&#125;</code></pre><p> &emsp;使用ownProps作为参数后，如果容器组件的参数发生变化，也会引起UI组件重新渲染。</p><p> &emsp;connect方法可以省略mapStateToProps参数，那样的话UI组件就不会订阅Store, 也就是说Store的更新不会引起UI组件渲染。</p><h3 id="五、mapDispatchToProps"><a href="#五、mapDispatchToProps" class="headerlink" title="五、mapDispatchToProps()"></a>五、mapDispatchToProps()</h3><p> &emsp;mapDispatchToProps 是connect函数的第二个参数，用来建立UI组件的参数到Store.dispatch的映射，它定义了哪些用户的操作应该当作Action，传给Store。它可以是一个函数，也可以是一个对象。</p><p> &emsp;1、<strong>如果mapDispatchToProps是一个函数</strong>，会得到dispatch和ownProps(容器组件的props对象)两个参数。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> mapDispatchToProps = (    dispatch,    ownProps) =&gt; &#123;    <span class="hljs-keyword">return</span> &#123;        onClick:<span class="hljs-function">()=&gt;</span>&#123;            dispatch(&#123;                type:<span class="hljs-string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>,                filter:ownProps.filter            &#125;)        &#125;    &#125;&#125;</code></pre><p>&emsp;从上述代码中可以看出，mapispatchToProps作为函数，应该返回以一个对象，该对象的每个键值对都是一个映射，定义了UI组件的参数怎样发出action。</p><p>&emsp;2、<strong>如果mapDispatchToProps是一个对象</strong>，它的每个键名也是对应UI的同名参数，键值应该是一个函数，会被当作是Action Creator,返回的Action会由Redux自动发出。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> mapDispatchToProps=&#123;    onClick:<span class="hljs-function">(<span class="hljs-params">filter</span>)=&gt;</span>&#123;        type:<span class="hljs-string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>,        filter:filter    &#125;&#125;</code></pre><h3 id="六、Provider组件"><a href="#六、Provider组件" class="headerlink" title="六、Provider组件"></a>六、Provider组件</h3><p>&emsp;connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成UI组件的参数。一种解决方法是将state对象作为参数，传给容器组件。但是这样比较麻烦，尤其是容器组件在很深的层级时，一级级将state传下去就很麻烦。</p><p>&emsp;React-Redux提供Provider组件，可以让容器组件拿到state。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;Provider&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">import</span> todoApp <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducers&#x27;</span>;<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/App&#x27;</span>;<span class="hljs-keyword">let</span> store = createStore(todoApp);render(    &lt;Provider store=&#123;store&#125;&gt;        &lt;App /&gt;    &lt;/Provider&gt;,    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>))</code></pre><p>&emsp;Provider 在根组件外面包了一层，这样一来，App的所有子组件默认都可以拿到state了。Provider的原理时React组件的context属性。<br>源码：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Provider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">getChildContext</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> &#123;            store:<span class="hljs-built_in">this</span>.props.store        &#125;    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.props.children;    &#125;&#125;Provider.childContextTypes = &#123;    store:React.PropTypes.object&#125;</code></pre><p>&emsp;上面代码中，store放在了上下文对象context上面。然后，子组件就可以从context拿到store。代码如下：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VisibleTodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">const</span> &#123;store&#125; = <span class="hljs-built_in">this</span>.context;        <span class="hljs-built_in">this</span>.unsubscribe=store.subscribe(<span class="hljs-function">()=&gt;</span>            <span class="hljs-built_in">this</span>.forceUpdate()        );    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">const</span> props=<span class="hljs-built_in">this</span>.props;        <span class="hljs-keyword">const</span> &#123;store&#125;=<span class="hljs-built_in">this</span>.context;        <span class="hljs-keyword">const</span> state=store.getState();        <span class="hljs-comment">//...</span>    &#125;&#125;VisibleTodoList.contextTypes = &#123;    store:React.PropTypes.object&#125;</code></pre><p>React-Redux 自动生成的容器组件的代码就是类似于上面这样，拿到store。</p><h3 id="七、React-Router-路由库"><a href="#七、React-Router-路由库" class="headerlink" title="七、React-Router 路由库"></a>七、React-Router 路由库</h3><p>&emsp;使用React-Router的项目，与其他项目没有不同之处，也是使用Provider在Router外面包一层。毕竟Provider的唯一功能就是传入store对象。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> Root = <span class="hljs-function">(<span class="hljs-params">&#123;store&#125;</span>) =&gt;</span> (    &lt;Provider store=&#123;store&#125;&gt;        &lt;Router&gt;            &lt;Route path=<span class="hljs-string">&quot;/&quot;</span> component=&#123;App&#125; /&gt;        &lt;/Router&gt;    &lt;/Provider&gt;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11-redux之中间件与异步操作</title>
    <link href="/2020/11/16/11-redux%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/11/16/11-redux%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>第10篇文章里，介绍了redux的基本做法：用户发出Action, Reducer函数算出新的State，View重新渲染。<br><img src="https://pic.downk.cc/item/5fb26119b18d627113c52bcf.jpg"><br>但是异步操作应该怎么处理呢？Action发出以后，Reducer立即算出新的State, 这就叫做同步；Action发出后，过一段时间再执行Reducer,这就叫做异步。<br>怎么才能让reducer在异步操作结束后自动执行呢？这就要用到新的工具： <strong>中间件</strong>（middleware）<br><img src="https://pic.downk.cc/item/5fb27135b18d627113c87d35.jpg"></p><h3 id="一、中间件的概念"><a href="#一、中间件的概念" class="headerlink" title="一、中间件的概念"></a>一、中间件的概念</h3><p>为了让redux可以进行异步操作，势必要在redux工作流程中添加新的功能。那么在哪个环节添加合适呢？</p><p>（1）Reducer: 纯函数，只能承担计算State的功能，不适合承担其他功能，也承担不了。因为理论上，纯函数不能进行读写的操作。</p><p>（2）View: 与State一一对应，可以看作是State的视觉层，也不合适承担其他功能。</p><p>（3）Action: 存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。</p><p>想来想去，只有发送Action的这个步骤，即Store.dispatch()这个方法，可以添加功能。<br>中间件就是一个函数，对store.dispatch方法进行了改造，在发出Action和执行Reducer这两步之间，添加了其他功能。</p><h3 id="二、中间件的使用"><a href="#二、中间件的使用" class="headerlink" title="二、中间件的使用"></a>二、中间件的使用</h3><p>常用的中间件都是现成的，只有引用别人写好的模块就行。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; applyMiddleware,createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">import</span> createLogger <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-logger&#x27;</span>;<span class="hljs-keyword">const</span> logger = createLogger();<span class="hljs-keyword">const</span> store = createStore(    reducer,    initialState, <span class="hljs-comment">//整个应用的初始状态</span>    applyMiddleware(logger))</code></pre><p>🐖：中间件的次序有讲究。有的中间件有次序要求，比如logger就一定放在最后，否则输出结果会不正确。使用前要查阅相关文档</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = createStore(    reducer,    appltMiddleware(thunk,promise,logger)    <span class="hljs-comment">//这里是用了三个中间件</span>)</code></pre><p>==applyMiddlewares()：== applyMiddlewares是Redux的原生方法，作用是将所有中间件组成一个数组，依次执行。</p><h3 id="三、异步操作的基本思路"><a href="#三、异步操作的基本思路" class="headerlink" title="三、异步操作的基本思路"></a>三、异步操作的基本思路</h3><p>同步操作只要发出一种Action即可，异步操作的差别是它要发出三种Action:</p><ul><li>操作发起时的Action</li><li>操作成功时的Action</li><li>操作失败时的Action</li></ul><p>以服务器取出数据为例，三种Action可以有两种写法：</p><pre><code class="hljs js"><span class="hljs-comment">//写法一：名称相同，参数不同</span>&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;FETCH_POSTS&#x27;</span>&#125;&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;FETCH_POSTS&#x27;</span>,<span class="hljs-attr">status</span>:<span class="hljs-string">&#x27;error&#x27;</span>,<span class="hljs-attr">error</span>:<span class="hljs-string">&#x27;OoPS&#x27;</span>&#125;&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;FETCH_POSTS&#x27;</span>,<span class="hljs-attr">status</span>:<span class="hljs-string">&#x27;success&#x27;</span>,<span class="hljs-attr">response</span>:&#123;...&#125; &#125;<span class="hljs-comment">//写法二：名称不同</span>&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;FETCH_POSTS_REQUEST&#x27;</span>&#125;&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;FETCH_POSTS_FAILURE&#x27;</span>,<span class="hljs-attr">error</span>:<span class="hljs-string">&#x27;Oops&#x27;</span>&#125;&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;FETCH_POSTS_SUCCESS&#x27;</span>,<span class="hljs-attr">response</span>:&#123;...&#125;&#125;</code></pre><p>除了Action种类不同，异步操作的State也要进行改造，反映不同的操作状态。<br>例子：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> state=&#123;    <span class="hljs-comment">//...</span>    isFetching:<span class="hljs-literal">true</span>, <span class="hljs-comment">//是否正在抓取数据</span>    didInvalidate:<span class="hljs-literal">true</span>,<span class="hljs-comment">//是否超时</span>    lastUpdated:<span class="hljs-string">&#x27;xxxx&#x27;</span><span class="hljs-comment">//上一次更新时间</span>&#125;</code></pre><p>现在，整个异步操作的思路就比较清晰了</p><ul><li>1.操作开始时，发送一个Action,触发State 更新为“正在操作”状态，View重新渲染</li><li>2.操作结束后，再送出一个Action,触发State 更新为“操作结束”状态，View再次重新渲染。</li></ul><h3 id="四、redux-thunk中间件"><a href="#四、redux-thunk中间件" class="headerlink" title="四、redux-thunk中间件"></a>四、redux-thunk中间件</h3><p>异步操作至少要发两个Action：用户触发第一个Action,这个跟同步操作一样没有问题，但是，如何才能再操作结束时，系统自动送出第二个Action呢？</p><p>这个奥妙在于Action Creator之中。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;    <span class="hljs-comment">//加载成功后，</span>    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">const</span> &#123;dispatch,selectedPost&#125;=<span class="hljs-built_in">this</span>.props;        <span class="hljs-comment">//发送一个Action,向服务器要数据</span>        <span class="hljs-comment">//这里的fetchPosts()函数就是Action Creator</span>        dispatch(fetchPosts(selectedPost));    &#125;&#125;</code></pre><p>下面就是fetchPosts的代码</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> fetchPosts = <span class="hljs-function"><span class="hljs-params">postTitle</span> =&gt;</span><span class="hljs-function">(<span class="hljs-params">dispatch,getState</span>)=&gt;</span>&#123;    <span class="hljs-comment">//1.先发出一个Action</span>    dispatch(requestPosts(postTitle));    <span class="hljs-comment">//2.进行异步操作</span>    <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">&#x27;/some/API/$&#123;postTitle&#125;.json&#x27;</span>)        <span class="hljs-comment">//3.拿到结果，将结果转换为JSON格式</span>        .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())        <span class="hljs-comment">//4.再发出一个Action</span>        .then(<span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> dispatch(receivePosts(postTitle,json)))&#125;</code></pre><p>🐖：</p><ul><li>fetchPosts 返回了一个函数，而普通的Action Creator返回一个Action对象</li><li>fetchPosts 返回的函数入参时dispatch和getState这两个redux方法，普通的Action Creator的参数是Action的内容。</li><li>在返回的函数中，先发出一个Action（requestPosts(postTitle)），表示操作开始</li><li>异步操作结束之后，又发出一个Action（receivePosts(postTitle,json)），表示操作结束。</li></ul><p>这样的处理，解决了异步操作中需要自动发出第二个Action的问题，但是，Action是由store.dispatch方法发出的，而这个方法正常情况下，入参只能是对象而不能是函数。<br>====&gt; 这时，就需要中间件redux-think</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>;<span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducers&#x27;</span>;<span class="hljs-comment">// Note: this API requires redux@&gt;=3.1.0</span><span class="hljs-keyword">const</span> store = createStore(  reducer,  applyMiddleware(thunk));</code></pre><p>上面代码使用redux-thunk,改造store.dispatch,使得后者可以接受函数作为参数。</p><p>因此，异步操作的第一个解决方案：写一个返回函数的Action Creator,然后使用redux-thunk 中间件改造store.dispatch.</p><h3 id="五、redux-promise中间件"><a href="#五、redux-promise中间件" class="headerlink" title="五、redux-promise中间件"></a>五、redux-promise中间件</h3><p>&emsp;既然Action Creator 可以返回函数，当然也可返回其他值。所以另一种异步操作的解决方案就是，让Action Creator返回一个Promise对象.</p><p>&emsp;这就需要使用redux-promise中间件。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createStore,applyMiddleware&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">import</span> promiseMiddleware <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-promise&#x27;</span>;<span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducers&#x27;</span>;<span class="hljs-comment">//这时Action Creator有两种写法，</span><span class="hljs-comment">//1.返回值是一个对象</span><span class="hljs-keyword">const</span> fetchPosts=<span class="hljs-function">(<span class="hljs-params">dispatch,postTitle</span>)=&gt;</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;    dispatch(requestPosts(postTitle));    <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">&#x27;/some/API/$&#123;postTitle&#125;.json)</span><span class="hljs-string">        .then(response=&gt;&#123;</span><span class="hljs-string">            type:&#x27;</span>FETCH_POSTS<span class="hljs-string">&#x27;,</span><span class="hljs-string">            payload:response.json()</span><span class="hljs-string">        &#125;)</span><span class="hljs-string">&#125;)</span><span class="hljs-string"></span><span class="hljs-string">//2.Action对象的payload属性是一个Promise对象，</span><span class="hljs-string">// 这时需要从redux-actions模块引入createAction方法</span></code></pre><p>参考文章：<a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html">阮一峰redux教程</a></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>010-状态管理库Redux</title>
    <link href="/2020/11/16/010-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93Redux/"/>
    <url>/2020/11/16/010-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93Redux/</url>
    
    <content type="html"><![CDATA[<h3 id="一、React为何需要状态管理库"><a href="#一、React为何需要状态管理库" class="headerlink" title="一、React为何需要状态管理库"></a>一、React为何需要状态管理库</h3><p><img src="https://i.bmp.ovh/imgs/2020/11/26a4726bd6216f11.png"></p><p><img src="https://i.bmp.ovh/imgs/2020/11/8ed5fe88ed497e9c.png"><br>组件之间通信非常麻烦，有了redux把状态单独拧出来，组件通信就变得简单了。</p><p>Redux的特性：</p><ul><li><strong>1、Single Source of Truth</strong></li></ul><p>&emsp;传统的MVC架构：一个view可能对应多个model,一个model也可能对应多个view,关系错综复杂，这样一旦出现错误很难追踪。<br><img src="https://i.bmp.ovh/imgs/2020/11/5a9cb384b94cc272.png"></p><p>&emsp;Redux的结构：只有一个Store,出现错误容易追踪。</p><p><img src="https://i.bmp.ovh/imgs/2020/11/fbb96f01a9c20437.png"></p><ul><li><p><strong>2、可预测性</strong> （不可变性immutable）</p><p><img src="https://i.bmp.ovh/imgs/2020/11/4753506caf528c03.png"></p></li><li><p><strong>3、纯函数更新State</strong></p></li></ul><p>&emsp;&emsp;redux没有副作用.<br><img src="https://i.bmp.ovh/imgs/2020/11/17c05a6f634a7eaf.png"></p><h3 id="二、理解Redux的核心概念：Store-Action-Reducer"><a href="#二、理解Redux的核心概念：Store-Action-Reducer" class="headerlink" title="二、理解Redux的核心概念：Store, Action,Reducer"></a>二、理解Redux的核心概念：Store, Action,Reducer</h3><p><strong>1.理解Store:</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/bc6be7d1bc1deaf2.png"></p><p>Store就是保存数据的地方，可以把它看作是一个容器。整个应用只能有一个Store。<br>Redux提供<strong>createStore</strong>这个函数，用来生成Store。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-comment">//createStore接受一个函数，返回新生成的store对象。</span><span class="hljs-keyword">const</span> store = createStore(fn);</code></pre><p><strong>==State:==</strong> &emsp;Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照。这种时点的数据集合，就叫做State。<br>当前时刻的State,可以通过 store.getState() 拿到。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">const</span> store = createStore(fn);<span class="hljs-keyword">const</span> state = store.getState();</code></pre><p>redux规定，<strong>一个state对应一个view</strong>。只要state相同，view就相同。知道了State,就知道了View是什么样，反之亦然。</p><p><strong>2.理解Action:</strong></p><p>&emsp;State的变化，会导致view的变化。但是，用户接触不到State,只能接触到view。所以，State的变化必须是view导致的。Action就是view发出的通知，标识State应该要变化了。</p><p>&emsp;Action是一个对象，其中的type属性是必须的，标识Action的名称。其他属性可以自由设置。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> action = &#123;  type:<span class="hljs-string">&#x27;ADD_TODO&#x27;</span>,  payload:<span class="hljs-string">&#x27;learn redux&#x27;</span>&#125;</code></pre><p>上述代码中，Action的名称是ADD_TODO，它携带的信息是字符串 learn redux.</p><p>可以这么理解，Action描述当前发生的事情。改变State的唯一方法，就是使用Action。它会运送数据给Store。</p><p><strong>Action Creator:</strong><br>View要发生多少种消息，就会有多少种Action.如果都手写，会很麻烦。所以，可以定义一个函数用来生成Action,这个函数就叫 Action Creator</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> ADD_TODO = <span class="hljs-string">&#x27;添加TODO&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTodo</span>(<span class="hljs-params">text</span>)</span>&#123;  <span class="hljs-keyword">return</span> &#123;    type:ADD_TODO,    text  &#125;&#125;<span class="hljs-keyword">const</span> action=addTodo(<span class="hljs-string">&#x27;learn redux&#x27;</span>)<span class="hljs-string">``</span><span class="hljs-string">` </span><span class="hljs-string">上面代码中，addTodo函数就是一个Action Creator</span><span class="hljs-string"></span><span class="hljs-string">**store.dispatch():**</span><span class="hljs-string">store.dispatch()是View发出Action的唯一方法。</span><span class="hljs-string">`</span><span class="hljs-string">``</span>js<span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">const</span> store = createStore(fn);store.dispatch(&#123;  type:<span class="hljs-string">&#x27;ADD_TODO&#x27;</span>,  payload:<span class="hljs-string">&#x27;learn redux&#x27;</span>&#125;)</code></pre><p>结合 Action Crreator,这段代码可以改写如下：</p><pre><code class="hljs js">store.dispatch(addTodo(<span class="hljs-string">&#x27;learn redux&#x27;</span>));</code></pre><p><strong>3.理解Reducer：</strong></p><p>Store在收到Action之后，必须给出一个新的State,这样View才会发生变化。这种State的计算过程，就叫做 Reducer。</p><p>Reducer是一个函数，它接受Action和当前的State,返回一个新的State。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> reducer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">state,action</span>)</span>&#123;  <span class="hljs-comment">//...</span>  <span class="hljs-keyword">return</span> new_state;&#125;</code></pre><p>整个应用的初始状态，可以作为State的默认值，下面就是一个实际的例子。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> defaultState=<span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> reducer = <span class="hljs-function">(<span class="hljs-params">state=defaultState,action</span>)=&gt;</span>&#123;  <span class="hljs-function"><span class="hljs-title">switch</span>(<span class="hljs-params">action.type</span>)</span>&#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD&#x27;</span>:      <span class="hljs-keyword">return</span> state + action.payload;    <span class="hljs-keyword">default</span>:      <span class="hljs-keyword">return</span> state;  &#125;&#125;;<span class="hljs-keyword">const</span> state=reducer(<span class="hljs-number">1</span>,&#123;  type:<span class="hljs-string">&#x27;ADD&#x27;</span>,  payload:<span class="hljs-number">2</span>&#125;)</code></pre><p>上面代码中，reducer函数接收到一个名为ADD的action以后，就返回一个新的State。<br>实际应用中，Reducer不需要像上面这样手动调用，store.dispatch方法会触发reducer的自动执行。为此，Store需要知道reducer函数，做法就是在生成Store的时候，就将reducer传入给createStore方法。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">const</span> store = createStore(reducer);<span class="hljs-comment">//以后每当store.dispatch发送过来一个新的Action,</span><span class="hljs-comment">//就会自动调用Reducer，得到新的State</span></code></pre><p>🐖为什么这个函数被叫做Reducer呢？<br>✨因为它可以作为数组的reduce方法的参数，下面是一个例子，一系列的Action对象按照顺序作为一个数组。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> actions = [  &#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;ADD&#x27;</span>,<span class="hljs-attr">payload</span>:<span class="hljs-number">0</span>&#125;,  &#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;ADD&#x27;</span>,<span class="hljs-attr">payload</span>:<span class="hljs-number">1</span>&#125;,  &#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;ADD&#x27;</span>,<span class="hljs-attr">payload</span>:<span class="hljs-number">2</span>&#125;];<span class="hljs-keyword">const</span> total = actions.reduce(reducer,<span class="hljs-number">0</span>)<span class="hljs-comment">//3</span></code></pre><p>上面代码中，数组actions表示依次有三个 Action，分别是加0、加1和加2。数组的reduce方法接受 Reducer 函数作为参数，就可以直接得到最终的状态3。 </p><p><img src="https://i.bmp.ovh/imgs/2020/11/43ed9499a953d590.png"></p><p><strong>Reducer函数最重要的特征是:它是一个纯函数。</strong><br>==纯函数==： 纯函数是函数式编程的概念，必须遵守以下一些约束。</p><ul><li>不得改写参数</li><li>不能调用系统 I/O的API</li><li>不能调用Date.now()或者Math.random等不纯的方法，因为每次都会得到不一样的结果。</li></ul><p>由于Reducer是纯函数，就可以保证同样的State必定得到同样的View。但也正因为这一点，Reducer函数里面不能改变State，必须返回一个全新的对象。所以，一般常采用 拓展运算符…和Object.assign()对state进行更新。(最好把State对象设为只读)</p><pre><code class="hljs js"><span class="hljs-comment">//1.state是一个对象</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state,action</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign(&#123;&#125;,state,&#123;thingTochange&#125;);  <span class="hljs-comment">//或者</span>  <span class="hljs-keyword">return</span> &#123;...state,...newState&#125;;&#125;<span class="hljs-comment">//2.state是一个数组</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state,action</span>)</span>&#123;  <span class="hljs-keyword">return</span> [...state,newItem]&#125;</code></pre><p>下图综合理解这三个概念，可以看出redux的单向数据流动。<br><img src="https://i.bmp.ovh/imgs/2020/11/9fceb4adcb97b639.png"></p><h3 id="三、redux的几个工具函数"><a href="#三、redux的几个工具函数" class="headerlink" title="三、redux的几个工具函数"></a>三、redux的几个工具函数</h3><p><strong>1.combineReducers:</strong></p><p>将多个reducer结合起来形成新的reducer。</p><p><img src="https://pic.downk.cc/item/5fb1ddf2b18d627113a841a0.jpg"></p><p><strong>2.bindActionCreators:</strong></p><p><img src="https://pic.downk.cc/item/5fb1de1eb18d627113a848fb.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1de6fb18d627113a8563c.jpg"></p><h3 id="四、在React中使用Redux"><a href="#四、在React中使用Redux" class="headerlink" title="四、在React中使用Redux"></a>四、在React中使用Redux</h3><p>redux提供了一个<strong>react-redux</strong>的package，用connect把一个已有的组件连接到store上。</p><p><img src="https://pic.downk.cc/item/5fb1e29cb18d627113a9146f.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1e356b18d627113a93618.jpg"></p><h3 id="五、理解Redux的异步action以及中间件"><a href="#五、理解Redux的异步action以及中间件" class="headerlink" title="五、理解Redux的异步action以及中间件"></a>五、理解Redux的异步action以及中间件</h3><p>中间件截获后去访问一个API，根据访问的结果再dispatch.</p><p><img src="https://pic.downk.cc/item/5fb1eab2b18d627113aabab1.jpg"></p><p>异步的action并不是一个新的action类型, 而是几个同步action的组合使用.</p><p><img src="https://pic.downk.cc/item/5fb1eb4eb18d627113aae915.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1ecf0b18d627113ab5f8a.jpg"></p><h3 id="六、如何在redux中组织Action和Reducer"><a href="#六、如何在redux中组织Action和Reducer" class="headerlink" title="六、如何在redux中组织Action和Reducer"></a>六、如何在redux中组织Action和Reducer</h3><p><img src="https://pic.downk.cc/item/5fb1ede4b18d627113ab90f7.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1ee82b18d627113abad69.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1eec1b18d627113abb8da.jpg"></p><h3 id="七、-Redux的运行基础-不可变数据-immutability"><a href="#七、-Redux的运行基础-不可变数据-immutability" class="headerlink" title="七、 Redux的运行基础:不可变数据(immutability)"></a>七、 Redux的运行基础:不可变数据(immutability)</h3><p><img src="https://pic.downk.cc/item/5fb1efbcb18d627113abe8a3.jpg"></p><h5 id="1-为什么需要不可变数据"><a href="#1-为什么需要不可变数据" class="headerlink" title="1.为什么需要不可变数据?"></a>1.为什么需要不可变数据?</h5><ul><li><p><strong>1.性能优化:</strong><br> &emsp;store变化时会通知组件更新==&gt; store的变化都是由action触发==&gt;action触发在旧的state上形成新的state。不需要比较新旧state值是否变了,只需要判断<strong>前后状态的引用</strong>有没有变化</p></li><li><p><strong>2.易于调试和跟踪:</strong><br>任何时候，store变化时可以记录之前和之后的状态值。</p></li><li><p><strong>3.易于推测:</strong><br>任何时候，都可以找到是什么引起store的变化</p><h5 id="2-如何操作不可变数据"><a href="#2-如何操作不可变数据" class="headerlink" title="2.如何操作不可变数据?"></a>2.如何操作不可变数据?</h5></li></ul><p>==三种方式:==<br><img src="https://pic.downk.cc/item/5fb1f0f2b18d627113ac3540.jpg"></p><p>简单场景：使用原生写法就可以了。</p><p><img src="https://pic.downk.cc/item/5fb1f37cb18d627113acb0d5.jpg"></p><p>复杂场景：需要借助一些类库。</p><p><img src="https://pic.downk.cc/item/5fb1f414b18d627113accfd2.jpg"></p><p>immer: 性能差一点，适用应用程序小，场景简单的情况。<br><img src="https://pic.downk.cc/item/5fb1f44fb18d627113acdf4d.jpg"></p><h3 id="八、梳理Redux的工作流程"><a href="#八、梳理Redux的工作流程" class="headerlink" title="八、梳理Redux的工作流程"></a>八、梳理Redux的工作流程</h3><p><img src="https://pic.downk.cc/item/5fb26119b18d627113c52bcf.jpg"></p><p>1.首先，用户发出Action。</p><pre><code class="hljs js">store.dispatch(action)</code></pre><p>2.然后，Store自动调用Reducer,并且传入两个参数：当前State和收到的Action。Reducer会返回新的State</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> nextState = todoApp(previousState,action);</code></pre><p>State一旦有变化，Store就会调用监听函数</p><pre><code class="hljs js"><span class="hljs-comment">//设置监听函数</span>store.subscribe(listener);</code></pre><p>listener可以通过store.getState()得到当前状态，如果使用的是React,这时可以触发重新渲染View。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listener</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">let</span> newState = store.getState();  component.setState(newState);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09-打包和部署</title>
    <link href="/2020/11/12/09-%E6%89%93%E5%8C%85%E5%92%8C%E9%83%A8%E7%BD%B2/"/>
    <url>/2020/11/12/09-%E6%89%93%E5%8C%85%E5%92%8C%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h4 id="一-为什么需要打包"><a href="#一-为什么需要打包" class="headerlink" title="一.为什么需要打包?"></a>一.为什么需要打包?</h4><ul><li>1.编译ES6语法特性，编译JSX</li><li>2.整合资源，例如图片svg,Less/Sass</li><li>3.优化代码体积</li></ul><p><img src="https://i.bmp.ovh/imgs/2020/11/ef5409f73d9ca563.png"></p><h4 id="二-打包注意事项"><a href="#二-打包注意事项" class="headerlink" title="二.打包注意事项:"></a>二.打包注意事项:</h4><p>1.设置node.js环境为production<br>2.禁止开发时专用代码，比如logger<br>3.设置应用根路径</p><p>npm run build 执行的就是打包过程。</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-使用脚手架工具创建React项目</title>
    <link href="/2020/11/12/08-%E4%BD%BF%E7%94%A8%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E5%88%9B%E5%BB%BAReact%E9%A1%B9%E7%9B%AE/"/>
    <url>/2020/11/12/08-%E4%BD%BF%E7%94%A8%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E5%88%9B%E5%BB%BAReact%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="1-为什么需要脚手架？"><a href="#1-为什么需要脚手架？" class="headerlink" title="1.为什么需要脚手架？"></a>1.为什么需要脚手架？</h3><p><img src="https://i.bmp.ovh/imgs/2020/11/1df974a0ce1a7435.png"><br>项目越来越复杂，需要用：</p><ul><li><p>react: 做UI，</p></li><li><p>redux: 做状态管理，</p></li><li><p>react-router: 做路由管理</p></li><li><p>babel: 把js新特性翻译为浏览器可以识别的旧语法</p></li><li><p>webpack: 打包</p></li><li><p>eslint: 用于语法检查<br>…<br><img src="https://i.bmp.ovh/imgs/2020/11/611411d14c00f1a4.png"></p><p>&emsp;这些工具背后需要很多的package,我们需要了解每一个package的配置和使用，这使得创建项目非常繁琐。而创建一个项目的过程大致是差不多的，完全可以抽象出来做成一个工具<br>&emsp;===&gt;所以，脚手架应运而生。</p></li></ul><h3 id="2-常见的用于创建React应用的脚手架工具："><a href="#2-常见的用于创建React应用的脚手架工具：" class="headerlink" title="2.常见的用于创建React应用的脚手架工具："></a>2.常见的用于创建React应用的脚手架工具：</h3><ul><li><p><strong>Create React APP</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/6a1c377349d0f209.png"><br>&emsp; facebook 官方推出的，使用了最简策略，用于学习或创建简单的react项目</p></li><li><p><strong>Rekit</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/57aaa6b41498f44a.png"></p><p>&emsp;基于create-react-app,提供了更多的功能，可以开发大型的项目。</p></li><li><p><strong>Codesandbox</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/c18cd49b5e89621e.png"><br>&emsp; Online,在线的创建项目，webpack运行在浏览器端,大大提高打包速度。支持react,vue,angular</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-理解新的ContextAPI及其使用场景</title>
    <link href="/2020/11/11/07-%E7%90%86%E8%A7%A3%E6%96%B0%E7%9A%84ContextAPI%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2020/11/11/07-%E7%90%86%E8%A7%A3%E6%96%B0%E7%9A%84ContextAPI%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>Context解决的是：组件之间的通信问题</strong></p><p>Context提供了一个无需为每层组件手动添加props,就能在组件树间进行数据传递的方法。</p><p><img src="https://i.bmp.ovh/imgs/2020/11/c51c0b02a804b0fb.png"></p><h4 id="1-设计目的"><a href="#1-设计目的" class="headerlink" title="1.设计目的"></a>1.设计目的</h4><p>&emsp;Context设计的目的：为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或者首选语言。<br>&emsp;在一个典型的React应用中，数据是通过props属性自上而下（由父亲到儿子）进行传递的，但是这种做法对于某些属性是及其繁琐的（比如上文说的UI主题，），这些属性是应用程序中许多组件都需要的。</p><p><strong>==&gt;</strong> 所以，Context被设计出来，提供了一种在组件间共享“全局”数据的方式，从而不必显示地通过组件树逐层地传递props.</p><h4 id="2-使用Context前的考虑"><a href="#2-使用Context前的考虑" class="headerlink" title="2.使用Context前的考虑"></a>2.使用Context前的考虑</h4><p><strong>Context主要应用场景</strong>：很多不同层级之间的组件需要访问同样的一些数据。(但是需要谨慎使用，因为这会让组件的复用性变差。)<br>如果只是想避免层层传递一些属性，<a href="https://zh-hans.reactjs.org/docs/composition-vs-inheritance.html">组件组合（component composition）</a>有时是一个比Context更好的解决方案。</p><h4 id="3-相关的API"><a href="#3-相关的API" class="headerlink" title="3.相关的API"></a>3.相关的API</h4><p> <strong><em>(1) React.createContext</em></strong><br>  <pre><code class="hljs js"><span class="hljs-keyword">const</span> MyContext = React.createContext(defaultValue);</code></pre></p><ul><li>createContext函数创建一个Context对象，当React渲染一个订阅了这个Context对象的组件时，这个组件会从组件树中离自身最近的匹配到的Provider中读取当前的context值。<br>…</li><li><em>defaultValue</em>: 只有当组件所处的组件树中没有匹配到Provider时，其defaultValue参数才起作用。即使Provider中的value值是”undefined”，消费组件的defaultValue也不会生效。<br>（defaultValue有助于在不使用Provider包装组件的情况下，对组件进行测试）</li></ul><p><strong><em>(2)Context.Provider</em></strong></p><pre><code class="hljs js">&lt;MyContext.Provider value=&#123;<span class="hljs-comment">/*某个值*/</span>&#125;&gt;</code></pre><ul><li><p>每个Context对象都会返回一个Provider React组件，它允许消费组件订阅context的变化。</p></li><li><p>一个Provider可以和多个消费组件有对应关系。多个Provider也可以嵌套使用，里面的会覆盖外层的数据。</p></li><li><p>Provider有一个value属性，传递给消费组件。当value值发生变化时，Provider内部的所有消费组件都会重新渲染。<br>（Provider及其内部的消费组件都不受制于shouldComponentUpdate函数，所以当消费组件在其祖先组件推出更新的情况下也能更新）</p></li><li><p>通过新旧值检测确定变化，使用了和 Object.is相同的算法。</p></li></ul><p><strong><em>(3) Class.contextType</em></strong></p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">this</span>.context;    <span class="hljs-comment">/* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */</span>  &#125;  <span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">this</span>.context;    <span class="hljs-comment">/* ... */</span>  &#125;  <span class="hljs-function"><span class="hljs-title">componentWillUnmount</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">this</span>.context;    <span class="hljs-comment">/* ... */</span>  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">this</span>.context;    <span class="hljs-comment">/* 基于 MyContext 组件的值进行渲染 */</span>  &#125;&#125;MyClass.contextType = MyContext;</code></pre><ul><li>挂载在class上的contextType属性会被重新赋值为一个由React.createContext()创建的Context对象。所以使用this.context可以消费最近Context上的那个值，我们可以任何生命周期访问到this.context，包括render函数。</li><li>通过class.contextType只能订阅一个context</li></ul><p><strong><em>(4) Context.Consumer</em></strong></p><pre><code class="hljs js">&lt;MyContext.Consumer&gt;    &#123;<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span><span class="hljs-comment">/*基于context值进行渲染*/</span>&#125;&lt;/MyContext.Consumer&gt;</code></pre><ul><li><p>这是一个可以订阅context的变更的React组件，它在函数式组件中可以订阅一个context。</p></li><li><p>这种方法需要一个<a href="https://zh-hans.reactjs.org/docs/render-props.html#using-props-other-than-render">函数作为子元素（function as a child)</a>,这个函数接收当前的context值，并返回一个React节点。</p></li><li><p> 传递给Consumer的value值也就是组件树上方离context最近的Provider提供的value值，如果没有对应的Provider,就用createContext()中的defaultValue.</p></li></ul><p><strong><em>(5) Context.displayName</em></strong></p><p>示例，下述组件在DevTools中将是显示MyDisplayName:</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> MyContext = React.createContext(<span class="hljs-comment">/*some value*/</span>);MyContext.displayName = <span class="hljs-string">&#x27;MyDisplayName&#x27;</span>;&lt;MyContext.Provider&gt; <span class="hljs-comment">// &quot;MyDisplayName.Provider&quot; 在 DevTools 中</span>&lt;MyContext.Consumer&gt; <span class="hljs-comment">// &quot;MyDisplayName.Consumer&quot; 在 DevTools 中</span></code></pre><ul><li>context对象接受一个名为displayName的属性，类型为字符串。React DevTools使用该字符串来确定context要显示的内容。</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-两种组件设计模式</title>
    <link href="/2020/11/11/06-%E4%B8%A4%E7%A7%8D%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/11/11/06-%E4%B8%A4%E7%A7%8D%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="组件复用的另外两种形式："><a href="#组件复用的另外两种形式：" class="headerlink" title="组件复用的另外两种形式："></a>组件复用的另外两种形式：</h4><p>（除了常规的组件复用之外）</p><ul><li><strong>高阶组件</strong></li><li><strong>函数作为子组件</strong></li></ul><h4 id="一-高阶组件"><a href="#一-高阶组件" class="headerlink" title="一.高阶组件"></a>一.高阶组件</h4><p><img src="https://i.bmp.ovh/imgs/2020/11/f50691752374e779.png"></p><p><strong>高阶组件(HOC)</strong> 是React中复用组件逻辑的一种高级技巧，它本身不是React API的一部分，而是基于React的组合特性形成的一种设计模式。高阶组件以组件为参数，并返回一个新组件。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponenent)</code></pre><p>==区分:== &emsp;组件是将props转换为UI，高阶组件是将组件转换为另一个组件。</p><p>具体参见：<a href="https://zh-hans.reactjs.org/docs/higher-order-components.html">React官方文档–高阶组件</a></p><h4 id="二-函数作为子组件"><a href="#二-函数作为子组件" class="headerlink" title="二.函数作为子组件"></a>二.函数作为子组件</h4><p><img src="https://i.bmp.ovh/imgs/2020/11/17246cbcf6e05f4d.png"></p><p><strong>总结：</strong></p><p>1、高阶组件和函数作为子组件都是设计模式（并不是新的组件类型）</p><p>2、可以实现更多场景的组件复用</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-理解VirtualDOM及key属性的作用</title>
    <link href="/2020/11/11/05-%E7%90%86%E8%A7%A3VirtualDOM%E5%8F%8Akey%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2020/11/11/05-%E7%90%86%E8%A7%A3VirtualDOM%E5%8F%8Akey%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>JSX的基础：虚拟DOM</p><p><img src="https://i.bmp.ovh/imgs/2020/11/6244a9607b4da0d0.png"></p><p><img src="https://i.bmp.ovh/imgs/2020/11/314414dd61ae46e0.png"></p><p>从根节点开始比较，针对不同情况，diff算法有不同的处理方式：</p><p><strong>1. 属性变化及顺序：</strong><br>   <img src="https://i.bmp.ovh/imgs/2020/11/231a0e379e4ef3a4.png"></p><p>==处理方式==：根据key属性，交换A与B的位置</p><p><strong>2. 节点类型发生变化：</strong><br>   <img src="https://i.bmp.ovh/imgs/2020/11/c65c14d031817b7e.png"></p><p>==处理方式==：暴力删除F节点（不管他是否在其他地方用到），创建一个新的G节点，append到A节点上。</p><p><strong>3. 节点跨层级移动：</strong><br>    <img src="https://i.bmp.ovh/imgs/2020/11/06f09ef16c9da001.png"></p><p>==处理方式==：diff算法直接删除左边B下面的D节点（以及其子树），到了右边，React直接创建一个新的D节点。</p><h4 id="虚拟DOM的两个假设："><a href="#虚拟DOM的两个假设：" class="headerlink" title="虚拟DOM的两个假设："></a>虚拟DOM的两个假设：</h4><p><strong>1、组件的DOM结构是相对稳定的（一般很少出现跨层级移动的情况）</strong></p><p>&emsp;&emsp;跨层级的节点移动，react的diff算法是直接删除。</p><p><strong>2、类型相同的兄弟节点可以被唯一标识（key属性）。</strong></p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>算法复杂度为O(n)</li><li>虚拟DOM如何计算diff</li><li>key属性的作用</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-react的生命周期</title>
    <link href="/2020/11/10/04-react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2020/11/10/04-react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="React的生命周期图"><a href="#React的生命周期图" class="headerlink" title="React的生命周期图"></a>React的生命周期图</h3><p><img src="https://i.bmp.ovh/imgs/2020/11/32b8163f9eadfd47.png"></p><p>🐖：mounting到底意味着什么？<br>答： When we talk about mounting， we’re talking about the process of converting the virtual components into actual DOM elements that are placed in the DOM by React.（其实就是React将虚拟DOM转化为真实DOM的过程)</p><p><strong>1.constructor:</strong></p><ul><li>用于初始化内部状态，很少使用</li><li>唯一可以直接修改state的地方</li></ul><p><strong>2.getDerivedStateFromProps:</strong></p><ul><li>当state需要从props初始化时使用。</li><li>尽量不要使用：维护两者状态一致性会增加复杂度。</li><li>每次render都会调用。</li><li>典型场景：表单控件获取默认值。</li></ul><p><strong>3.componentDidMount:</strong></p><ul><li>UI渲染完成后调用</li><li>只执行一次</li><li>典型场景：获取外部资源</li></ul><p><strong>4.componeWillUnmout:</strong></p><ul><li>组件移除时被调用</li><li>典型场景：资源释放</li></ul><p><strong>5.getSnapshotBeforeUpdate:</strong></p><ul><li>在页面render之前调用，state已经更新</li><li>典型场景：获取render之前的DOM状态</li></ul><p><strong>6.componentDidUpdate:</strong></p><ul><li>每次UI更新时被调用</li><li>典型场景：页面需要根据props变化重新获取数据</li></ul><p><strong>7.shouldComponentUpdate:</strong></p><ul><li>决定Vitual DOM是否重绘</li><li>一般由PureComponent自动实现</li><li>典型场景：性能优化</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-JSX的本质是语法糖</title>
    <link href="/2020/11/10/03-JSX%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <url>/2020/11/10/03-JSX%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    
    <content type="html"><![CDATA[<p>###理解JSX</p><p><em>JSX：在javaScript代码中直接写HTML标记。</em></p><pre><code class="hljs js"><span class="hljs-keyword">const</span> name=<span class="hljs-string">&#x27;jane&#x27;</span><span class="hljs-keyword">const</span> element=<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello,&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></code></pre><p><strong>1.JSX的本质</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/5e744edbbade47d2.png"></p><p><strong>2.在JSX中使用表达式</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/87d92de0fdbd6f36.png"></p><p><strong>3.JSX的优点</strong></p><ul><li>声明创建界面的直观</li><li>代码动态创建界面的灵活</li><li>无需学习新的模板语言</li></ul><p><strong>约定：自定义组件首字母大写</strong><br>1.react认为小写的tag是原生DOM节点，如div<br>2.大写字母开头的组件是自定义节点<br>3.JSX标记可以直接使用属性语法，如&lt;menu.Item /&gt;</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-react以组件方式考虑UI的构建</title>
    <link href="/2020/11/10/02-react%E4%BB%A5%E7%BB%84%E4%BB%B6%E6%96%B9%E5%BC%8F%E8%80%83%E8%99%91UI%E7%9A%84%E6%9E%84%E5%BB%BA/"/>
    <url>/2020/11/10/02-react%E4%BB%A5%E7%BB%84%E4%BB%B6%E6%96%B9%E5%BC%8F%E8%80%83%E8%99%91UI%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.bmp.ovh/imgs/2020/11/b28d10e0a2054aec.png"></p><p><strong>一、构建一个组件需要考虑的三件事情：</strong></p><p>1、组件的UI( 一些外在的表现形式 )<br>2、组件的状态管理（放在哪？）<br>3、组件的交互</p><p><img src="https://i.bmp.ovh/imgs/2020/11/f878479d2f41ffb4.png"></p><p><strong>二、何时创建组件：单一职责原则</strong></p><p>1、一个组件只负责一个功能<br>2、复杂的组件应该进行拆分</p><p><strong>三、数据状态管理原则：DRY原则</strong></p><p>1.能计算得到的状态不应该单独存储<br>2.组件尽量无状态，尽量通过props获取.</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-React的历史背景及特点</title>
    <link href="/2020/11/10/01-React%E7%9A%84%E5%8E%86%E5%8F%B2%E8%83%8C%E6%99%AF/"/>
    <url>/2020/11/10/01-React%E7%9A%84%E5%8E%86%E5%8F%B2%E8%83%8C%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="1-React-出现的历史背景"><a href="#1-React-出现的历史背景" class="headerlink" title="1. React 出现的历史背景"></a>1. React 出现的历史背景</h3><h4 id="A-UI方面的——"><a href="#A-UI方面的——" class="headerlink" title="A.UI方面的——"></a>A.UI方面的——</h4><p>传统WebUI存在的问题：</p><ul><li>传统UI关注太多的细节</li><li>应用程序的状态分散在各处，难以追踪和维护</li></ul><p><strong>=&gt;</strong> <strong>React的解决方案</strong>：react 始终整体”刷新”页面，无需关心细节。它只判断前后两个状态是否变化，并不关注背后的哪个细节发生了变化。<br><img src="https://i.bmp.ovh/imgs/2020/11/981310a92f37e99e.png"></p><h4 id="B-数据方面的——"><a href="#B-数据方面的——" class="headerlink" title="B.数据方面的——"></a>B.数据方面的——</h4><p>传统的MVC难以扩展和维护，太多的model和view，关系错综复杂且双向绑定，当出现了问题，很难追踪是model还是view层出现了问题。<br><img src="https://i.bmp.ovh/imgs/2020/11/0520d5fd55b9ac16.png"> </p><p><strong>=&gt;</strong> <strong>React的解决方案</strong>，提出了单向数据流架构flux.(后面衍生出redux和mobx)<br><img src="https://i.bmp.ovh/imgs/2020/11/1d93a50d7d4e112b.png"></p><h3 id="2-React-的特点："><a href="#2-React-的特点：" class="headerlink" title="2. React 的特点："></a>2. React 的特点：</h3><p>1个新概念<br>4个必须的API<br>单向数据流<br>完善的错误提示</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>my-first-blog</title>
    <link href="/2020/11/09/%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/"/>
    <url>/2020/11/09/%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="前端学习路线及资源"><a href="#前端学习路线及资源" class="headerlink" title=" 前端学习路线及资源"></a><center> 前端学习路线及资源</h2><p align='right'>——————左耳听风<p>&nbsp;&emsp;对于前端的学习和提高，我的基本思路是这样的。首先，前端的三个最基本的东西 HTML 5、CSS 3 和 JavaScript（ES6）是必须要学好的。这其中有很多很多的技术，比如，CSS 3 引申出来的 Canvas（位图）、SVG（矢量图） 和 WebGL（3D 图），以及 CSS 的各种图形变换可以让你做出非常丰富的渲染效果和动画效果。<br>&nbsp;&emsp; ES6 简直就是把 JavaScript 带到了一个新的台阶，JavaScript 语言的强大，大大释放了前端开发人员的生产力，让前端得以开发更为复杂的代码和程序，于是像 React 和 Vue 这样的框架开始成为前端编程的不二之选。<br>&nbsp;&nbsp; 我一直认为学习任何知识都要从基础出发，所以这篇文章我会着重介绍基础知识和基本原理，尤其是如下的这些知识，都是前端程序员需要花力气啃下来的硬骨头。JavaScript 的核心原理。这里我会给出好些网上很不错的讲 JavaScript </p><ul><li><p><strong>JavaScript 的核心原理</strong>。这里我会给出好些网上很不错的讲 JavaScript 的原理的文章或图书，你一定要学好语言的特性，并且详细了解其中的各种坑。</p></li><li><p><strong>浏览器的工作原理</strong>。这也是一块硬骨头，我觉得这是前端程序员需要了解和明白的关键知识点，不然，你将无法深入下去。</p></li><li><p><strong>网络协议 HTTP</strong>。也是要着重了解的，尤其是 HTTP/2，还有 HTTP 的几种请求方式：短连接、长连接、Stream 连接、WebSocket 连接。</p></li><li><p><strong>前端性能调优</strong>。有了以上的这些基础后，你就可以进入前端性能调优的主题了，我相信你可以很容易上手各种性能调优技术的。</p></li><li><p><strong>框架学习</strong>。我只给了 React 和 Vue 两个框架。就这两个框架来说，Virtual DOM 技术是其底层技术，组件化是其思想，管理组件的状态是其重点。而对于 React 来说，函数式编程又是其编程思想，所以，这些基础技术都是你需要好好研究和学习的。</p></li><li><p><strong>UI 设计</strong>。设计也是前端需要做的一个事，比如像 Google 的 Material UI，或是比较流行的 Atomic Design 等应该是前端工程师需要学习的。</p><p>&nbsp;而对于工具类的东西，这里我基本没怎么涉及，因为本文主要还是从原理和基础入手。那些工具我觉得都很简单，就像学习 Java 我没有让你去学习 Maven 一样，因为只要你去动手了，这种知识你自然就会获得，我们还是把精力重点放在更重要的地方。  </p><p>下面我们从前端基础和底层原理开始讲起。先来讲讲 HTML5 相关的内容。</p><h3 id="HTML-5"><a href="#HTML-5" class="headerlink" title="HTML 5"></a>HTML 5</h3><p>HTML 5 主要有以下几本书推荐。</p><ul><li><a href="https://book.douban.com/subject/25786074/">HTML 5 权威指南</a>，本书面向初学者和中等水平 Web 开发人员，是牢固掌握 HTML 5、CSS 3 和 JavaScript 的必读之作。书看起来比较厚，是因为里面的代码很多。</li><li><a href="https://book.douban.com/subject/24533314/">HTML 5 Canvas 核心技术 </a>，如果你要做 HTML 5 游戏的话，这本书必读。</li><li>对于 SVG、Canvas 和 WebGL 这三个对应于矢量图、位图和 3D 图的渲染来说，给前端开发带来了重武器，很多 HTML5 小游戏也因此蓬勃发展。所以，你可以学习一下。学习这三个技术，我个人觉得最好的地方是 MDN。</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/SVG">SVG: Scalable Vector Graphics</a></li><li><a href="https://developer.mozilla.org/kab/docs/Web/API/Canvas_API">Canvas API</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">The WebGL API: 2D and 3D graphics for the web</a></li></ul></li></ul><p>  最后是几个资源列表。</p><ul><li><a href="https://github.com/diegocard/awesome-html5">Awesome HTML5</a> 。GitHub 上的 Awesome HTML5，其中有大量的资源和技术文章。</li><li><a href="https://github.com/willianjusten/awesome-svg">Awesome SVG</a></li><li><a href="https://github.com/raphamorim/awesome-canvas">Awesome Canvas</a></li><li><a href="https://github.com/sjfricke/awesome-webgl">Awesome WebGL</a></li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>在《程序员练级攻略》系列文章最开始，我们就推荐过 CSS 的在线学习文档，这里再推荐一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">MDN Web Doc - CSS </a>。我个人觉得只要你仔细读一下文档，CSS 并不难学。绝大多数觉得难的，一方面是文档没读透，另一方面是浏览器支持的标准不一致。所以，学好 CSS 最关键的还是要仔细地读文档。之后，在写 CSS 的时候，你会发现，你的 CSS 中有很多看起来相似的东西。你的 DRY - Don’t Repeat Yourself 洁癖告诉你，这是不对的。所以，你需要学会使用 <a href="http://lesscss.org/">LESS</a> 和 <a href="http://sass-lang.com/">SaSS</a> 这两个 CSS 预处理工具，其可以帮你提高很多效率。然后，你需要学习一下 CSS 的书写规范，前面的《程序员修养》一文中提到过一些，这里再补充几个:</p><ul><li><p><a href="https://github.com/necolas/idiomatic-css">Principles of writing consistent, idiomatic CSS</a></p></li><li><p><a href="https://github.com/grvcoelho/css-styleguide">Opinionated CSS styleguide for scalable applications</a></p></li><li><p><a href="https://google.github.io/styleguide/htmlcssguide.html">Google HTML/CSS Style Guide</a></p><p>&emsp;如果你需要更有效率，那么你还需要使用一些 CSS Framework，其中最著名的就是 Twitter 公司的 Bootstrap，其有很多不错的 UI 组件，页面布局方案，可以让你非常方便也非常快速地开发页面。除此之外，还有，主打清新 UI 的 Semantic UI 、主打响应式界面的 Foundation 和基于 Flexbox 的 Bulma。<br>&emsp;当然，在使用 CSS 之前，你需要把你浏览器中的一些 HTML 标签给标准化掉。所以，推荐几个 Reset 或标准化的 CSS 库：Normalize、MiniRest.css、sanitize.css 和 unstyle.css。关于更多的 CSS 框架，你可以参看<a href="https://github.com/troxler/awesome-css-frameworks">Awesome CSS Frameworks</a> 上的列表。接下来，是几个公司的 CSS 相关实践，供你参考:</p></li><li><p><a href="https://codepen.io/chriscoyier/post/codepens-css"> CodePen’s CSS</a></p></li><li><p><a href="https://markdotto.com/2014/07/23/githubs-css/">Github 的 CSS</a></p></li><li><p>Medium’s CSS is actually pretty f***ing good()</p></li><li><p>CSS at BBC Sport</p></li><li><p><a href="https://blog.trello.com/refining-the-way-we-structure-our-css-at-trello">Refining The Way We Structure Our CSS At Trello</a></p><p>&emsp; 最后是一个可以写出可扩展的 CSS 的阅读列表 <a href="https://github.com/davidtheclark/scalable-css-readin">A Scalable CSS Reading List</a> 。</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>下面是学习 JavaScript 的一些图书和文章。</p></li><li><p><a href="">JavaScript: The Good Parts</a> ，中文翻译版为《JavaScript 语言精粹》。这是一本介绍 JavaScript 语言本质的权威图书，值得任何正在或准备从事 JavaScript 开发的人阅读，并且需要反复阅读。学习、理解、实践大师的思想，我们才可能站在巨人的肩上，才有机会超越大师，这本书就是开始。</p></li><li><p><a href="">Secrets of the JavaScript Ninja</a> ，中文翻译版为《JavaScript 忍者秘籍》，本书是 jQuery 库创始人编写的一本深入剖析 JavaScript 语言的书。适合具备一定 JavaScript 基础知识的读者阅读，</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
