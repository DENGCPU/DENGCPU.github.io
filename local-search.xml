<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>010-状态管理库Redux</title>
    <link href="/2020/11/16/010-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93Redux/"/>
    <url>/2020/11/16/010-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93Redux/</url>
    
    <content type="html"><![CDATA[<h3 id="一、React为何需要状态管理库"><a href="#一、React为何需要状态管理库" class="headerlink" title="一、React为何需要状态管理库"></a>一、React为何需要状态管理库</h3><p><img src="https://i.bmp.ovh/imgs/2020/11/26a4726bd6216f11.png"></p><p><img src="https://i.bmp.ovh/imgs/2020/11/8ed5fe88ed497e9c.png"><br>组件之间通信非常麻烦，有了redux把状态单独拧出来，组件通信就变得简单了。</p><p>Redux的特性：</p><ul><li><strong>1、Single Source of Truth</strong></li></ul><p>&emsp;传统的MVC架构：一个view可能对应多个model,一个model也可能对应多个view,关系错综复杂，这样一旦出现错误很难追踪。<br><img src="https://i.bmp.ovh/imgs/2020/11/5a9cb384b94cc272.png"></p><p>&emsp;Redux的结构：只有一个Store,出现错误容易追踪。</p><p><img src="https://i.bmp.ovh/imgs/2020/11/fbb96f01a9c20437.png"></p><ul><li><p><strong>2、可预测性</strong> （不可变性immutable）</p><p><img src="https://i.bmp.ovh/imgs/2020/11/4753506caf528c03.png"></p></li><li><p><strong>3、纯函数更新State</strong></p></li></ul><p>&emsp;&emsp;redux没有副作用.<br><img src="https://i.bmp.ovh/imgs/2020/11/17c05a6f634a7eaf.png"></p><h3 id="二、理解Redux的核心概念：Store-Action-Reducer"><a href="#二、理解Redux的核心概念：Store-Action-Reducer" class="headerlink" title="二、理解Redux的核心概念：Store, Action,Reducer"></a>二、理解Redux的核心概念：Store, Action,Reducer</h3><p><strong>1.理解Store:</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/bc6be7d1bc1deaf2.png"></p><p><strong>2.理解Action:</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/805628b35989fe98.png"></p><p>一个action是描述一个行为的数据结构，指定action的类型和要做的事情。</p><p><strong>3.理解Reducer：</strong></p><p><img src="https://i.bmp.ovh/imgs/2020/11/43ed9499a953d590.png"></p><p>下图综合理解这三个概念，可以看出redux的单向数据流动。<br><img src="https://i.bmp.ovh/imgs/2020/11/9fceb4adcb97b639.png"></p><h3 id="三、redux的几个工具函数"><a href="#三、redux的几个工具函数" class="headerlink" title="三、redux的几个工具函数"></a>三、redux的几个工具函数</h3><p><strong>1.combineReducers:</strong></p><p>将多个reducer结合起来形成新的reducer。</p><p><img src="https://pic.downk.cc/item/5fb1ddf2b18d627113a841a0.jpg"></p><p><strong>2.bindActionCreators:</strong></p><p><img src="https://pic.downk.cc/item/5fb1de1eb18d627113a848fb.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1de6fb18d627113a8563c.jpg"></p><h3 id="四、在React中使用Redux"><a href="#四、在React中使用Redux" class="headerlink" title="四、在React中使用Redux"></a>四、在React中使用Redux</h3><p>redux提供了一个<strong>react-redux</strong>的package，用connect把一个已有的组件连接到store上。</p><p><img src="https://pic.downk.cc/item/5fb1e29cb18d627113a9146f.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1e356b18d627113a93618.jpg"></p><h3 id="五、理解Redux的异步action以及中间件"><a href="#五、理解Redux的异步action以及中间件" class="headerlink" title="五、理解Redux的异步action以及中间件"></a>五、理解Redux的异步action以及中间件</h3><p>中间件截获后去访问一个API，根据访问的结果再dispatch.</p><p><img src="https://pic.downk.cc/item/5fb1eab2b18d627113aabab1.jpg"></p><p>异步的action并不是一个新的action类型, 而是几个同步action的组合使用.</p><p><img src="https://pic.downk.cc/item/5fb1eb4eb18d627113aae915.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1ecf0b18d627113ab5f8a.jpg"></p><h3 id="六、如何在redux中组织Action和Reducer"><a href="#六、如何在redux中组织Action和Reducer" class="headerlink" title="六、如何在redux中组织Action和Reducer"></a>六、如何在redux中组织Action和Reducer</h3><p><img src="https://pic.downk.cc/item/5fb1ede4b18d627113ab90f7.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1ee82b18d627113abad69.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1eec1b18d627113abb8da.jpg"></p><h3 id="七、-Redux的运行基础-不可变数据-immutability"><a href="#七、-Redux的运行基础-不可变数据-immutability" class="headerlink" title="七、 Redux的运行基础:不可变数据(immutability)"></a>七、 Redux的运行基础:不可变数据(immutability)</h3><p><img src="https://pic.downk.cc/item/5fb1efbcb18d627113abe8a3.jpg"></p><h5 id="1-为什么需要不可变数据"><a href="#1-为什么需要不可变数据" class="headerlink" title="1.为什么需要不可变数据?"></a>1.为什么需要不可变数据?</h5><ul><li><p><strong>1.性能优化:</strong><br> &emsp;store变化时会通知组件更新==&gt; store的变化都是由action触发==&gt;action触发在旧的state上形成新的state。不需要比较新旧state值是否变了,只需要判断<strong>前后状态的引用</strong>有没有变化</p></li><li><p><strong>2.易于调试和跟踪:</strong><br>任何时候，store变化时可以记录之前和之后的状态值。</p></li><li><p><strong>3.易于推测:</strong><br>任何时候，都可以找到是什么引起store的变化</p><h5 id="2-如何操作不可变数据"><a href="#2-如何操作不可变数据" class="headerlink" title="2.如何操作不可变数据?"></a>2.如何操作不可变数据?</h5></li></ul><p>==三种方式:==<br><img src="https://pic.downk.cc/item/5fb1f0f2b18d627113ac3540.jpg"></p><p>简单场景：使用原生写法就可以了。</p><p><img src="https://pic.downk.cc/item/5fb1f37cb18d627113acb0d5.jpg"></p><p>复杂场景：需要借助一些类库。</p><p><img src="https://pic.downk.cc/item/5fb1f414b18d627113accfd2.jpg"></p><p>immer: 性能差一点，适用应用程序小，场景简单的情况。<br><img src="https://pic.downk.cc/item/5fb1f44fb18d627113acdf4d.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>09-打包和部署</title>
    <link href="/2020/11/12/09-%E6%89%93%E5%8C%85%E5%92%8C%E9%83%A8%E7%BD%B2/"/>
    <url>/2020/11/12/09-%E6%89%93%E5%8C%85%E5%92%8C%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h4 id="一-为什么需要打包"><a href="#一-为什么需要打包" class="headerlink" title="一.为什么需要打包?"></a>一.为什么需要打包?</h4><ul><li>1.编译ES6语法特性，编译JSX</li><li>2.整合资源，例如图片svg,Less/Sass</li><li>3.优化代码体积</li></ul><p><img src="https://i.bmp.ovh/imgs/2020/11/ef5409f73d9ca563.png"></p><h4 id="二-打包注意事项"><a href="#二-打包注意事项" class="headerlink" title="二.打包注意事项:"></a>二.打包注意事项:</h4><p>1.设置node.js环境为production<br>2.禁止开发时专用代码，比如logger<br>3.设置应用根路径</p><p>npm run build 执行的就是打包过程。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>08-使用脚手架工具创建React项目</title>
    <link href="/2020/11/12/08-%E4%BD%BF%E7%94%A8%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E5%88%9B%E5%BB%BAReact%E9%A1%B9%E7%9B%AE/"/>
    <url>/2020/11/12/08-%E4%BD%BF%E7%94%A8%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E5%88%9B%E5%BB%BAReact%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="1-为什么需要脚手架？"><a href="#1-为什么需要脚手架？" class="headerlink" title="1.为什么需要脚手架？"></a>1.为什么需要脚手架？</h3><p><img src="https://i.bmp.ovh/imgs/2020/11/1df974a0ce1a7435.png"><br>项目越来越复杂，需要用：</p><ul><li><p>react: 做UI，</p></li><li><p>redux: 做状态管理，</p></li><li><p>react-router: 做路由管理</p></li><li><p>babel: 把js新特性翻译为浏览器可以识别的旧语法</p></li><li><p>webpack: 打包</p></li><li><p>eslint: 用于语法检查<br>…<br><img src="https://i.bmp.ovh/imgs/2020/11/611411d14c00f1a4.png"></p><p>&emsp;这些工具背后需要很多的package,我们需要了解每一个package的配置和使用，这使得创建项目非常繁琐。而创建一个项目的过程大致是差不多的，完全可以抽象出来做成一个工具<br>&emsp;===&gt;所以，脚手架应运而生。</p></li></ul><h3 id="2-常见的用于创建React应用的脚手架工具："><a href="#2-常见的用于创建React应用的脚手架工具：" class="headerlink" title="2.常见的用于创建React应用的脚手架工具："></a>2.常见的用于创建React应用的脚手架工具：</h3><ul><li><p><strong>Create React APP</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/6a1c377349d0f209.png"><br>&emsp; facebook 官方推出的，使用了最简策略，用于学习或创建简单的react项目</p></li><li><p><strong>Rekit</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/57aaa6b41498f44a.png"></p><p>&emsp;基于create-react-app,提供了更多的功能，可以开发大型的项目。</p></li><li><p><strong>Codesandbox</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/c18cd49b5e89621e.png"><br>&emsp; Online,在线的创建项目，webpack运行在浏览器端,大大提高打包速度。支持react,vue,angular</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>07-理解新的ContextAPI及其使用场景</title>
    <link href="/2020/11/11/07-%E7%90%86%E8%A7%A3%E6%96%B0%E7%9A%84ContextAPI%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2020/11/11/07-%E7%90%86%E8%A7%A3%E6%96%B0%E7%9A%84ContextAPI%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>Context解决的是：组件之间的通信问题</strong></p><p>Context提供了一个无需为每层组件手动添加props,就能在组件树间进行数据传递的方法。</p><p><img src="https://i.bmp.ovh/imgs/2020/11/c51c0b02a804b0fb.png"></p><h4 id="1-设计目的"><a href="#1-设计目的" class="headerlink" title="1.设计目的"></a>1.设计目的</h4><p>&emsp;Context设计的目的：为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或者首选语言。<br>&emsp;在一个典型的React应用中，数据是通过props属性自上而下（由父亲到儿子）进行传递的，但是这种做法对于某些属性是及其繁琐的（比如上文说的UI主题，），这些属性是应用程序中许多组件都需要的。</p><p><strong>==&gt;</strong> 所以，Context被设计出来，提供了一种在组件间共享“全局”数据的方式，从而不必显示地通过组件树逐层地传递props.</p><h4 id="2-使用Context前的考虑"><a href="#2-使用Context前的考虑" class="headerlink" title="2.使用Context前的考虑"></a>2.使用Context前的考虑</h4><p><strong>Context主要应用场景</strong>：很多不同层级之间的组件需要访问同样的一些数据。(但是需要谨慎使用，因为这会让组件的复用性变差。)<br>如果只是想避免层层传递一些属性，<a href="https://zh-hans.reactjs.org/docs/composition-vs-inheritance.html">组件组合（component composition）</a>有时是一个比Context更好的解决方案。</p><h4 id="3-相关的API"><a href="#3-相关的API" class="headerlink" title="3.相关的API"></a>3.相关的API</h4><p> <strong><em>(1) React.createContext</em></strong><br>  <pre><code class="hljs js"><span class="hljs-keyword">const</span> MyContext = React.createContext(defaultValue);</code></pre></p><ul><li>createContext函数创建一个Context对象，当React渲染一个订阅了这个Context对象的组件时，这个组件会从组件树中离自身最近的匹配到的Provider中读取当前的context值。<br>…</li><li><em>defaultValue</em>: 只有当组件所处的组件树中没有匹配到Provider时，其defaultValue参数才起作用。即使Provider中的value值是”undefined”，消费组件的defaultValue也不会生效。<br>（defaultValue有助于在不使用Provider包装组件的情况下，对组件进行测试）</li></ul><p><strong><em>(2)Context.Provider</em></strong></p><pre><code class="hljs js">&lt;MyContext.Provider value=&#123;<span class="hljs-comment">/*某个值*/</span>&#125;&gt;</code></pre><ul><li><p>每个Context对象都会返回一个Provider React组件，它允许消费组件订阅context的变化。</p></li><li><p>一个Provider可以和多个消费组件有对应关系。多个Provider也可以嵌套使用，里面的会覆盖外层的数据。</p></li><li><p>Provider有一个value属性，传递给消费组件。当value值发生变化时，Provider内部的所有消费组件都会重新渲染。<br>（Provider及其内部的消费组件都不受制于shouldComponentUpdate函数，所以当消费组件在其祖先组件推出更新的情况下也能更新）</p></li><li><p>通过新旧值检测确定变化，使用了和 Object.is相同的算法。</p></li></ul><p><strong><em>(3) Class.contextType</em></strong></p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">this</span>.context;    <span class="hljs-comment">/* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */</span>  &#125;  <span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">this</span>.context;    <span class="hljs-comment">/* ... */</span>  &#125;  <span class="hljs-function"><span class="hljs-title">componentWillUnmount</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">this</span>.context;    <span class="hljs-comment">/* ... */</span>  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">this</span>.context;    <span class="hljs-comment">/* 基于 MyContext 组件的值进行渲染 */</span>  &#125;&#125;MyClass.contextType = MyContext;</code></pre><ul><li>挂载在class上的contextType属性会被重新赋值为一个由React.createContext()创建的Context对象。所以使用this.context可以消费最近Context上的那个值，我们可以任何生命周期访问到this.context，包括render函数。</li><li>通过class.contextType只能订阅一个context</li></ul><p><strong><em>(4) Context.Consumer</em></strong></p><pre><code class="hljs js">&lt;MyContext.Consumer&gt;    &#123;<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span><span class="hljs-comment">/*基于context值进行渲染*/</span>&#125;&lt;/MyContext.Consumer&gt;</code></pre><ul><li><p>这是一个可以订阅context的变更的React组件，它在函数式组件中可以订阅一个context。</p></li><li><p>这种方法需要一个<a href="https://zh-hans.reactjs.org/docs/render-props.html#using-props-other-than-render">函数作为子元素（function as a child)</a>,这个函数接收当前的context值，并返回一个React节点。</p></li><li><p> 传递给Consumer的value值也就是组件树上方离context最近的Provider提供的value值，如果没有对应的Provider,就用createContext()中的defaultValue.</p></li></ul><p><strong><em>(5) Context.displayName</em></strong></p><p>示例，下述组件在DevTools中将是显示MyDisplayName:</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> MyContext = React.createContext(<span class="hljs-comment">/*some value*/</span>);MyContext.displayName = <span class="hljs-string">&#x27;MyDisplayName&#x27;</span>;&lt;MyContext.Provider&gt; <span class="hljs-comment">// &quot;MyDisplayName.Provider&quot; 在 DevTools 中</span>&lt;MyContext.Consumer&gt; <span class="hljs-comment">// &quot;MyDisplayName.Consumer&quot; 在 DevTools 中</span></code></pre><ul><li>context对象接受一个名为displayName的属性，类型为字符串。React DevTools使用该字符串来确定context要显示的内容。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>06-两种组件设计模式</title>
    <link href="/2020/11/11/06-%E4%B8%A4%E7%A7%8D%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/11/11/06-%E4%B8%A4%E7%A7%8D%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="组件复用的另外两种形式："><a href="#组件复用的另外两种形式：" class="headerlink" title="组件复用的另外两种形式："></a>组件复用的另外两种形式：</h4><p>（除了常规的组件复用之外）</p><ul><li><strong>高阶组件</strong></li><li><strong>函数作为子组件</strong></li></ul><h4 id="一-高阶组件"><a href="#一-高阶组件" class="headerlink" title="一.高阶组件"></a>一.高阶组件</h4><p><img src="https://i.bmp.ovh/imgs/2020/11/f50691752374e779.png"></p><p><strong>高阶组件(HOC)</strong> 是React中复用组件逻辑的一种高级技巧，它本身不是React API的一部分，而是基于React的组合特性形成的一种设计模式。高阶组件以组件为参数，并返回一个新组件。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponenent)</code></pre><p>==区分:== &emsp;组件是将props转换为UI，高阶组件是将组件转换为另一个组件。</p><p>具体参见：<a href="https://zh-hans.reactjs.org/docs/higher-order-components.html">React官方文档–高阶组件</a></p><h4 id="二-函数作为子组件"><a href="#二-函数作为子组件" class="headerlink" title="二.函数作为子组件"></a>二.函数作为子组件</h4><p><img src="https://i.bmp.ovh/imgs/2020/11/17246cbcf6e05f4d.png"></p><p><strong>总结：</strong></p><p>1、高阶组件和函数作为子组件都是设计模式（并不是新的组件类型）</p><p>2、可以实现更多场景的组件复用</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>05-理解VirtualDOM及key属性的作用</title>
    <link href="/2020/11/11/05-%E7%90%86%E8%A7%A3VirtualDOM%E5%8F%8Akey%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2020/11/11/05-%E7%90%86%E8%A7%A3VirtualDOM%E5%8F%8Akey%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>JSX的基础：虚拟DOM</p><p><img src="https://i.bmp.ovh/imgs/2020/11/6244a9607b4da0d0.png"></p><p><img src="https://i.bmp.ovh/imgs/2020/11/314414dd61ae46e0.png"></p><p>从根节点开始比较，针对不同情况，diff算法有不同的处理方式：</p><p><strong>1. 属性变化及顺序：</strong><br>   <img src="https://i.bmp.ovh/imgs/2020/11/231a0e379e4ef3a4.png"></p><p>==处理方式==：根据key属性，交换A与B的位置</p><p><strong>2. 节点类型发生变化：</strong><br>   <img src="https://i.bmp.ovh/imgs/2020/11/c65c14d031817b7e.png"></p><p>==处理方式==：暴力删除F节点（不管他是否在其他地方用到），创建一个新的G节点，append到A节点上。</p><p><strong>3. 节点跨层级移动：</strong><br>    <img src="https://i.bmp.ovh/imgs/2020/11/06f09ef16c9da001.png"></p><p>==处理方式==：diff算法直接删除左边B下面的D节点（以及其子树），到了右边，React直接创建一个新的D节点。</p><h4 id="虚拟DOM的两个假设："><a href="#虚拟DOM的两个假设：" class="headerlink" title="虚拟DOM的两个假设："></a>虚拟DOM的两个假设：</h4><p><strong>1、组件的DOM结构是相对稳定的（一般很少出现跨层级移动的情况）</strong></p><p>&emsp;&emsp;跨层级的节点移动，react的diff算法是直接删除。</p><p><strong>2、类型相同的兄弟节点可以被唯一标识（key属性）。</strong></p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>算法复杂度为O(n)</li><li>虚拟DOM如何计算diff</li><li>key属性的作用</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>04-react的生命周期</title>
    <link href="/2020/11/10/04-react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2020/11/10/04-react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="React的生命周期图"><a href="#React的生命周期图" class="headerlink" title="React的生命周期图"></a>React的生命周期图</h3><p><img src="https://i.bmp.ovh/imgs/2020/11/32b8163f9eadfd47.png"></p><p><strong>1.constructor:</strong></p><ul><li>用于初始化内部状态，很少使用</li><li>唯一可以直接修改state的地方</li></ul><p><strong>2.getDerivedStateFromProps:</strong></p><ul><li>当state需要从props初始化时使用。</li><li>尽量不要使用：维护两者状态一致性会增加复杂度。</li><li>每次render都会调用。</li><li>典型场景：表单控件获取默认值。</li></ul><p><strong>3.componentDidMount:</strong></p><ul><li>UI渲染完成后调用</li><li>只执行一次</li><li>典型场景：获取外部资源</li></ul><p><strong>4.componeWillUnmout:</strong></p><ul><li>组件移除时被调用</li><li>典型场景：资源释放</li></ul><p><strong>5.getSnapshotBeforeUpdate:</strong></p><ul><li>在页面render之前调用，state已经更新</li><li>典型场景：获取render之前的DOM状态</li></ul><p><strong>6.componentDidUpdate:</strong></p><ul><li>每次UI更新时被调用</li><li>典型场景：页面需要根据props变化重新获取数据</li></ul><p><strong>7.shouldComponentUpdate:</strong></p><ul><li>决定Vitual DOM是否重绘</li><li>一般由PureComponent自动实现</li><li>典型场景：性能优化</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>03-JSX的本质是语法糖</title>
    <link href="/2020/11/10/03-JSX%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <url>/2020/11/10/03-JSX%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    
    <content type="html"><![CDATA[<p>###理解JSX</p><p><em>JSX：在javaScript代码中直接写HTML标记。</em></p><pre><code class="hljs js"><span class="hljs-keyword">const</span> name=<span class="hljs-string">&#x27;jane&#x27;</span><span class="hljs-keyword">const</span> element=<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello,&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></code></pre><p><strong>1.JSX的本质</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/5e744edbbade47d2.png"></p><p><strong>2.在JSX中使用表达式</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/87d92de0fdbd6f36.png"></p><p><strong>3.JSX的优点</strong></p><ul><li>声明创建界面的直观</li><li>代码动态创建界面的灵活</li><li>无需学习新的模板语言</li></ul><p><strong>约定：自定义组件首字母大写</strong><br>1.react认为小写的tag是原生DOM节点，如div<br>2.大写字母开头的组件是自定义节点<br>3.JSX标记可以直接使用属性语法，如&lt;menu.Item /&gt;</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>02-react以组件方式考虑UI的构建</title>
    <link href="/2020/11/10/02-react%E4%BB%A5%E7%BB%84%E4%BB%B6%E6%96%B9%E5%BC%8F%E8%80%83%E8%99%91UI%E7%9A%84%E6%9E%84%E5%BB%BA/"/>
    <url>/2020/11/10/02-react%E4%BB%A5%E7%BB%84%E4%BB%B6%E6%96%B9%E5%BC%8F%E8%80%83%E8%99%91UI%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.bmp.ovh/imgs/2020/11/b28d10e0a2054aec.png"></p><p><strong>一、构建一个组件需要考虑的三件事情：</strong></p><p>1、组件的UI( 一些外在的表现形式 )<br>2、组件的状态管理（放在哪？）<br>3、组件的交互</p><p><img src="https://i.bmp.ovh/imgs/2020/11/f878479d2f41ffb4.png"></p><p><strong>二、何时创建组件：单一职责原则</strong></p><p>1、一个组件只负责一个功能<br>2、复杂的组件应该进行拆分</p><p><strong>三、数据状态管理原则：DRY原则</strong></p><p>1.能计算得到的状态不应该单独存储<br>2.组件尽量无状态，尽量通过props获取.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React的历史背景及特点</title>
    <link href="/2020/11/10/01-React%E7%9A%84%E5%8E%86%E5%8F%B2%E8%83%8C%E6%99%AF/"/>
    <url>/2020/11/10/01-React%E7%9A%84%E5%8E%86%E5%8F%B2%E8%83%8C%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="1-React-出现的历史背景"><a href="#1-React-出现的历史背景" class="headerlink" title="1. React 出现的历史背景"></a>1. React 出现的历史背景</h3><h4 id="A-UI方面的——"><a href="#A-UI方面的——" class="headerlink" title="A.UI方面的——"></a>A.UI方面的——</h4><p>传统WebUI存在的问题：</p><ul><li>传统UI关注太多的细节</li><li>应用程序的状态分散在各处，难以追踪和维护</li></ul><p><strong>=&gt;</strong> <strong>React的解决方案</strong>：react 始终整体”刷新”页面，无需关心细节。它只判断前后两个状态是否变化，并不关注背后的哪个细节发生了变化。<br><img src="https://i.bmp.ovh/imgs/2020/11/981310a92f37e99e.png"></p><h4 id="B-数据方面的——"><a href="#B-数据方面的——" class="headerlink" title="B.数据方面的——"></a>B.数据方面的——</h4><p>传统的MVC难以扩展和维护，太多的model和view，关系错综复杂且双向绑定，当出现了问题，很难追踪是model还是view层出现了问题。<br><img src="https://i.bmp.ovh/imgs/2020/11/0520d5fd55b9ac16.png"> </p><p><strong>=&gt;</strong> <strong>React的解决方案</strong>，提出了单向数据流架构flux.(后面衍生出redux和mobx)<br><img src="https://i.bmp.ovh/imgs/2020/11/1d93a50d7d4e112b.png"></p><h3 id="2-React-的特点："><a href="#2-React-的特点：" class="headerlink" title="2. React 的特点："></a>2. React 的特点：</h3><p>1个新概念<br>4个必须的API<br>单向数据流<br>完善的错误提示</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>my-first-blog</title>
    <link href="/2020/11/09/%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/"/>
    <url>/2020/11/09/%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="前端学习路线及资源"><a href="#前端学习路线及资源" class="headerlink" title=" 前端学习路线及资源"></a><center> 前端学习路线及资源</h2><p align='right'>——————左耳听风<p>&nbsp;&emsp;对于前端的学习和提高，我的基本思路是这样的。首先，前端的三个最基本的东西 HTML 5、CSS 3 和 JavaScript（ES6）是必须要学好的。这其中有很多很多的技术，比如，CSS 3 引申出来的 Canvas（位图）、SVG（矢量图） 和 WebGL（3D 图），以及 CSS 的各种图形变换可以让你做出非常丰富的渲染效果和动画效果。<br>&nbsp;&emsp; ES6 简直就是把 JavaScript 带到了一个新的台阶，JavaScript 语言的强大，大大释放了前端开发人员的生产力，让前端得以开发更为复杂的代码和程序，于是像 React 和 Vue 这样的框架开始成为前端编程的不二之选。<br>&nbsp;&nbsp; 我一直认为学习任何知识都要从基础出发，所以这篇文章我会着重介绍基础知识和基本原理，尤其是如下的这些知识，都是前端程序员需要花力气啃下来的硬骨头。JavaScript 的核心原理。这里我会给出好些网上很不错的讲 JavaScript </p><ul><li><p><strong>JavaScript 的核心原理</strong>。这里我会给出好些网上很不错的讲 JavaScript 的原理的文章或图书，你一定要学好语言的特性，并且详细了解其中的各种坑。</p></li><li><p><strong>浏览器的工作原理</strong>。这也是一块硬骨头，我觉得这是前端程序员需要了解和明白的关键知识点，不然，你将无法深入下去。</p></li><li><p><strong>网络协议 HTTP</strong>。也是要着重了解的，尤其是 HTTP/2，还有 HTTP 的几种请求方式：短连接、长连接、Stream 连接、WebSocket 连接。</p></li><li><p><strong>前端性能调优</strong>。有了以上的这些基础后，你就可以进入前端性能调优的主题了，我相信你可以很容易上手各种性能调优技术的。</p></li><li><p><strong>框架学习</strong>。我只给了 React 和 Vue 两个框架。就这两个框架来说，Virtual DOM 技术是其底层技术，组件化是其思想，管理组件的状态是其重点。而对于 React 来说，函数式编程又是其编程思想，所以，这些基础技术都是你需要好好研究和学习的。</p></li><li><p><strong>UI 设计</strong>。设计也是前端需要做的一个事，比如像 Google 的 Material UI，或是比较流行的 Atomic Design 等应该是前端工程师需要学习的。</p><p>&nbsp;而对于工具类的东西，这里我基本没怎么涉及，因为本文主要还是从原理和基础入手。那些工具我觉得都很简单，就像学习 Java 我没有让你去学习 Maven 一样，因为只要你去动手了，这种知识你自然就会获得，我们还是把精力重点放在更重要的地方。  </p><p>下面我们从前端基础和底层原理开始讲起。先来讲讲 HTML5 相关的内容。</p><h3 id="HTML-5"><a href="#HTML-5" class="headerlink" title="HTML 5"></a>HTML 5</h3><p>HTML 5 主要有以下几本书推荐。</p><ul><li><a href="https://book.douban.com/subject/25786074/">HTML 5 权威指南</a>，本书面向初学者和中等水平 Web 开发人员，是牢固掌握 HTML 5、CSS 3 和 JavaScript 的必读之作。书看起来比较厚，是因为里面的代码很多。</li><li><a href="https://book.douban.com/subject/24533314/">HTML 5 Canvas 核心技术 </a>，如果你要做 HTML 5 游戏的话，这本书必读。</li><li>对于 SVG、Canvas 和 WebGL 这三个对应于矢量图、位图和 3D 图的渲染来说，给前端开发带来了重武器，很多 HTML5 小游戏也因此蓬勃发展。所以，你可以学习一下。学习这三个技术，我个人觉得最好的地方是 MDN。</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/SVG">SVG: Scalable Vector Graphics</a></li><li><a href="https://developer.mozilla.org/kab/docs/Web/API/Canvas_API">Canvas API</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">The WebGL API: 2D and 3D graphics for the web</a></li></ul></li></ul><p>  最后是几个资源列表。</p><ul><li><a href="https://github.com/diegocard/awesome-html5">Awesome HTML5</a> 。GitHub 上的 Awesome HTML5，其中有大量的资源和技术文章。</li><li><a href="https://github.com/willianjusten/awesome-svg">Awesome SVG</a></li><li><a href="https://github.com/raphamorim/awesome-canvas">Awesome Canvas</a></li><li><a href="https://github.com/sjfricke/awesome-webgl">Awesome WebGL</a></li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>在《程序员练级攻略》系列文章最开始，我们就推荐过 CSS 的在线学习文档，这里再推荐一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">MDN Web Doc - CSS </a>。我个人觉得只要你仔细读一下文档，CSS 并不难学。绝大多数觉得难的，一方面是文档没读透，另一方面是浏览器支持的标准不一致。所以，学好 CSS 最关键的还是要仔细地读文档。之后，在写 CSS 的时候，你会发现，你的 CSS 中有很多看起来相似的东西。你的 DRY - Don’t Repeat Yourself 洁癖告诉你，这是不对的。所以，你需要学会使用 <a href="http://lesscss.org/">LESS</a> 和 <a href="http://sass-lang.com/">SaSS</a> 这两个 CSS 预处理工具，其可以帮你提高很多效率。然后，你需要学习一下 CSS 的书写规范，前面的《程序员修养》一文中提到过一些，这里再补充几个:</p><ul><li><p><a href="https://github.com/necolas/idiomatic-css">Principles of writing consistent, idiomatic CSS</a></p></li><li><p><a href="https://github.com/grvcoelho/css-styleguide">Opinionated CSS styleguide for scalable applications</a></p></li><li><p><a href="https://google.github.io/styleguide/htmlcssguide.html">Google HTML/CSS Style Guide</a></p><p>&emsp;如果你需要更有效率，那么你还需要使用一些 CSS Framework，其中最著名的就是 Twitter 公司的 Bootstrap，其有很多不错的 UI 组件，页面布局方案，可以让你非常方便也非常快速地开发页面。除此之外，还有，主打清新 UI 的 Semantic UI 、主打响应式界面的 Foundation 和基于 Flexbox 的 Bulma。<br>&emsp;当然，在使用 CSS 之前，你需要把你浏览器中的一些 HTML 标签给标准化掉。所以，推荐几个 Reset 或标准化的 CSS 库：Normalize、MiniRest.css、sanitize.css 和 unstyle.css。关于更多的 CSS 框架，你可以参看<a href="https://github.com/troxler/awesome-css-frameworks">Awesome CSS Frameworks</a> 上的列表。接下来，是几个公司的 CSS 相关实践，供你参考:</p></li><li><p><a href="https://codepen.io/chriscoyier/post/codepens-css"> CodePen’s CSS</a></p></li><li><p><a href="https://markdotto.com/2014/07/23/githubs-css/">Github 的 CSS</a></p></li><li><p>Medium’s CSS is actually pretty f***ing good()</p></li><li><p>CSS at BBC Sport</p></li><li><p><a href="https://blog.trello.com/refining-the-way-we-structure-our-css-at-trello">Refining The Way We Structure Our CSS At Trello</a></p><p>&emsp; 最后是一个可以写出可扩展的 CSS 的阅读列表 <a href="https://github.com/davidtheclark/scalable-css-readin">A Scalable CSS Reading List</a> 。</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>下面是学习 JavaScript 的一些图书和文章。</p></li><li><p><a href="">JavaScript: The Good Parts</a> ，中文翻译版为《JavaScript 语言精粹》。这是一本介绍 JavaScript 语言本质的权威图书，值得任何正在或准备从事 JavaScript 开发的人阅读，并且需要反复阅读。学习、理解、实践大师的思想，我们才可能站在巨人的肩上，才有机会超越大师，这本书就是开始。</p></li><li><p><a href="">Secrets of the JavaScript Ninja</a> ，中文翻译版为《JavaScript 忍者秘籍》，本书是 jQuery 库创始人编写的一本深入剖析 JavaScript 语言的书。适合具备一定 JavaScript 基础知识的读者阅读，</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
