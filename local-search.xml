<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面试13-如何分析和调优性能瓶颈？</title>
    <link href="/2021/07/15/%E9%9D%A2%E8%AF%9513-%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E5%92%8C%E8%B0%83%E4%BC%98%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%EF%BC%9F/"/>
    <url>/2021/07/15/%E9%9D%A2%E8%AF%9513-%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E5%92%8C%E8%B0%83%E4%BC%98%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="面试场景13：如何分析和调优性能瓶颈？"><a href="#面试场景13：如何分析和调优性能瓶颈？" class="headerlink" title="面试场景13：如何分析和调优性能瓶颈？"></a>面试场景13：如何分析和调优性能瓶颈？</h3><p><strong>破题</strong>：</p><p>做优化应该是一个<strong>有指标、有比较、有数据</strong>的过程。一个完整的解决方案应该说清楚标准，讲清楚缘由，理清楚结果，最后用数据与收益来说明你的工作成果。</p><ul><li>建立衡量标准：这样可以为优化后计算收益提供指标。衡量标准应该是可量化的，在确认指标之后，还需要有数据积累。</li><li>确认优化原因：有了数据基础，还需要根据具体场景分析优化能转化多少价值，确认是否需要优化</li><li>实施方案：在有了优化点之后，需要制定具体的提升方案并实施</li><li>计算收益：通过数据描述收益效果</li></ul><p><img src="https://pic.imgdb.cn/item/60ef8f2f5132923bf8676ccd.jpg"></p><h4 id="一、衡量"><a href="#一、衡量" class="headerlink" title="一、衡量"></a>一、衡量</h4><h5 id="1-1-理论基础"><a href="#1-1-理论基础" class="headerlink" title="1.1 理论基础"></a>1.1 理论基础</h5><p>分析调优的第一步是要知道问题出现在哪儿？ Google 的 DoubleClick 小组做过一个研究，证明了网页性能在一定程度上影响用户留存率。他们的研究显示，如果一个移动端页面加载时长超过 3 秒，用户就会放弃而离开。这很有意思，结论非常简单，却是可量化的。</p><p>显然，数字在沟通上可以降低理解成本，加强印象的魔力。在此基础上，Google的chrome组提出了以用户为核心的RAIL模型，用更多的数字维度去解释网页性能：</p><ul><li>Resonse 响应： 应在50毫秒内完成事件处理并反馈给用户</li><li>Animation 动画：10毫秒内生产一帧</li><li>Idle 浏览器空闲时间：最大化利用浏览器空闲时间</li><li>Load 加载： 在5秒内完成页面资源加载且使页面可交互</li></ul><h5 id="1-2-衡量工具"><a href="#1-2-衡量工具" class="headerlink" title="1.2 衡量工具"></a>1.2 衡量工具</h5><p>Chrome浏览器里内置了Lighthouse的测量工具：</p><p><img src="https://pic.imgdb.cn/item/60ef91cc5132923bf8750fd2.jpg" alt="开发者工具里的Lighthouse"></p><p>点击<strong>generate report</strong>，就可以直接生成一份网站性能报告：</p><p><img src="https://pic.imgdb.cn/item/60ef92845132923bf878ddcd.jpg" alt="例：React官方网站的性能报告"></p><p>在报告中会对诸如初次内容渲染、可交互时间、加载等进行具体的数值量化打分，最后还会给整体的性能一个总体分数，这里是88分：<br><img src="https://pic.imgdb.cn/item/60ef937e5132923bf87e1bf3.jpg"></p><ul><li>黄色代表当前处于一个用户尚可接受的状态</li><li>绿色代表了表现优异</li></ul><p>拉到最底部会有如何优化当前性能指标的指导意见，整份报告不仅包含了当前页面的性能数据，还囊括了最佳实践指南，如下图所示：<br><img src="https://pic.imgdb.cn/item/60ef94405132923bf88246ec.jpg"></p><p>那既然有了lighthouse，直接根据它去优化不就完事了么？但是，有一个问题还需要解决，lighthouse是否可以反映用户的真实情况呢？</p><p><strong>真实情况：</strong></p><p>我们经常会遇到一种情况，测试说她的电脑打开网页很慢，而在你自己电脑上打开加载速度却很快。同一个网页在不同的环境下，是否存在性能差异？是否需要根据不同的网络环境，不同的浏览器单独衡量呢？<br>另外一种情况，对于管理后台而言，需要对标C端的加载速度么？显然是不需要的。</p><p>由此可以看出：</p><ul><li>Lighthouse 并不能真实地反映出每个用户的设备实际性能数据</li><li>Lighthouse 的分数反映的是业界的标准，而非项目实际需求的标准</li></ul><p>基于以上原因，我们需要自行完成性能指标的采集。一般在大厂，有现成的工具可以用。如果没有，可以考虑使用网页APM工具：</p><ul><li>国际上老牌的New Relic</li><li>国内阿里云的ARMS，可参考其<a href="https://help.aliyun.com/document_detail/170905.html?spm=a2c4g.11186623.6.633.281f29ddxOQN8g">开发文档</a></li></ul><p>无论什么工具，它们都会对齐lighthouse这样一个行业标准，所以完全不用担心指标会有差异。</p><h5 id="1-3-采集过程"><a href="#1-3-采集过程" class="headerlink" title="1.3 采集过程"></a>1.3 采集过程</h5><p>以阿里云的ARMS为例，采集通常是由一个JavaScript SDK完成的，就像下面这样一个在script标签里引入bl.js的示例一样。</p><pre><code class="hljs js">&lt;script&gt;!(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">c,b,d,a</span>)</span>&#123;c[a]||(c[a]=&#123;&#125;);c[a].config=&#123;<span class="hljs-attr">pid</span>:<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-attr">appType</span>:<span class="hljs-literal">undefined</span>,<span class="hljs-attr">imgUrl</span>:<span class="hljs-string">&quot;https://arms-retcode.aliyuncs.com/r.png?&quot;</span>, <span class="hljs-attr">uid</span>: <span class="hljs-string">&quot;xxxx&quot;</span>&#125;;<span class="hljs-keyword">with</span>(b)<span class="hljs-keyword">with</span>(body)<span class="hljs-keyword">with</span>(insertBefore(createElement(<span class="hljs-string">&quot;script&quot;</span>),firstChild))setAttribute(<span class="hljs-string">&quot;crossorigin&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,src=d)&#125;)(<span class="hljs-built_in">window</span>,<span class="hljs-built_in">document</span>,<span class="hljs-string">&quot;https://retcode.alicdn.com/retcode/bl.js&quot;</span>,<span class="hljs-string">&quot;__bl&quot;</span>);&lt;/script&gt;</code></pre><p>接下来就是<strong>指标采集工作</strong>，指标需要根据业务需求增减或修改，所以经常会有变化，常用的指标一般有：</p><ol><li><p><strong>FCP</strong>（First Contentful Paint），首次绘制内容的耗时。首屏统计的方式一直在变，现在通常是记录<strong>初次加载</strong>并<strong>绘制内容</strong>的时间。<br><img src="https://pic.imgdb.cn/item/60efe0d75132923bf87ba3e4.jpg"></p></li><li><p><strong>TTI</strong>（Time to Interact），页面可交互的时间。一般是通过记录window.performance.timing中的domInteractive与fetchStart的时间差来完成。</p></li><li><p><strong>Page Load</strong>，页面完全加载时间。通常通过记录window.performance.timing中的loadEventStart与fetchStart的时间差来完成</p></li><li><p><strong>FPS</strong>，前端页面帧率。通常是在主线程打点完成记录，其原理是requestAnimationFrame会在页面重绘前被调用，而FPS就是计算两次之间的时间差。</p></li></ol><pre><code class="hljs js"><span class="hljs-keyword">let</span> lastTime = performance.now();<span class="hljs-keyword">let</span> frame = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> lastFrameTime = performance.now();<span class="hljs-keyword">const</span> loop = <span class="hljs-function">(<span class="hljs-params">time</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> now = performance.now();    lastFrameTime = now;    frame++;    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">now &gt; <span class="hljs-number">1000</span> + lastTime</span>)</span> &#123;        <span class="hljs-keyword">let</span> fps = <span class="hljs-built_in">Math</span>.round(frame / ((now - lastTime) / <span class="hljs-number">1000</span>));        frame = <span class="hljs-number">0</span>;        lastTime = now;        <span class="hljs-built_in">console</span>.log(fps);    &#125;    <span class="hljs-built_in">window</span>.requestAnimationFrame(loop);&#125;</code></pre><ol start="5"><li><strong>静态资源</strong>及<strong>API请求成功率</strong>。通常是通过window.performance.getEntries()来获取相关信息。</li></ol><p><img src="https://pic.imgdb.cn/item/60efe44d5132923bf897c1c4.jpg"></p><h4 id="二、排查"><a href="#二、排查" class="headerlink" title="二、排查"></a>二、排查</h4><p>优化最难的地方在于定目标。</p><p>制定目标有一个前提，对象是谁？需要明确的是，如果我们要提升网页的加载速度，应该把关注点放在整个用户群，而不是只有自己。</p><p>假设我们已经收集到了用户页面的性能数据，比如FCP的数据是1秒、3秒、4秒、6秒、7秒、8秒、65秒。那么提升性能是去提升他的平均值吗？平均数约39秒，并不能反映整体情况。</p><p>在性能监控中有一个概念叫TP（Top Percentile），如TP50指50的用户打开页面绘制的时间不超过6秒，90%的用户不超过8秒。如果要提升FCP，那么就需要提升TP50，TP90，TP99下的数据，这才是正确方向的目标。</p><p>其次是场景，如果是C端页面，那么FCP、TIL、FPS、Page Load、静态资源及Api请求成功率等几个目标都很重要，会直接影响关键业务的转化率。而管理后台，更关注的是使用功能是否完整，运行是否流畅，对加载速度并没有很高的要求，所以通常只对FPS、静态资源及Api请求成功率这三个指标更关注。显然，指标的选择取决于你的业务形态。</p><h4 id="三、实施"><a href="#三、实施" class="headerlink" title="三、实施"></a>三、实施</h4><p>这部分，拿FCP、TIL、Page Load、FPS、静态资源及Api请求成功率这几个指标来进行讲解。</p><ol><li><p><strong>FCP</strong><br>加载一个 React页面，通常是白屏到直接显示内容。那么，如果白屏时间过长，用户可能会流失，就需要在<strong>页面上绘制内容</strong>，给出一些反馈。</p><p>最早的优化方案是绘制一个<strong>Loading</strong>的图标，写死在HTML的CSS中，当JS开始执行的时候再移除它。</p><p>后来有了<strong>骨架屏</strong>的概念，如下面的Facebook的网页显示。在内容还没有就绪的时候，先通过渲染骨架屏，给予用户反馈。</p><p><img src="https://pic.imgdb.cn/item/60eff7665132923bf8197b72.jpg" alt="Facebook骨架屏"></p><p>还有一种解决方案是<strong>SSR</strong>，也就行服务端渲染，常用的方案有next.js等</p></li></ol><ol start="2"><li><p><strong>TIL</strong><br>TIL在实现上，可以优先加载让用户关注的内容，让用户先用起来。主要策略是<strong>异步加载</strong>与<strong>懒加载</strong>相结合。比如：</p><ul><li><b>核心内容</b>在React中同步加载</li><li><b>非核心内容</b>采取异步加载的方式延迟加载</li><li><b>内容中的图片</b>采用懒加载的方式避免占用网络资源</li></ul></li><li><p><strong>Page Load</strong></p><p><strong>页面完整加载时间</strong>同样可以通过异步加载的方式完成。异步加载主要由webpack打包common chunk与异步组件的方式完成。</p></li><li><p><strong>FPS</strong></p><p>FPS主要代表了卡顿的情况，在React中引起卡顿的主要原因是<strong>长列表</strong>与<strong>重渲染</strong>。长列表的解决方案已经很成熟，直接使用react-virtualied 或者 react-window就可以；重渲染的问题较复杂，下一讲会详细说明。</p></li><li><p><strong>静态资源及API请求成功率</strong></p><p>静态资源及API请求成功率都有可能在用户的机器上失败，而在自己的电脑上没有问题。导致这个问题的原因有很多：</p><ul><li>你是直接从前端服务器拉取JS与CSS资源，还是从CDN拉取的？</li><li>解析CDN与API域名存在失败的情况</li><li>运营商对静态资源及API请求做了篡改，导致请求失败。</li></ul><p>那么如何解决呢？</p><ul><li>对于静态资源而言，能用CDN就用CDN，可以大幅度提升静态资源的成功率</li><li>如果域名解析失败，就可以采取静态资源域名自动切换的方案；或者直接寻求SRE的帮助</li><li>如果有运营商对内容做了篡改，推荐使用 HTTPS。</li></ul></li></ol><h4 id="四、收益"><a href="#四、收益" class="headerlink" title="四、收益"></a>四、收益</h4><p>技术必须服务于业务。从技术角度讲收益，需要从业务实际收益出发。就像开篇所说的：“如果一个移动端页面加载时长超过 3 秒，用户就会放弃而离开。”那么将 TP999 从 5 秒优化到 3 秒以内，就可以得出具体的用户转化率数据。这样的技术优化才是对公司有帮助的。</p><p><strong>答题</strong>：</p><blockquote><p>我负责的业务是 CRM 管理后台，用户付费进入操作使用，有一套非常标准的业务流程。在我做完性能优化后，整个付费率一下提升了 17%，效果还可以。</p><p>前期管理后台的基础性能数据是没有的，我接手后接入了一套 APM 工具，才有了基础的性能数据。然后我对指标观察了一周多，思考了业务形态，发现其实用户对后台系统的加载速度要求并不高，但对系统的稳定性要求比较高。我也发现静态资源的加载成功率并不高，TP99 的成功率大约在 91%，这是因为静态资源直接从服务器拉取，服务器带宽形成了瓶颈，导致加载失败。我对 Webpack 的构建工作流做了改造，支持发布到 CDN，改造后 TP99 提升到了 99.9%</p></blockquote><p><img src="https://pic.imgdb.cn/item/60effb455132923bf82f8d01.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS06-50道CSS基础面试题</title>
    <link href="/2021/07/12/CSS06-50%E9%81%93CSS%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2021/07/12/CSS06-50%E9%81%93CSS%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="CSS06——50道CSS基础面试题"><a href="#CSS06——50道CSS基础面试题" class="headerlink" title="CSS06——50道CSS基础面试题"></a>CSS06——50道CSS基础面试题</h4><h5 id="1、介绍一下标准的CSS盒子模型？与低版本的IE盒子模型什么不同？"><a href="#1、介绍一下标准的CSS盒子模型？与低版本的IE盒子模型什么不同？" class="headerlink" title="1、介绍一下标准的CSS盒子模型？与低版本的IE盒子模型什么不同？"></a>1、介绍一下标准的CSS盒子模型？与低版本的IE盒子模型什么不同？</h5><ul><li>标准盒子模型：宽度 = 内容的宽度（content）+ border + padding + margin</li><li>IE盒子模型： 宽度 = 内容宽度（content + border + padding）+ margin</li></ul><p>标准 W3C 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。<br>IE盒模型也包括 margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 padding。</p><p>可参考：<a href="https://segmentfault.com/a/1190000015235886">谈谈你对CSS盒模型的认识</a></p><h5 id="2、box-sizing属性？"><a href="#2、box-sizing属性？" class="headerlink" title="2、box-sizing属性？"></a>2、box-sizing属性？</h5><pre><code class="hljs css"><span class="hljs-comment">/* 默认值是content-box，标准盒模型，设置元素的 height/width 属性指的是content部分的高/宽 */</span><span class="hljs-selector-tag">box-sizing</span>: <span class="hljs-selector-tag">conent-box</span>;<span class="hljs-comment">/* border-box IE盒模型，设置元素的height/width属性指的是border+padding+content的高/宽 */</span><span class="hljs-selector-tag">box-sizing</span>: <span class="hljs-selector-tag">border-box</span>;</code></pre><h5 id="3、CSS选择器有哪些？哪些属性可以继承？"><a href="#3、CSS选择器有哪些？哪些属性可以继承？" class="headerlink" title="3、CSS选择器有哪些？哪些属性可以继承？"></a>3、CSS选择器有哪些？哪些属性可以继承？</h5><p>CSS选择器： </p><ul><li>id选择器(#myid)</li><li>类选择器(.myclassname)</li><li>标签选择器(div,h1,p) </li><li>相邻选择器(h1+p)</li><li>子选择器(ul&gt;li)</li><li>后代选择器(li a)</li><li>通配符选择器(*)</li><li>属性选择器(a[rel=”external”])</li><li>伪类选择器(a:hover, li:nth-child)</li></ul><p>可继承的属性：font-size, font-family, color</p><p>不可继承的属性：border, padding, margin, width, height</p><p>选择器优先级（就近原则）：!important &gt; 内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器。</p><p>注意：!important比内联优先级高</p><h5 id="4、CSS优先级算法如何计算？"><a href="#4、CSS优先级算法如何计算？" class="headerlink" title="4、CSS优先级算法如何计算？"></a>4、CSS优先级算法如何计算？</h5><p>权重：</p><ol><li>第一优先级：<code>!important </code>会覆盖页面内任何位置的元素样式</li><li>内联样式，如<code>style=&quot;color:red&quot;</code>，权值为<b>1000</b></li><li>ID选择器，如<code>#app</code>，权值为<b>0100</b></li><li>类、伪类、属性选择器，如<code>.foo,:first-child,div[class=&#39;foo&#39;]</code>，权值为<b>0001</b></li><li>标签、伪元素选择器，如<code>div::first-line</code>，权值为<b>0001</b></li><li>通配符、子类选择器、兄弟选择器，如<code>*,&gt;,+</code>，权值为<b>0000</b></li><li>继承的样式没有权值</li></ol><p>比较规则：</p><ol><li>1000 &gt; 0100 从左往右逐个比较，前一级相等才往后比较</li><li>权重相同时，后面的样式会覆盖前面的样式</li><li>通配符、子选择器、兄弟选择器，虽然权重为0000，但是优先于继承的样式</li></ol><h5 id="5、CSS3新增伪类有哪些？"><a href="#5、CSS3新增伪类有哪些？" class="headerlink" title="5、CSS3新增伪类有哪些？"></a>5、CSS3新增伪类有哪些？</h5><ul><li>p:first-of-type 选择属于其父元素的首个元素</li><li>p:last-of-type 选择属于其父元素的最后元素</li><li>p:only-of-type 选择属于其父元素的唯一的元素</li><li>p:only-child 选择属于父元素的唯一子元素</li><li>p:nth-child(2) 选择属于其父元素的第二个子元素</li><li>:enabled :disabled 表单控件的禁用状态</li><li>:checked 单选框或复选框被选中</li></ul><h5 id="6、如何居中div？-如何居中一个浮动元素？如何让绝对定位的元素居中？"><a href="#6、如何居中div？-如何居中一个浮动元素？如何让绝对定位的元素居中？" class="headerlink" title="6、如何居中div？ 如何居中一个浮动元素？如何让绝对定位的元素居中？"></a>6、如何居中div？ 如何居中一个浮动元素？如何让绝对定位的元素居中？</h5><p>div居中：可参<a href="https://juejin.cn/post/6844903821529841671">div居中的几种方法</a></p><h5 id="7、display有哪些值？"><a href="#7、display有哪些值？" class="headerlink" title="7、display有哪些值？"></a>7、display有哪些值？</h5><p>inline(默认)——内联<br>none——隐藏<br>block——块显示<br>inline-block——内联块<br>list-item——项目列表</p><h5 id="8、position有哪些值？"><a href="#8、position有哪些值？" class="headerlink" title="8、position有哪些值？"></a>8、position有哪些值？</h5><ul><li><p>static(默认)：按照正常文档流进行排列</p></li><li><p>relative（相对定位）：不脱离文档流，参考自身静态位置通过top/bottom/left/right定位</p></li><li><p>absolute（绝对定位）：参考距其最近一个不为static的父级元素通过top/bottom/left/right定位</p></li><li><p>fixed(固定定位)：所固定的参照对象是可视化窗口</p></li><li><p>inherit: 从父元素继承该属性的值</p><p>具体可参考：<a href="https://dengcpu.github.io/2021/02/10/CSS%E5%B8%83%E5%B1%8005-%E5%AE%9A%E4%BD%8Dposition/">CSS布局05—定位position</a></p></li></ul><h5 id="9、CSS3有哪些新特性？"><a href="#9、CSS3有哪些新特性？" class="headerlink" title="9、CSS3有哪些新特性？"></a>9、CSS3有哪些新特性？</h5><p> 参考：<a href="https://juejin.cn/post/6844903486618861575#heading-1">前端面试之 CSS3 新特性</a></p><p>（1）边框：</p><ul><li>border-radius 圆角边框</li><li>border-shadow 添加阴影</li><li>border-image 使用图片来绘制边框</li></ul><p>（2）背景：</p><ul><li>background-clip 确定背景画区</li><li>background-origin 确定背景位置，通常与background-position联合使用</li><li>background-size 调整背景图片大小</li><li>background-break  CSS3中元素可以被分成几个独立的盒子（如使内联元素span跨越多行），background-break 属性用来控制背景怎样在这些不同的盒子中显示。</li></ul><p>（3）文字效果</p><ul><li>word-wrap 强制文本换行</li><li>text-overflow 设置超出指定容器的边界时如何显示</li><li>text-shadow 文本阴影</li><li>text-decoration  文字渲染</li></ul><p>（4）字体</p><p>@font-face特性 允许开发人员为网页指定在线字体</p><p>参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face">MDN–@font-face</a></p><p>（5）过渡、转换和动画</p><ul><li>过渡 Transition: 元素从一个样式变换为另一个样式时添加效果</li><li>转换 Transform: 2D和3D转换，允许我们对元素进行旋转、缩放、移动或倾斜</li><li>动画 Animation：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation">MDN-animation</a></li></ul><p>（6）渐变</p><p>CSS3 Gradient分为：linear-gradient（线性渐变）、radial-gradient（径向渐变）</p><p>（7）多列布局</p><p>CSS3可以通过创建多个列对文本进行布局：</p><ul><li>column-count: 规定元素应该被分隔的列数</li><li>column-gap: 规定列之间的间隔</li><li>column-rule: 设置列之间的宽度、样式、颜色等</li></ul><p>（8）用户界面</p><ul><li>resize: 规定是否可由用户调整元素尺寸</li><li>box-sizing: content-box/border-box/inherit</li><li>outline-offset: 对轮廓进行偏移，并在超出边框的位置绘制轮廓</li></ul><p>（9）媒体查询 @media</p><p>参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media">MDN-@media</a></p><p>（10） 弹性盒子（Flex Box)</p><p>弹性盒子是 CSS3 的一种新的布局模式。</p><p>参考: <a href="https://www.runoob.com/css3/css3-flexbox.html">弹性盒子-菜鸟教程</a></p><p>（11）RGBA 和透明度</p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML01-语义化标签</title>
    <link href="/2021/07/12/HTML01-%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/"/>
    <url>/2021/07/12/HTML01-%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="HTML01——页面结构语义化"><a href="#HTML01——页面结构语义化" class="headerlink" title="HTML01——页面结构语义化"></a>HTML01——页面结构语义化</h3><h4 id="一、为什么需要语义化？"><a href="#一、为什么需要语义化？" class="headerlink" title="一、为什么需要语义化？"></a>一、为什么需要语义化？</h4><ul><li>易修改、易维护。</li><li>无障碍阅读支持。</li><li>搜索引擎友好，利于 SEO。</li><li>面向未来的 HTML，浏览器在未来可能提供更丰富的支持</li></ul><h4 id="二、结构语义化"><a href="#二、结构语义化" class="headerlink" title="二、结构语义化"></a>二、结构语义化</h4><p>语义元素均有一个共同特点——他们均不做任何事情。换句话说，语义元素仅仅是页面结构的规范化，并不会对内容有本质的影响。</p><p>下图展示了一个典型的页面结构：</p><p><img src="https://pic.imgdb.cn/item/60eb95275132923bf869293b.jpg"></p><h5 id="2-1-头部"><a href="#2-1-头部" class="headerlink" title="2.1 头部"></a>2.1 头部</h5><pre><div class="caption"><span>HTML5 的规定，```<header>```都应包含某个级别的标题，所以应隐式或显式地包含标题，通常将不希望显示的标题设置为display: none;，一方面遵守规范，另一方面则提供了无障碍阅读而不至于影响到页面设计。</span></div><code class="hljs <header>```元素有两种用法，第一是标注内容的标题，第二是标注网页的页眉，如上图你看到的那样。除非必要（内容标题附带其它信息的情况下：发布时间、作者等），一般不在内容中使用```<header>```。因而，网页中可以包含多个```<header>```元素。按照">##### 2.2 导航栏导航栏使用&#96;&#96;&#96;&lt;nav&gt;&#96;&#96;&#96;看起来是理所当然的，进一步，它也用于一组文章的链接。一个页面可以包含多个&#96;&#96;&#96;&lt;nav&gt;&#96;&#96;&#96;元素，但通常仅仅在页面的主要导航部分使用它。《HTML5：The Missing Manual》中指出了在侧栏使用&#96;&#96;&#96;&lt;nav&gt;&#96;&#96;&#96;标签的两个案例：&#96;&#96;&#96;html&lt;!-- 案例一 --&gt;&lt;nav&gt;  &lt;!-- 此处是链接 --&gt;  &lt;aside&gt;&lt;&#x2F;aside&gt;  &lt;aside&gt;&lt;&#x2F;aside&gt;&lt;&#x2F;nav&gt;&lt;!-- 案例二 --&gt;&lt;aside&gt;  &lt;nav&gt;    &lt;!-- 此处是链接 --&gt;  &lt;&#x2F;nav&gt;  &lt;section&gt;&lt;&#x2F;section&gt;  &lt;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;aside&gt;</code></pre><p>如果侧栏中包含其它不同于链接的其它区块，那么，使用第二种方案显然更为合适。</p><p>导航通常包含一组链接，普遍认为，链接使用列表来组织。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;链接&quot;</span>&gt;</span>链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;链接&quot;</span>&gt;</span>链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;链接&quot;</span>&gt;</span>链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span></code></pre><h5 id="2-3-附注"><a href="#2-3-附注" class="headerlink" title="2.3 附注"></a>2.3 附注</h5><pre><code class="hljs <aside>```元素并不仅仅是侧栏，它表示与它周围文本没有密切关系的内容。文章中同样可以使用```<aside>```元素，来说明文章的附加内容、解释说明某个观点、相关内容链接等等。">当&#96;&#96;&#96;&lt;aside&gt;&#96;&#96;&#96;用于侧栏时，其表示整个网页的附加内容。通常的广告区域、搜索、分享链接则位于侧栏。侧栏中的&#96;&#96;&#96;&lt;section&gt;&#96;&#96;&#96;元素规定了一个区域，通常是带有标题的内容。&#96;&#96;&#96;&lt;section&gt;&#96;&#96;&#96;标签适合标记的内容区块：* 与页面主体并列显示的小内容块。* 独立性内容，清单、表单等。* 分组内容，如 CMS 系统中的文章分类区块。* 比较长文档的一部分，可能仅仅是为了正确规定页面大纲。&#96;&#96;&#96;&lt;div&gt;&#96;&#96;&#96;标签依然是可用的，当你觉得使用其它标签都不太合适的时候。新的语义元素出现之前，我们总是这么干的！##### 2.4 页脚同可“包罗万象”的&#96;&#96;&#96;&lt;header&gt;&#96;&#96;&#96;元素不同，标准规定&#96;&#96;&#96;&lt;footer&gt;&#96;&#96;&#96;标签仅仅可以包含版权、来源信息、法律限制等等之类的文本或链接信息。如果想要在页脚中包含其它内容，可以使用熟悉的&#96;&#96;&#96;&lt;div&gt;&#96;&#96;&#96;来帮忙。&#96;&#96;&#96;html&lt;div&gt;    &lt;aside&gt;      &lt;!-- 其它内容 --&gt;    &lt;&#x2F;aside&gt;      &lt;footer&gt;      &lt;!-- 法律、版权、来源、联系信息等 --&gt;    &lt;&#x2F;footer&gt;&lt;&#x2F;div&gt;</code></pre><h5 id="2-5-主要内容"><a href="#2-5-主要内容" class="headerlink" title="2.5 主要内容"></a>2.5 主要内容</h5><p>在早先的 HTML5 版本中并没有规定页面主体的标签，相关的书中经常会说：除去头部、尾部、侧栏等其它部分，剩下的自然是主体部分。</p><p>然而，HTML5.1 中规定了一个<code>&lt;main&gt;</code>标签来标识主体内容。<code>&lt;main&gt;</code>标签不能包含在页面其它区块元素中，通常是<code>&lt;body&gt;</code>的子标签，或者是全局<code>&lt;div&gt;</code>的子标签。<code>&lt;main&gt;</code>标签可以帮助屏幕阅读工具识别页面的主体部分，从而让访问者迅速得到有用的信息。</p><h5 id="2-6-文章"><a href="#2-6-文章" class="headerlink" title="2.6 文章"></a>2.6 文章</h5><pre><code class="hljs <article>```表示一个完整的、自成一体的内容块。如文章或新闻报道。```<article>```应包含完整的标题、文章署名、发布时间、正文。当语义与表现发生冲突，例如有时需要将文章分多个页面显示，那么需要把每个页面的文章区域都用```<article>```标记。">文章中包含插图时，使用新的语义元素&#96;&#96;&#96;&lt;figure&gt;&#96;&#96;&#96;标签。&#96;&#96;&#96;html&lt;article&gt;  &lt;h1&gt;标题&lt;&#x2F;h1&gt;  &lt;p&gt;    &lt;!-- 内容 --&gt;  &lt;&#x2F;p&gt;  &lt;figure&gt;    &lt;img src&#x3D;&quot;#&quot; alt&#x3D;&quot;插图&quot;&gt;    &lt;figcaption&gt;这是一个插图&lt;&#x2F;figcaption&gt;  &lt;&#x2F;figure&gt;&lt;&#x2F;article&gt;</code></pre><p>上述情况下，<code>&lt;figcaption&gt;</code>包含了关于插图的详细解释，则<code>&lt;img&gt;</code>的<code>alt</code>属性可以略去。</p><p>本文参考：<a href="https://rainylog.com/post/ife-note-1/">页面结构语义化</a></p>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试12-React的渲染异常会造成什么后果？</title>
    <link href="/2021/07/11/%E9%9D%A2%E8%AF%9512-React%E7%9A%84%E6%B8%B2%E6%9F%93%E5%BC%82%E5%B8%B8%E4%BC%9A%E9%80%A0%E6%88%90%E4%BB%80%E4%B9%88%E5%90%8E%E6%9E%9C%EF%BC%9F/"/>
    <url>/2021/07/11/%E9%9D%A2%E8%AF%9512-React%E7%9A%84%E6%B8%B2%E6%9F%93%E5%BC%82%E5%B8%B8%E4%BC%9A%E9%80%A0%E6%88%90%E4%BB%80%E4%B9%88%E5%90%8E%E6%9E%9C%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="面试场景12-React的渲染异常会造成什么后果？"><a href="#面试场景12-React的渲染异常会造成什么后果？" class="headerlink" title="面试场景12: React的渲染异常会造成什么后果？"></a>面试场景12: React的渲染异常会造成什么后果？</h3><p><strong>破题</strong></p><p>&nbsp;&nbsp;在<a href="https://dengcpu.github.io/2020/12/07/%E9%9D%A2%E8%AF%9503-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E7%9A%84%E5%9D%91%EF%BC%9F/">第3讲“如何避免生命周期中的坑”</a>中，有讲到“错误边界”的相关内容：如果渲染异常，在没有任何降级保护措施的情况下，，页面会直接显示白屏。但是问题到这里并没有结束，在类似“会产生什么影响”或“会造成什么后果”的问题后，紧接着会问“怎么解决”。</p><p><strong>审题：</strong></p><p>从上面的分析中可以整理出两个答题方向：</p><ul><li>“是什么”，即阐述现象与原理，在描述原理时，也要注意提供相应的案例；</li><li>“怎么解决”，即从工程化的角度展开，拿出通用化方案，并能量化结果，给出数据与指标。</li></ul><p><img src="https://pic.imgdb.cn/item/60ea4d435132923bf801de94.jpg"></p><h4 id="一、渲染异常是什么？"><a href="#一、渲染异常是什么？" class="headerlink" title="一、渲染异常是什么？"></a>一、渲染异常是什么？</h4><p>下面举个例子就能很好的说明：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;    state = &#123;        fruits: [<span class="hljs-string">&quot;apple&quot;</span>,<span class="hljs-string">&quot;banana&quot;</span>,<span class="hljs-string">&quot;pear&quot;</span>,<span class="hljs-string">&quot;orange&quot;</span>]    &#125;;    handleClick = <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-built_in">this</span>.setState(&#123;            fruits: <span class="hljs-literal">undefined</span>        &#125;)    &#125;;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> (            &lt;div className=<span class="hljs-string">&quot;App&quot;</span>&gt;                &lt;ul&gt;                    &#123;<span class="hljs-built_in">this</span>.state.fruits.map(<span class="hljs-function">(<span class="hljs-params">fruit</span>)=&gt;</span>&#123;                        &lt;li&gt;&#123;fruit&#125;&lt;/li&gt;                    &#125;)&#125;                &lt;/ul&gt;                &lt;button onClick=&#123;<span class="hljs-built_in">this</span>.handleClick&#125;&gt;Make a chaos&lt;/button&gt;            &lt;/div&gt;        )    &#125;&#125;</code></pre><p>这段代码包含了两个部分：</p><ul><li>渲染this.state.fruits的常规操作</li><li>按钮点击事件，通过点击按钮将fruits重置为undefined</li></ul><p>整段代码运行后，展示的内容如下图所示：<br><img src="https://pic.imgdb.cn/item/60ea57a45132923bf837e0f5.jpg"></p><p>这时如果点击按钮，就会看到熟悉的React报错。这是因为在开发模式下react-error-overlay，所以在代码抛出异常后，能够在页面上直接看见。<br><img src="https://pic.imgdb.cn/item/60ea58215132923bf83a753e.jpg"></p><p>如果是生产模式呢？即直接把代码打包上线，运行在线上会怎么样呢？这时，点击按钮，整个界面会直接消失。</p><p>为什么会产生这种现象呢？React官方团队是这样说的：</p><blockquote><p>组件内的 JavaScript 错误会导致 React 的内部状态被破坏，并且在下一次渲染时产生可能无法追踪的错误。这些错误基本上是由较早的其他代码（非 React 组件代码）错误引起的，但 React 并没有提供一种在组件中优雅处理这些错误的方式，也无法从错误中恢复。</p></blockquote><p>简而言之，如果有JS的错误出现在React内部渲染层，就会导致整个应用的崩溃。从现象来看，就是整个界面从页面中被移除掉，也就展现出了所谓的白屏。</p><h4 id="二、怎么解决渲染异常呢？"><a href="#二、怎么解决渲染异常呢？" class="headerlink" title="二、怎么解决渲染异常呢？"></a>二、怎么解决渲染异常呢？</h4><p>在<a href="https://dengcpu.github.io/2020/12/07/%E9%9D%A2%E8%AF%9503-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E7%9A%84%E5%9D%91%EF%BC%9F/">第3讲“如何避免生命周期中的坑”</a>中有讲到“错误边界”的概念，其中应用了getDerivedStateFromError与componentDidCatch两个函数。但这并不是完整的解决方案，完整的方案通常要从预防和兜底两个角度解决问题。</p><h5 id="2-1-预防"><a href="#2-1-预防" class="headerlink" title="2.1 预防"></a>2.1 预防</h5><p>预防就需要事先知道病灶在哪里。既然是渲染异常，就需要分析异常会出现在哪里。我们可以知道，在渲染层，也就是render中return后的JSX，都是在进行数据的<strong>拼接</strong>与<strong>转换</strong></p><ul><li>如果在拼接的过程出现错误，那直接会导致编译的失败</li><li>如果在转换的过程出现错误，就很不容易被发现</li></ul><p>比如上述案例中的this.state.fruits为undefined就很难发现，尤其是前端的渲染数据基本都是通过后端业务接口获取的，那么数据是否可靠就成了至关重要的问题。</p><p>这个问题被称为<strong>null-safety</strong>，也就是空安全。它没有最优解，不仅困扰着我们，也困扰着Facebook这样的大公司，目前他们对于这个问题的解决方案是使用idx。  idx在使用时需要配置Babel插件，再引入idx库，然后通过idx函数包裹需要使用的object，再在回调函数中取需要的值。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> idx <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;idx&#x27;</span>;<span class="hljs-comment">//使用时</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFriends</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> idx(props, <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> _.user.friends[<span class="hljs-number">0</span>].friends)&#125;<span class="hljs-comment">//转换后</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFriends</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> props.user == <span class="hljs-literal">null</span> ? props.user :    props.user.friends == <span class="hljs-literal">null</span> ? props.user.friends:    props.user.friends[<span class="hljs-number">0</span>] == <span class="hljs-literal">null</span> ? props.user.friends[<span class="hljs-number">0</span>]:    props.user.friend[<span class="hljs-number">0</span>].friends&#125;</code></pre><p>idx的代码既不优雅，也不简洁，还需要引入Babel插件，所以在社区中使用者寥寥无几，还不如使用Lodash的get函数。那么有没有优雅的解决方案呢？ 有，就是ES2020中的Optional chaining 中文叫<strong>可选链操作符</strong>。如果用可选链操作符重新render函数的话，可以写成：</p><pre><code class="hljs js">render()     <span class="hljs-keyword">return</span> (        &lt;div className=<span class="hljs-string">&#x27;App&#x27;</span>&gt;            &lt;ul&gt;                &#123;<span class="hljs-built_in">this</span>.state?.fruits.map(<span class="hljs-function">(<span class="hljs-params">fruit</span>) =&gt;</span> &#123;                    &lt;li&gt;&#123;fruit&#125;&lt;/li&gt;                &#125;)&#125;            &lt;/ul&gt;            &lt;button onClick=&#123;<span class="hljs-built_in">this</span>.handleClick&#125;&gt;Make a chaos&lt;/button&gt;        &lt;/div&gt;    )&#125;</code></pre><p>并不是所有浏览器都支持该特性，但是可以通过引入Babel插件保证浏览器兼容性：</p><pre><code class="hljs js">&#123;    <span class="hljs-string">&quot;plugins&quot;</span>: [<span class="hljs-string">&quot;@babel/plugin-proposal-optional-chaining&quot;</span>]&#125;</code></pre><p>可选链操作符是一个遵循ES标准，侵入性比较低的方案。那么有没有不需要配置的方案呢?也是有的，如果使用TypeScript的话，在3.7版本中可以直接使用该特性。</p><h5 id="2-2-兜底"><a href="#2-2-兜底" class="headerlink" title="2.2 兜底"></a>2.2 兜底</h5><p>虽然空安全的预防方案足够完善，但我们不可能在每行代码中都使用。而且旧项目的代码，逐行修改费时费力。所以，以防万一，肯定是需要兜底方案的。</p><p>兜底应该限制崩溃的层级。错误边界加到哪里，崩溃就止步于哪里，其他组件还可以正常使用，所以只需要给关键的UI组件添加错误边界。这时可以使用我们在<a href="https://dengcpu.github.io/2020/12/17/%E9%9D%A2%E8%AF%9505-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1React%E7%BB%84%E4%BB%B6%EF%BC%9F/">第5讲“如何设计React组件？”</a>中提到的高阶组件：</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> errorBoundary = <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;        state = &#123;            hasError: <span class="hljs-literal">false</span>,        &#125;;        <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getDerivedStateFromError</span>(<span class="hljs-params">err</span>)</span> &#123;            <span class="hljs-keyword">return</span> &#123;                hasError: <span class="hljs-literal">true</span>,            &#125;;        &#125;        <span class="hljs-function"><span class="hljs-title">componentDidCatch</span>(<span class="hljs-params">err: <span class="hljs-built_in">Error</span>, info: React.ErrorInfo</span>)</span> &#123;            <span class="hljs-built_in">console</span>.log(err,info)        &#125;        <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;            <span class="hljs-keyword">return</span> (                <span class="hljs-built_in">this</span>.state.hasError ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ErrorDefaultUI</span> <span class="hljs-attr">error</span>=<span class="hljs-string">&#123;this.state.error&#125;</span> /&gt;</span></span> : &lt;WrappedComponent&gt;            )        &#125;    &#125;&#125;</code></pre><p>用这个高阶组件拦截报错信息，展示统一的错误页面，也就是ErrorDefaultUI。使用起来也很简单，直接在原函数上挂上注解就可以了。</p><pre><code class="hljs js">@errorBoundary<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserProfile</span> </span>&#123;&#125;</code></pre><p>这个方案可以在团队内部抽取为一个npm包，提供能力复用。</p><h5 id="2-3-量化结果"><a href="#2-3-量化结果" class="headerlink" title="2.3 量化结果"></a>2.3 量化结果</h5><p>我们做了这么多事情，那如何评估做得好不好呢？就需要数据说话，来评估事情到底有没有价值。</p><ul><li>在预防层面，需要看空安全方案在项目中覆盖量，从而保证团队内项目都将空安全用了起来</li><li>在兜底层面，同样需要保证方案在项目中覆盖量，其次需要统计兜底页面成功兜底的次数，最后兜底页面展示时能够及时完成线上报警。</li></ul><p>所以，量化工作应该从<strong>覆盖</strong>与<strong>统计</strong>两方向展开：</p><ol><li>覆盖量，最简单的方式就是直接查看项目的package.json文件是否引入了相关的库。有的公司代码检测使用统一的工具，比如sonar, 那么你就只需要去写配置文件就行。那如果公司什么没接入呢？你甚至可以用一个最原始简单的方案去实现，比如写一个node脚本，去拉去相关仓库的代码自行分析。然后每周产出一个dashboard查看使用情况</li><li>统计，相对容易。因为每个公司至少会接入一种统计工具，比如百度统计、Google统计或者mixpanel来完成业务分析。所以只需要在代码中，添加一行统计代码，直接上报相关信息就行。如果有条件的话，最好也接入一下报警系统，这样能够及时发现问题并上报。<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">componentDidCatch</span>(<span class="hljs-params">err: <span class="hljs-built_in">Error</span>, info: React.ErrorInfo</span>)</span> &#123;    <span class="hljs-comment">//业务统计</span>    trackEvent(<span class="hljs-string">&#x27;error boundary&#x27;</span>, &#123;err, info&#125;);    <span class="hljs-comment">//业务报警</span>    reportError(error, info);&#125;</code></pre></li></ol><p><strong>答题：</strong></p><blockquote><p>React渲染异常的时候，在没有做任何拦截的情况下，会出现整个页面白屏的现象。它的成型原因是在渲染层出现了JS的错误，导致整个应用崩溃。这种错误通常是在render中没有控制好空安全，使值取到了空值。</p></blockquote><blockquote><p>在治理上，主要从预防与兜底两个角度去处理。<br/><br>在预防策略上，引入空安全相关的方案。技术选型上主要有三个方案：第一个使引入外部函数，比如Facebook的idx或者Lodash.get;第二个是引入Babel插件，使用ES2020的标准——可选链操作符；第三个是TypeScript，它在3.7版本之后可以直接使用可选链操作符。<br/><br>在兜底策略上，考虑到团队内部可能存在一样的问题，抽取兜底的公共高阶组件，封装NPM包供团队内部使用。</p></blockquote><blockquote><p>（举例）从最终的数据来看，预防与治理方案覆盖了团队内部100%的React项目，前三个月兜底组件统计到了日均10次的报警信息，其中有10%是公司关键业务。那么经过分析与统计，首为关键的ui组件添加兜底组件进行拦截，然后就是做内部培训，对易错点的代码进行指导，加强code review。后续到现在，线上只收到过1次报警。</p></blockquote><p><img src="https://pic.imgdb.cn/item/60ea9c975132923bf8d19d93.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试11-如何解释React的渲染流程？</title>
    <link href="/2021/07/05/%E9%9D%A2%E8%AF%9511-%E5%A6%82%E4%BD%95%E8%A7%A3%E9%87%8AReact%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%EF%BC%9F/"/>
    <url>/2021/07/05/%E9%9D%A2%E8%AF%9511-%E5%A6%82%E4%BD%95%E8%A7%A3%E9%87%8AReact%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="面试场景11：如何解释React的渲染流程？"><a href="#面试场景11：如何解释React的渲染流程？" class="headerlink" title="面试场景11：如何解释React的渲染流程？"></a>面试场景11：如何解释React的渲染流程？</h3><p><strong>破题:</strong></p><p> 想要讲清楚渲染流程，需要知道什么时渲染过程中的重点？以及渲染过程中的层次该如何划分？</p><p> <strong>承题：</strong></p><p> React面试前几讲中提到了渲染流程中的知识点：React渲染节点的挂载、React组件的生命周期、setState触发渲染更新、diff策略与patch方案。 渲染流程中包含的内容很繁杂，有大大小小需要处理的事，专业术语叫<strong>事务</strong>。事务具有<strong>原子性</strong>，必须作为一个整体执行完成，是无法分割的。</p><p> 事务是通过<strong>调度</strong>的方式协调执行的。有了全局规划的调度，也有了具体的事务，但是工作往往是按<strong>阶段进行划分</strong>的，渲染流程中也存在阶段划分。</p><p> 这样，初步的答题框架就有了：<br> <img src="https://pic.imgdb.cn/item/60e262bd5132923bf8fa1861.jpg" alt="React渲染"></p><p> 在逐级梳理之前，我们先讲一个渲染流程中绝对绕不开的概念——协调。</p><h4 id="一、协调"><a href="#一、协调" class="headerlink" title="一、协调"></a>一、协调</h4><p> 协调，在React官方博客中原文是Reconciler，官方文档在介绍协调时，是这么说的：</p><blockquote><p>React提供的声明式API让开发者可以在对React的底层实现没有具体了解的情况下编写应用。在开发者编写应用是虽然保持相对简单的心智，但开发者无法了解内部的实现机制。本文描述了在实现React的“diffing”算法中我们做出的设计决策以保证组件满足更新具有可预测性，以及在繁杂业务下依然保持应用的高性能性。</p></blockquote><p>从这段官方文档可以看出，Reconciler是协助React确认状态变化时要更新哪些DOM元素的diff算法，看上去有点调解员的意思。这是狭义的Reconciler，也是<a href="https://dengcpu.github.io/2021/07/03/%E9%9D%A2%E8%AF%9510-React%E7%9A%84diff%E7%AE%97%E6%B3%95%E6%9C%89%E4%BD%95%E7%89%B9%E7%82%B9%EF%BC%9F/">第10讲“React的diff算法有何特点？”</a>中提到的内容。</p><p>而在React源码中还有一个叫做reconcilers的模块，它通过抽离公共函数与diff算法使声明式渲染、自定义组件、state、生命周期方法和refs等特性实现跨平台工作。<br/><br>Reconcilers模块以React16为界线分为两个版本：</p><ol><li><strong>Stack Reconciler</strong> 是React15及其以前版本的方案，其核心是以<strong>递归的方式</strong>逐级调度栈中子节点到父节点的渲染。</li><li><strong>Fiber Reconciler</strong>是React16及其以后版本的方案，它的核心设计是<strong>增量渲染</strong>（incremental rendering)，也就是将渲染工作分割为多个区块，并将西其分散到多个帧中。设计初衷是提高react在动画、画布以及手势等场景下的性能表现。</li></ol><p>这两者之间的性能可以通过一个<a href="https://claudiopro.github.io/react-fiber-vs-stack-demo/">demo</a>明显地体会到。</p><h4 id="二、渲染"><a href="#二、渲染" class="headerlink" title="二、渲染"></a>二、渲染</h4><h5 id="2-1-Stack-Reconciler"><a href="#2-1-Stack-Reconciler" class="headerlink" title="2.1 Stack Reconciler"></a>2.1 Stack Reconciler</h5><p>Stack Reconciler没有单独的包，并没有像Fiber Reconciler一样抽取为独立的<a href="https://github.com/facebook/react/tree/16.3-dev/packages/react-reconciler">React-Reconciler模块</a>。但它依然是一个经典的设计。在React官方文档中，是通过伪代码的形式介绍其<a href="https://react.html.cn/docs/implementation-notes.html">实现方案</a>的。</p><p><strong>挂载</strong>：</p><p>这里的挂载并不是生命周期里提到的挂载，它是将整个React挂载到ReactDOM.render之上，就像以下代码中的App组件挂载在root节点之上：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> (            &lt;div&gt;hello world&lt;/div&gt;        )    &#125;&#125;ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>))</code></pre><p>之前说过，JSX会被Babel编译为React.createElement的形式：</p><pre><code class="hljs js">ReactDOM.render(React.createElement(App), <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>))</code></pre><p>但是，这项工作是发生在本地的Node进程中，而不是通过浏览器中的React完成的。（<strong>JSX不是通过React完成编译</strong>）</p><p>ReactDOM.render调用之后，实际上是<strong>透传参数给ReactMount.render</strong>.</p><ul><li>ReactDOM是对外暴露的模块接口</li><li>ReactMount是实际执行者，完成初始化React组件的整个过程。</li></ul><p>初始化第一步就是通过React.createElement创建React Element。不同的组件类型会被创建为不同的Element:</p><ul><li>App组件会被标记为type function，作为用户自定义的组件，被ReactComponentsiteComponent包裹一次，生成一个对象实例；</li><li>div 标签作为React内部的已知DOM类型，会实例化为ReactDOMComponent;</li><li>“hello world”会被直接判断是否为字符串，实例化为ReactDOMComponent。</li></ul><p><img src="https://pic.imgdb.cn/item/60e2c71e5132923bf867f448.jpg"></p><p>这段的逻辑在React源码中大致是这样的，其中isInternalComponentType就是判断当前的组件是否为内部已知类型：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-keyword">typeof</span> element.type === <span class="hljs-string">&#x27;string&#x27;</span></span>)</span> &#123;    instance = ReactHostComponent.createInternalComponent(element);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isInternalComponentType(element.type))&#123;    instance = <span class="hljs-keyword">new</span> element.type(element)&#125; <span class="hljs-keyword">else</span> &#123;    instance = <span class="hljs-keyword">new</span> ReactCompositeComponentWrapper();&#125;</code></pre><p>到这里仅仅是完成了实例化，我们还需要与React产生一些联动，比如改变状态、更新界面等。在setState一讲中，我们提到在状态变更后，涉及一个变更收集再批量处理的过程。这里ReactUpates模块就专门<strong>用于批量处理</strong>，而批量处理的前后操作，是由React通过建立事务的概念来处理的。</p><p>React事务都是基于Transaction类继承拓展。每个Transaction实例都是一个封闭空间，保持不可变的任务常量，并提供对应的事务处理接口。一段事务在React源码中大概是这样的：</p><pre><code class="hljs js">mountComponentIntoNode: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rootID, container</span>)</span>&#123;    <span class="hljs-keyword">var</span> transaction = ReactComponent.ReactReconcileTransaction.getPooled();    transaction.perform(        <span class="hljs-built_in">this</span>._mountComponentIntoNode,        <span class="hljs-built_in">this</span>,        rootID,        container,        transaction    );    ReactComponent.ReactReconcileTransaction.release(transaction);&#125;</code></pre><p>这里React团队是从后端领域借鉴到前端的，事务的设计有以下优势：</p><ul><li>原子性：事务作为一个整体被执行，要么全部被执行，要么都不执行</li><li>隔离性：多个事务并发执行时，一个事务的执行不应该影响其他事务的执行。</li><li>一致性: 相同的输入，确定能得到同样的执行结果。</li></ul><p>上面提到的事务会调用ReactCompositeComponent.mountComponent函数进入React生命周期，它的源码大致是这样的：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">inst.componentWillMount</span>)</span>&#123;    inst.componentWillMount();    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-built_in">this</span>._pendingStateQueue</span>)</span> &#123;        inst.state = <span class="hljs-built_in">this</span>._processPendingState(inst.props, inst.context);    &#125;&#125;</code></pre><p>首先会判断是否有 componentWillMount，然后初始化 state 状态。当 state 计算完毕后，就会调用在 App 组件中声明的 render 函数。接着 render 返回的结果，会处理为新的 React Element，再走一遍上面提到的流程，不停地往下解析，逐步递归，直到开始处理 HTML 元素。到这里我们的 App 组件就完成了首次渲染。</p><p><strong>更新</strong>：</p><p>现在来解析当调用setState时会发生什么，setState时会调用Component类中的enqueueSetState函数：</p><pre><code class="hljs js"><span class="hljs-built_in">this</span>.updater.enqueueSetState(<span class="hljs-built_in">this</span>, partialState);</code></pre><p>在执行enqueueSetState后，会调用ReactCompositeComponent实例中的_pendingStateQueue,将新的状态变更加入实例的等待更新状态队列中，再调用ReactUpdates模块中的enqueueUpdate函数执行更新。这个过程会检查更新是否已经在进行中：</p><ul><li>如果是，则把组件加入dirtyComponents中；</li><li>如果不是，先初始化更新事务，然后把组件加入dirtyComponents列表。</li></ul><p>这里的初始化更新事务，就是setState一讲中提到的batchingstrategy.isBatchingUpdates开关。接下来就会在更新事务中处理所有记录的dirtyComponents。</p><p><strong>卸载：</strong></p><ol><li>对于自定义组件，也就是ReactCompositeComponent而言，卸载过程需要递归地调用生命周期函数。<pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompositeComponent</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">unmout</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">var</span> publicInstance = <span class="hljs-built_in">this</span>.publicInstance        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">publicInstance</span>)</span>&#123;            <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">publicInstance.componentWillUnmount</span>)</span>&#123;                publicInstance.componentWillUnmount()            &#125;        &#125;        <span class="hljs-keyword">var</span> renderedComponent = <span class="hljs-built_in">this</span>.renderedComponent        renderedComponent.unmount()    &#125;&#125;</code></pre></li><li>对于ReactDOMComponent，卸载子元素需要清楚事件监听器并清理一些缓存。<pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DOMComponent</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">unmount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">var</span> renderedChildren = <span class="hljs-built_in">this</span>.renderedChildren        renderedChildren.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> child.unmount())    &#125;&#125;</code></pre>从以上的流程我们可以看出，React渲染的整体策略是<strong>递归</strong>，并通过事务建立React与虚拟DOM的联系并完成调度。</li></ol><p>整体的函数调用流程可查看<a href="https://bogdan-lyashenko.github.io/Under-the-hood-ReactJS/stack/images/intro/all-page-stack-reconciler.svg">全景大图</a></p><h5 id="2-2-Fiber-Reconciler"><a href="#2-2-Fiber-Reconciler" class="headerlink" title="2.2 Fiber Reconciler"></a>2.2 Fiber Reconciler</h5><p>首先，要理解什么是Fiber?</p><p><strong>Fiber</strong></p><p>在系统开发中，指<strong>一种最轻量化的线程</strong>。与一般线程不同的是，Fiber对于系统内核是不可见的，也不能由内核进行调度。它的运行模式被称为<strong>协作式多任务</strong>；而线程采用的是<strong>抢占式多任务</strong>。</p><ul><li>在协作式多任务模式下，线程会定时放弃自己的运行权利，告知内核让下一个线程运行；</li><li>在抢占式下，内核决定调度方案，可以直接剥夺长耗时线程时间片，提供给其他线程。</li></ul><p>回到浏览器中，浏览器无法实现抢占式调度，为了提升可用性与流畅度，React在设计上只能采用协作式调度的方案：将渲染任务拆分为多段，每次只执行一段，完成后就把时间控制权还给主线程。这就是Fiber Reconciler得名的原因。</p><p>在Fiber Reconciler还引入了两个新的概念，分别是Fiber与effect:</p><ul><li>在React Element的基础上，通过createFiberFromElement函数创建Fiber对象。Fiber对象不仅包括ReactElement，还包含了指向父、子、兄弟节点的属性，保证Fiber构成的虚拟DOM树成为一个双向链表。</li><li>effect是指在协调过程中必须执行计算的活动。</li></ul><p>在了解了Fiber是什么之后，我们就可以进入Fiber Reconciler的协调过程了。</p><p><strong>协调</strong></p><p>React团队画了一张基于Fiber Reconciler生命周期阶段图，其中协调过程被分为两个部分：Render 和 commit<br><img src="https://pic.imgdb.cn/item/60e955455132923bf8f17f6e.jpg"></p><ol><li><p>Render阶段</p><p>Render阶段主要通过构造workInProgress树计算出diff。以current树为基础，将每个Fiber作为一个基本单位，自下而上逐个节点检查并构造workInProgress树。这个过程不再是递归，而是基于<strong>循环</strong>完成。</p><p>在执行上通过requestIdleCallback来调度执行每组任务，每组中的每个计算任务被称为work，每个work完成后会确认是否由优先级更高的work需要插入。如果有就让位，没有就继续。优先级通常标记为动画或high的会先处理。每完成一组后，将调度全交回主线程，直到下一次requestIdleCallback调用，再继续构建workInProgress树。</p></li><li><p>Commit阶段</p><p> 在Commit阶段处理effec列表，这里的effect列表包含了根据diff更新DOM树，回调生命周期、响应ref等。</p><p> 但是一定要注意，这个阶段是同步执行的，不可中断暂停。所以不要在componentDidMount、componentDidUpdate、componentWillUnmount中执行重度消耗算力的任务。</p></li></ol><p>在上面的讲述中，省去了挂载与更新流程。其实在挂载阶段，ReactMount模块已经不存在了，是直接构造Fiber树。而更新流程大致一样，依然通过IsBatchingUpdates控制。那么Fiber Reconciler与Stack Reconciler最大的不同有两点：</p><ul><li>协作式多任务模式</li><li>基于循环遍历计算diff</li></ul><p><strong>答题</strong></p><blockquote><p>React的渲染过程大致一致，但是协调并不相同。以React16为分界线，分为Stack Reconciler和Fiber Reconciler。这里的协调从狭义上说，特指React的diff算法。广义上说，有时候也指React的reconciler模块，它通常包含了diff算法和一些公共逻辑。</p></blockquote><blockquote><p>1.Stack Reconciler的核心调度是递归。调度的基本单位是事务，它的事务基类是Transaction，这里的事务是React团队从后端开发中引入的概念。在React16以前，挂载主要通过ReactMount模块完成，更新通过ReactUpdate模块完成，模块之间相互分离，落脚执行点也是事务。</p></blockquote><blockquote><p>2.在React16以后，协调改为了Fiber Reconciler。它的调度方式有两个特点：第一个是协作式多任务模式。这个模式下，线程会定时放弃自己的运行权利，交还给主线程，通过requestIdleCallback实现。第二个特点式策略优先级，调度任务通过标记tag的方式分优先级执行，比如动画或者优先级标为high的任务可以先执行。Fiber Reconciler的基本单位是Fiber, Fiber基于过去的React Element提供了二次封装，提供了指向父、子、兄弟节点的引用，为diff工作的双链表实现提供了基础。</p></blockquote><blockquote><p>在Fiber Reconciler架构下，整个生命周期被划分为Render和Commit两个阶段。Render阶段的执行特点是可中断、可停止、无副作用，主要是通过构造workInProgress树计算出diff。以current树为基础，将每个Fiber作为一个基本单位，自下而上逐个节点检查并构造workInProgress树，这个过程不再是递归，而是基于循环实现。<br/><br>在执行上通过requestIdleCallback来调度执行每组任务，每组中的每个计算任务被称为work，每个work完成后确认是否有优先级更高的work需要插入。如果有让位，没有就继续。优先级通常是标记为动画或者high的会优先处理。每完成一组后，将调度权交回主线程，直到下一次requestIdleCallback调用，再继续构建workInProgress树</p></blockquote><blockquote><p>在commit阶段需要处理effect列表,这里的effect列表包含了根据diff更新DOM树、回调生命周期、响应ref等。</p></blockquote><blockquote><p>但是一定要注意，这个阶段是同步执行的，不可中断暂停。所以不要在componentDidMount/componentDidUpdate/componentWillUnmount中执行重度消耗算力的任务。</p></blockquote><blockquote><p>如果只是一般的应用场景，比如管理后台、H5展示页。两者的性能差距不大，但是在动画、画布以及手势风场景下，Stack Reconciler的设计回占用主线程，造成卡顿。而Fiber Reconciler的设计则会带来高性能表现。</p></blockquote><p><img src="https://pic.imgdb.cn/item/60e7b47e5132923bf81de246.jpg" alt="React渲染流程"></p><p><strong>补充：</strong><br><strong>为什么Stack Reconciler模式下render函数不支持return数组？</strong></p><p>答：Stack Reconciler采用的是递归遍历的模式，那么在递归情况下只能返回一个节点元素，肯定就不支持数组了。</p>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试10-React的diff算法有何特点？</title>
    <link href="/2021/07/03/%E9%9D%A2%E8%AF%9510-React%E7%9A%84diff%E7%AE%97%E6%B3%95%E6%9C%89%E4%BD%95%E7%89%B9%E7%82%B9%EF%BC%9F/"/>
    <url>/2021/07/03/%E9%9D%A2%E8%AF%9510-React%E7%9A%84diff%E7%AE%97%E6%B3%95%E6%9C%89%E4%BD%95%E7%89%B9%E7%82%B9%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="面试场景10：与其他框架相比，React的diff算法有何不同？"><a href="#面试场景10：与其他框架相比，React的diff算法有何不同？" class="headerlink" title="面试场景10：与其他框架相比，React的diff算法有何不同？"></a>面试场景10：与其他框架相比，React的diff算法有何不同？</h3><p><strong>破题</strong>：<br>一般说到前端框架，主要有两个：</p><ul><li>Vue，国内用的比较广泛</li><li>类React框架（React-like框架），通常指Preact/inferno等兼容React API的框架，它们与react设计相似、使用相似。</li></ul><p>所以我们就拿Vue以及Preact与React的diff算法进行比较。</p><p><strong>承题</strong>：<br>如上，我们可以整理出一个答题框架：</p><ol><li>就React diff算法完成“讲概率，说用途，理思路，优缺点，列一遍”的组合拳</li><li>横向对比React、React-like框架以及Vue的diff算法</li></ol><p><img src="https://pic.imgdb.cn/item/60e052645132923bf82f0ed1.jpg" alt="diff算法对比思维导图"></p><h4 id="一、React的Diff算法"><a href="#一、React的Diff算法" class="headerlink" title="一、React的Diff算法"></a>一、React的Diff算法</h4><p>diff算法探讨的是虚拟DOM树发生变化后，生成DOM树更新补丁的方式。塔通过对比新旧两棵虚拟DOM树的变更差异，将更新补丁作用于真实DOM，以最小成本完成视图更新。</p><p><img src="https://pic.imgdb.cn/item/60e053385132923bf8332c28.jpg" alt="diff算法的流程"></p><p>具体的流程是这样的：</p><ul><li>真实DOM与虚拟DOM之间存在一个映射关系。这个映射关系依靠初始化时的JSX建立完成。</li><li>当虚拟DOM发生变化后，就会根据差距计算生成一个patch，这个patch是一个结构化的数据，内容包含了增加、更新、移除等。</li><li>最后再根据patch去更新真实的DOM，反馈到用户的界面上。</li></ul><p><img src="https://pic.imgdb.cn/item/60e054885132923bf839c0c3.jpg" alt="diff算法的具体流程"></p><p><strong>生成补丁、更新差异</strong>的过程统称为diff算法。</p><p>在整个过程中最重要的三点:<strong>更新时机、遍历算法、优化策略</strong>。（也是面试中经常问的点）</p><p><font color='red'>1、更新时机</font></p><p>更新时机就是触发更新、进行差异对比的时机。更新一般发生在setState、Hooks调用等操作以后。此时，树的结点发生变化，开始进行对比。<br><br/><br>那么新旧两颗树是如何进行对比差异的呢？这里就需要使用遍历算法。</p><p><font color='red'>2、遍历算法</font></p><p>遍历算法是指沿着某条搜索线路，依次对树的每个节点进行访问。通常有两种：</p><ul><li>深度优先遍历，是从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树节点的遍历，直到遍历完所有可达节点。</li><li>广度优先遍历，则是从根节点出发，在横向遍历二叉树层段节点的基础上，纵向遍历二叉树的层次。</li></ul><p>React的diff算法采用的是<strong>深度优先遍历算法</strong>。因为广度优先遍历可能会导致组件的生命周期时序错乱。</p><p><font color='red'>3、优化策略</font></p><p>优化策略是指React对diff算法做的优化手段。</p><p>虽然深度优先遍历保证了组件的生命周期时序不错乱，但传统的 diff 算法也带来了一个严重的性能瓶颈，复杂程度为 O(n^3)，其中 n 表示树的节点总数。正如计算机科学中常见的优化方案一样，React 用了一个非常经典的手法将复杂度降低为 O(n)，也就是分治，即通过“分而治之”这一巧妙的思想分解问题。</p><p>具体来说，React分别从<strong>树、组件、元素</strong>三个层面进行复杂度的优化，并诞生了与之对应的策略。</p><p><strong>策略一：忽略节点跨层级操作场景，提升对比效率</strong></p><p>树对比的处是很暴力的：两棵树只对同一层次的节点进行比较，如果发现节点已经不存在了，则该节点及其子节点会被完全删除，不会再进一步比较。这就提升了对比效率</p><p><strong>策略二：如果组件的类型（classComponent）一致，则默认为相似的树结构，否则默认为不同的结构</strong></p><p>在组件对比的过程中：</p><ul><li>如果组件是同一类型则进行树对比；</li><li>如果不是则直接放入补丁中。</li></ul><p>只要父组件类型不同，就会被重新渲染。这也就是为什么shouldComponentUpdate、PureComponent及React.memo可以提升性能的原因。</p><p><strong>策略三：同一层级的子节点，可以通过标记key的方式进行列表对比</strong></p><p>元素的比对主要发生在同一层级中，通过<strong>标记节点操作生成补丁</strong>。节点操作包含了插入、移动、删除等。其中节点重新排序同时涉及插入、移动、删除三个操作，所以效率消耗最大，此时策略三起重要作用。</p><p>通过标记key的方式，React可以直接移动DOM节点，降低内耗。操作代码如下：</p><pre><code class="hljs js">&lt;ul&gt;    &lt;li key=<span class="hljs-string">&#x27;a&#x27;</span>&gt;a&lt;/li&gt;    &lt;li key=<span class="hljs-string">&#x27;b&#x27;</span>&gt;b&lt;/li&gt;    &lt;li key=<span class="hljs-string">&#x27;c&#x27;</span>&gt;c&lt;/li&gt;&lt;/ul&gt;</code></pre><p>以上就是React diff算法的基本内容。 除此之外，React16还引入了Fiber设计，所以还需要了解Fiber对diff算法带来的影响。</p><p>Fiber机制下节点与树分别采用FiberNode与FiberTree进行重构。<strong>FiberNode使用了双链表结构，可以直接找到兄弟节点与子节点，使得整个更新过程可以随时暂停恢复。</strong>FiberTree则是通过FiberNode构成的树。</p><p>Fiber机制下，整个更新过程由current与workInProgress两颗树双缓冲完成。当workInProgress更新完成后，通过修改current相关指针指向的节点，直接抛弃老树，虽然非常简单粗暴，但是很合理。</p><h4 id="二、其他框架中的diff算法"><a href="#二、其他框架中的diff算法" class="headerlink" title="二、其他框架中的diff算法"></a>二、其他框架中的diff算法</h4><h5 id="2-1-Preact"><a href="#2-1-Preact" class="headerlink" title="2.1 Preact"></a>2.1 Preact</h5><p>在众多的react-like框架中，Preact使用范围最广，生命力最强。它仅以3kb的小巧特点应用于对体积追求非常极致的场景。也正因为体积受限，Preact在diff算法上做了裁剪。</p><p>以下是Preact的diff算法图示，可以看到它将diff分为三个类型：Fragment、Component及DOM Node</p><p><img src="https://pic.imgdb.cn/item/60e06b375132923bf8b8d672.jpg" alt="Preact的diff算法"></p><ul><li>Fragment对应React的树比较</li><li>Component对应组件比较，它们在原理上是相通的。</li><li>最大的不同在于DOM Node这一层，Preact并没有patch的过程，而是直接更新DOM节点属性。</li></ul><h5 id="2-1-Vue"><a href="#2-1-Vue" class="headerlink" title="2.1 Vue"></a>2.1 Vue</h5><p>Vue 2.0 因为使用了<a href="https://github.com/snabbdom/snabbdom/tree/8079ba78685b0f0e0e67891782c3e8fb9d54d5b8">snabbdom</a>，整体思路和React相同。但是在元素对比时，如果新旧两个元素是同一个元素，且没有设置key时，snabbdom在diff子元素中会一次性对比<strong>旧节点、新节点</strong>以及它们的<strong>首尾元素</strong>四个节点，以及验证列表是否有变化。依然没有引入Fiber等设计，也没有时间切片等功能。</p><p><strong>答题：</strong></p><blockquote><p>首先说明下什么是diff算法：diff算法是指生成更新补丁的方式，主要应用于虚拟DOM树变化后，更新真实DOM。所以diff算法一定存在这样一个过程：触发更新-&gt;生成补丁-&gt;应用补丁。</p></blockquote><blockquote><p>React的diff算法，触发更新的时机主要是在state变化与hooks调用之后。此时触发虚拟DOM树变更遍历，采用了深度优先遍历算法。但是传统的树遍历方式，效率低。为了优化效率，使用了分治的方法。将单一节点对比转化为了3种类型的节点对比，分别是树、组件、元素，以此提升效率。<br/><br>1、树对比：由于网页视图中较少有跨层级节点移动，两颗虚拟DOM树只对同一层级的节点进行对比。<br/><br>2、组件对比：如果组件是同一类型，则进行树对比；如果不是，则直接放入补丁中。<br/><br>3、元素对比：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的DOM剪裁操作。</p></blockquote><blockquote><p>自React 16起，引入了Fiber架构。为了使整个更新过程可以随时暂停恢复，节点与树分别采用了FiberNode与FiberTree进行重构。FiberNode使用了双链表的结构，可以直接找到兄弟节点与子节点。  整个更新过程由current和workInProgress两棵树双缓冲完成。workInProgress更新完成后，再通过修改current相关指针指向新节点。</p></blockquote><blockquote><p>Preact的diff算法相较于React，整体思路相似。但最底层的元素采用了真实DOM对比操作，也没有采用Fiber设计。<br/><br>Vue的diff算法整体也与React相似，同样未实现Fiber设计。</p></blockquote><blockquote><p>最后，关于适用场景：<br/><br>React拥有完整的diff算法策略，且拥有随时中断更新的时间切片能力，在大批量节点更新的极端情况下，拥有更友好的交互体验。<br/><br>Preact可以在一些对性能要求不高，仅需要渲染框架的简单场景下适用。<br/><br>Vue的整体diff策略与React对齐，虽然缺乏时间切片能力，但并不意味着Vue的性能更差。（Vue3初期其实引用过，后面因为收益不高除掉了）除了高帧率动画，在Vue中其他的场景机会都可以适用防抖和节流去提高响应性能。</p></blockquote><p>备注：回答时切忌踩一捧一！</p><p><img src="https://pic.imgdb.cn/item/60e11ac65132923bf83aefac.jpg" alt="diff算法的对比答题思维导图"></p><p><font color='blue'>补充：</font></p><p><strong>如何根据React diff算法原理优化代码呢？</strong></p><p>答：</p><ul><li>根据diff算法的设计原则，应尽量避免跨层级节点移动</li><li>通过设置唯一key进行优化，尽量减少组件层级深度。因为过深的层级会加深遍历深度，带来性能问题。</li><li>设置shouldComponentUpdate或者React.pureComponent减少diff次数。</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试09-虚拟dom的工作原理是什么？</title>
    <link href="/2021/03/21/%E9%9D%A2%E8%AF%9509-%E8%99%9A%E6%8B%9Fdom%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <url>/2021/03/21/%E9%9D%A2%E8%AF%9509-%E8%99%9A%E6%8B%9Fdom%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="面试场景9：Virtual-DOM的工作原理是什么？"><a href="#面试场景9：Virtual-DOM的工作原理是什么？" class="headerlink" title="面试场景9：Virtual DOM的工作原理是什么？"></a>面试场景9：Virtual DOM的工作原理是什么？</h3><p><strong>破题</strong>：</p><p>  Virtual DOM,简称VDOM，也被称为虚拟DOM。在<a href="https://dengcpu.github.io/2020/12/02/%E9%9D%A2%E8%AF%9502-%E4%B8%BA%E4%BB%80%E4%B9%88React%E8%A6%81%E7%94%A8JSX%EF%BC%9F/">面试场景2：“为什么React要用JSX”</a>中，我们已经提到了，为了更便捷高效地使用声明式开发组件，引入了XML语法结构的JSX。JSX经过编译后会生成类似React.createElement函数包裹标签及属性。那么这里的React.createElement函数所返回的就是一个虚拟DOM。虚拟DOM并不是只有React才有，只是经过React的发扬光大，变得很流行。  同样地，vue从1.0到2.0，最大的变化就是引入了虚拟DOM。那么虚拟DOM为什么能够引起关注，触发流行呢？</p><p>  <strong>承题</strong>：</p><p>  <img src="https://pic.imgdb.cn/item/60de89615132923bf8f3206c.jpg" alt="虚拟DOM工作原理思维导图"></p><p>答题的框架如上图所示，除了基础部分的“讲说理列”之外，还要尽量回答出虚拟DOM流行的原因。</p><h4 id="一、虚拟DOM的由来-（历史）"><a href="#一、虚拟DOM的由来-（历史）" class="headerlink" title="一、虚拟DOM的由来 （历史）"></a>一、虚拟DOM的由来 （历史）</h4><p>React的原型是XHP，FaceBook创建XHP的目的主要有两点：</p><ol><li><strong>简化前端开发</strong>，按照现在流行的说法叫后端赋能，让后端开发人员可以快速交付页面。</li><li><strong>避免跨站点脚本攻击</strong>，也就是避免XSS攻击。XSS不会直接攻击网页，而是通过嵌入JS代码的方式，将恶意攻击附加到用户的请求中来攻击用户。它可以别用作窃取用户信息，或者恶意增删用户的一些资料。而XHP的优势在于默认启用XSS把保护。</li></ol><p>所有的页面在XHP中构建完成，并没有直接的HTML，都是通过<strong>转义的方式</strong>生成的。这样的过程确保可以在XHP中写出安全的静态页面，但是如果需要构建动态的网页应用就会出现一些问题。一旦状态发生更改，网页就需要重新渲染，从而丢失之前网页中的信息。Facebook团队意识到，这个问题对也页面性能和用户体验来说是非常糟糕的。这就使得他们产生了思考：为什么仅仅因为状态的改变，就不得不重新渲染整个页面？   最后出现了React的最初构想：不再基于XHP，而是基于JS的用户界面搭建。<br>…<br>回顾这段历史，就会发现Facebook一开始的初衷是<strong>简化前端开发、防止XSS</strong>。它的解决方案也很粗暴，就是不要直接操作DOM，而是通过虚拟DOM规避风险。因为直接操作DOM可能会带来XSS的风险，也可能因为技术水平的限制带来性能问题。如果你不想让一个东西被外人触碰，最好的方式就是把它封起来，与使用者隔离，这就是我们今天看到的虚拟DOM。</p><h4 id="二、虚拟DOM到底长什么样子？"><a href="#二、虚拟DOM到底长什么样子？" class="headerlink" title="二、虚拟DOM到底长什么样子？"></a>二、虚拟DOM到底长什么样子？</h4><p>先整理下之前关于虚拟DOM的内容：</p><ul><li><p>在JSX的使用中，JSX所描述的结构会被转移为React.createElement函数，大致像这样：</p><pre><code class="hljs js"><span class="hljs-comment">// JSX描述</span>&lt;input type=<span class="hljs-string">&quot;button&quot;</span> /&gt;<span class="hljs-comment">//Babel 转译后</span>React.createElement(<span class="hljs-string">&#x27;input&#x27;</span>,&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&quot;button&quot;</span>&#125;)</code></pre></li><li><p>React会持有一棵虚拟DOM树，在状态更新后，会触发虚拟DOM树的修改，再以此为基础修改真实DOM。</p></li></ul><p>根据上述条件，可以很快得出结论：React.createElement的返回结果应该是一个JS Object。由于是树结构，所以一定包含一个children字段，来建立与子级的关系。所以可以推测出它的结构像下面这样：</p><pre><code class="hljs js"><span class="hljs-comment">// 推测出的DOM结构</span>&#123;    tag: <span class="hljs-string">&#x27;input&#x27;</span>,    props: &#123;        type: <span class="hljs-string">&#x27;button&#x27;</span>    &#125;,    children: []&#125;</code></pre><p>基于基本认知，React有两个函数：</p><ul><li>diff函数，去<strong>计算</strong>状态变更前后的虚拟DOM树差异；</li><li>渲染函数，<strong>渲染</strong>整个虚拟DOM树或者处理差异结点。</li></ul><p>现在应该可以理解为什么有React和ReactDOM两个库了。正是由于计算与渲染的分工，在日常的开发中，需要同时引入React和ReactDOM两个库：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>));</code></pre><p>其中React库主要的工作是组件实现、更新调度；而ReactDOM提供了在网页上渲染的基础。</p><p>也正是因为这样的划分，当React向ios/Android开发时，只需要通过React Native提供Native层的元素渲染即可完成。</p><h4 id="三、虚拟DOM的优势"><a href="#三、虚拟DOM的优势" class="headerlink" title="三、虚拟DOM的优势"></a>三、虚拟DOM的优势</h4><p>从上面的内容进行整理，似乎可以总结出虚拟DOM有以下优势：</p><ul><li>性能优越；</li><li>规避XSS；</li><li>可跨平台</li></ul><p>但是这样笼统的回答是不合适的，有的面试官会问：“虚拟DOM一定比真实的DOM操作性能更高吗？”，其实不是！如果只是修改一个按钮的文案，那么虚拟DOM的操作无论如何都不可能比真实的DOM更快。所以，一定要回到具体的场景进行讨论。<br>如果大量的直接操作DOM则容易引起<strong>网页性能</strong>的下降，这时React基于虚拟DOM的diff处理与批处理操作，可以降低DOM的操作范围与频次，提升页面性能。在这样的场景下虚拟DOM就比较快，但是像<font color='green'>首次渲染或微量操作</font>，虚拟DOM的渲染速度就会比真实DOM更慢！（这里可参考 <a href="https://www.zhihu.com/question/31809713/answer/53544875">虚拟DOM一定比真实DOM性能好吗？-尤雨溪的回答</a></p><p>那么虚拟DOM一定可以<strong>规避XSS</strong>吗？虚拟DOM内部确保了字符转义，所以确实可以做到这点，但是React存在风险，因为React留有dangerousSetInnerHTMLAPI绕过转义。</p><p>没有虚拟DOM不能实现<strong>跨平台</strong>吗？比如NativeScript没有虚拟DOM层，它是通过提供兼容原生API的JS API实现跨平台开发。那么虚拟DOM的优势在哪里？实际上，虚拟DOM真正的优势在于<font color='green'>跨平台的成本更低</font>。在React Native之后，前端社区从虚拟DOM中体会到了跨平台的无限前景，所以在后续的发展中，都借鉴了虚拟DOM。比如：社区流行的小程序同构方案，在构建过程中会提供类似虚拟DOM的结构描述对象，来支撑多端转换。</p><h4 id="四、虚拟DOM的缺点"><a href="#四、虚拟DOM的缺点" class="headerlink" title="四、虚拟DOM的缺点"></a>四、虚拟DOM的缺点</h4><p>社区公认的虚拟DOM缺点主要有两个：</p><ul><li><strong>内存占用较高</strong>。因为当前网页的虚拟DOM包含了真实DOM的完整信息，而且由于是Object，其内存占用肯定会有所上升。</li><li><strong>无法进行极致优化</strong>。虽然虚拟DOM足以应对绝大部分应用的性能需求，但在一些性能要求较高的应用中，虚拟DOM取法进行针对性的极致优化。比如，类似于Google Earth的场景。</li></ul><p><strong>答题：</strong></p><blockquote><p>虚拟DOM的<strong>工作原理</strong>是通过JS对象模拟DOM的节点。在Facebook构建React初期时，考虑到要提升代码抽象能力、避免认为的DOM操作、降低代码整体风险等因素，所以引入了虚拟DOM。</p></blockquote><blockquote><p>虚拟DOM的<strong>实现</strong>通常时Plain Object,以React为例，在render函数中写的JSX会在Babel插件的作用下，编译为React.createElement执行JSX中的属性参数。<br>React.createElement执行完后会返回一个Plain Object，它会描述自己的tag类型、props属性以及children情况等。这些Plain Object通过树结构组成一颗虚拟DOM树。当状态发生变更时，将变更前后的虚拟DOM树进行差异对比，这个过程叫diff，生成的结果叫patch。计算之后，会渲染patch完成对真实DOM的操作。</p></blockquote><blockquote><p>虚拟DOM的<strong>优点</strong>主要有三点：改善大规模DOM操作的性能、规避XSS风险、能以较低的成本实现跨平台开发。<br>虚拟DOM的<strong>缺点</strong>在社区中主要有两点：1.内存占用较高，因为需要模拟整个网页的真实DOM。2.高性能应用场景存在难以优化的情况，类似于Google Earth等高性能应用在技术选型上往往不会选择React。</p></blockquote><p><img src="https://pic.imgdb.cn/item/60dec8d85132923bf883ec77.jpg" alt="虚拟DOM工作原理解答"></p><p>补充：<br>除了渲染页面，虚拟DOM还有哪些应用场景？<br>答：只要记录了真实DOM变更，虚拟DOM甚至还可以应用于<strong>埋点统计</strong>与<strong>数据记录</strong></p>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS02-深入理解JS事件循环机制</title>
    <link href="/2021/03/02/JS02-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/03/02/JS02-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p><strong>事件循环Event Loop的几个要点：</strong></p><ol><li><p>JavaScript是单线程，非阻塞的。</p></li><li><p>浏览器的事件循环：</p><ul><li>执行栈和任务队列</li><li>宏任务和微任务</li></ul></li><li><p>node环境下的事件循环：</p><ul><li>和浏览器环境有何不同</li><li>事件循环模型</li><li>宏任务和微任务</li></ul></li></ol><h3 id="一、为什么JavaScript是单线程的？"><a href="#一、为什么JavaScript是单线程的？" class="headerlink" title="一、为什么JavaScript是单线程的？"></a>一、为什么JavaScript是单线程的？</h3><p>JS语言的一大特点就是单线程，也就是说，同一时间只能做一件事。那为什么JS不能有多个线程呢？</p><p>JS的单线程与它的用途有关。<strong>JS作为浏览器脚本语言，它的主要用途是和用户互动，以及操作DOM</strong>。这决定了它只能是单线程，否则将会带来复杂的同步问题。比如，假设JS有两个线程，一个线程在某个DOM节点上添加了内容，另一个进程删除了节点，这时浏览器应该以哪个进程为主呢？</p><p>所以，为了避免复杂性，从诞生起，JS就是单线程，这已经成为了这门语言的核心特征，将来也不会改变。</p><p>🐖：为了利用多核CPU的计算能力，H5提出Web Worker标准，允许JS脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以这个标准并没有改变JS单线程的本质。</p><h3 id="二、任务队列"><a href="#二、任务队列" class="headerlink" title="二、任务队列"></a>二、任务队列</h3><p>单线程就意味着，所有任务需要排队，前一个任务结束，后一个任务才能被执行。如果有一个任务执行耗时很长，后面的任务就不得不一直等着。</p><p>因为IO设备很慢（比如Ajax操作从网络读取数据），不得不等着结果出来再往下执行，这时CPU其实是空闲的。JS语言的设计者意识到，这种情况主线程可以不管IO设备，挂起等待中的任务，先运行排再后面得任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。</p><p>于是，所有任务可以分为两种：</p><ul><li>同步任务（synchronous）：主线程上排队的任务，只有前一个任务执行完毕，才能执行后一个任务。</li><li>异步任务（asynchronous）：不进入主线程，而进入“任务队列（task queue）”，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。比如，Ajax请求，setTimeout，setInterval ，promise，mutationObserver等</li></ul><p>异步执行的运行机制如下：（同步任务其实也是如此，它可以被看做是没有异步任务的异步执行）</p><p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）<br>（2）主线程之外，还存在一个任务队列。只要异步任务有了运行结果，就在任务队列种放置一个事件<br>（3）一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，就结束等待状态，进入执行栈，开始执行。<br>（4）主线程不断重复第（3）步</p><p><img src="https://img.imgdb.cn/item/603e2cae360785be54499c57.jpg" alt="事件循环机制"></p><p>只要主线程空了，就会去读取“任务队列”，这就是JS的运行机制。这个过程会不断重复，因此叫做Event Loop（事件循环）</p><p>任务队列中的异步任务又分为：宏任务和微任务。宏任务可以认为是<strong>宿主（浏览器）</strong>发起的异步请求的处理结果，微任务是由<strong>JS引擎</strong>发起的异步请求的处理结果。</p><ul><li>宏任务（Macro Task）：setTimeout/setInterval，Ajax，整体的script代码，I/O，UI交互事件，setImmediate(node.js环境)</li><li>微任务（Micro Task）：Promise，async/await，MutationObserver，process.nextTick(node.js环境)</li></ul><p>🐖：<strong>微任务的优先级是高于宏任务的</strong>，在同一个事件循环中，主线程只有在执行完微任务队列里的任务，才会执行宏任务队列里的任务。<br><img src="https://img.imgdb.cn/item/603e2f50360785be544a9058.jpg" alt="event loop"></p><p>（上图中的web api可以理解为一些异步事件，任务队列中的异步任务可以理解为这些异步事件返回的结果）</p><p>基于以上，JS事件循环机制中的某次循环细分为：</p><ul><li>执行栈中同步任务执行完毕</li><li>微任务队列执行（清空微任务队列）</li><li>渲染DOM</li><li>宏任务队列执行（清空宏任务队列）</li><li>..进入下次循环..直至js代码执行完毕 </li></ul><h3 id="三、事件和回调函数"><a href="#三、事件和回调函数" class="headerlink" title="三、事件和回调函数"></a>三、事件和回调函数</h3><p>“任务队列”是一个事件的队列，IO设备完成一项任务，就在任务队列中添加一个事件，表示相关的异步任务可以进入“执行栈”了。主线程读取“任务队列”，就是读取里面有哪些事件。</p><p>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击，页面滚动等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。</p><p>所谓“回调函数”，就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p><p>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，“任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的“定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。</p><h3 id="四、定时器"><a href="#四、定时器" class="headerlink" title="四、定时器"></a>四、定时器</h3><p>除了放置异步任务的事件，“任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。这就叫做“定时器”（timer)功能，也就是定时执行的代码。</p><p>定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部机制完全一样。下面以setTimeout为例。</p><p>如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。</p><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);&#125;,<span class="hljs-number">0</span>);<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<span class="hljs-comment">//输出 2，1</span><span class="hljs-comment">//只有执行完第四行之后，系统才会执行“任务队列”中的回调函数。</span></code></pre><p>总之，<code>setTimeout(fn,0)</code>的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在任务队列的尾部添加一个事件，因此要等到同步任务和任务队列中的现有事件都处理完，才会得到执行。</p><p>🐖：setTimeout()只是将事件插入了任务队列，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，<strong>所以没办法保证，回调函数一定会在setTimeout()指定的时间执行</strong>。</p><p>参考：<br>1.<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">阮一峰–JavaScript运行机制详解：再谈Event Loop</a><br>2.<a href="https://www.cnblogs.com/yugege/p/9598265.html">深入理解JavaScript事件循环机制</a><br>3.<a href="https://blog.csdn.net/weixin_44366733/article/details/109633119">Js事件循环(Event Loop)</a></p>]]></content>
    
    
    <categories>
      
      <category>JS学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS布局05-定位position</title>
    <link href="/2021/02/10/CSS%E5%B8%83%E5%B1%8005-%E5%AE%9A%E4%BD%8Dposition/"/>
    <url>/2021/02/10/CSS%E5%B8%83%E5%B1%8005-%E5%AE%9A%E4%BD%8Dposition/</url>
    
    <content type="html"><![CDATA[<p><strong>定位</strong>允许你从正常的文档流中取出元素，并使他们具有不同的行为，例如放在另一个元素的上面，或者始终保持在浏览器视窗内的同一位置。</p><p>定位允许我们覆盖正常的文档流行为，以产生更多的布局可能。如果我们想要创建一个浮动在页面其他部分的UI元素，并始终停留在浏览器窗口内的相同位置（无论页面滚动多少），我们就可以使用“定位”这种布局工具。</p><p>有许多不同类型的定位，即position属性有很多取值：<br><img src="https://img.imgdb.cn/item/6024e5083ffa7d37b33471bf.jpg" alt="position的取值"></p><h4 id="一、静态定位"><a href="#一、静态定位" class="headerlink" title="一、静态定位"></a>一、静态定位</h4><p>静态定位是每个元素获取的默认值——它只表示“将元素放入它在文档布局流中的正常位置”，没什么特别的。</p><p>静态定位是默认行为！</p><h4 id="二、相对定位"><a href="#二、相对定位" class="headerlink" title="二、相对定位"></a>二、相对定位</h4><p>相对定位与静态定位非常相似，占据在正常的文档流中。仅仅使用<code>position: relative</code>，文档布局不会发生任何变化，它一般和top、bottom、left和right属性搭配使用。</p><p><strong>介绍top,bottom,left和right属性</strong></p><p>top、bottom、left和right用来精确指定元素移动到的位置。这些属性的值可以采用逻辑上期望的任何单位：px、rems、% 等</p><p>举个例子：现在有俩上下排列的盒子<br>HTML文件</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>CSS文件</p><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">background-color</span>: skyblue;&#125;<span class="hljs-selector-class">.box2</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">background-color</span>: pink;&#125;</code></pre><p>排版如下：<br><img src="https://img.imgdb.cn/item/6024e80e3ffa7d37b335c2ff.jpg"><br>现在我们将box1设置一个相对定位：</p><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;    <span class="hljs-attribute">position</span>: relative;    <span class="hljs-attribute">top</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">left</span>: <span class="hljs-number">50px</span>;&#125;</code></pre><p>现在排版如下：<br><img src="https://img.imgdb.cn/item/6024e9203ffa7d37b3363c48.jpg"></p><p>🐖 <code>top:50px;</code>指距离顶部50px, <code>left:50px;</code>指距离左边50px;</p><h4 id="三、绝对定位"><a href="#三、绝对定位" class="headerlink" title="三、绝对定位"></a>三、绝对定位</h4><p>绝对定位absolute和浮动float有相似之处：<strong>包裹性</strong>和<strong>高度欺骗</strong></p><h5 id="3-1-包裹性"><a href="#3-1-包裹性" class="headerlink" title="3.1 包裹性"></a>3.1 包裹性</h5><p>看一个例子：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border:4px solid blue;&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/25/1.jpg&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border:4px solid red; position: absolute;&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/25/2.jpg&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>效果如下：<br><img src="https://img.imgdb.cn/item/60331a065f4313ce257124f8.jpg" alt="绝对定位的包裹性"></p><p>一旦给元素加上absolute和float，就相当于给元素加上了<code>display: block;</code> 比如一个内联元素span，本身是无法直接指定高度的，但是给span加上absolute或者是float后，span的属性就自动变为block了。</p><h5 id="3-2-高度欺骗"><a href="#3-2-高度欺骗" class="headerlink" title="3.2 高度欺骗"></a>3.2 高度欺骗</h5><p>上例中给图片外层的div加上absolute，现在将absolute移到内部图片上，高度欺骗的效果就出来了：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border:4px solid blue;&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/25/1.jpg&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border:4px solid red;&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position: absolute;&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/25/2.jpg&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><img src="https://img.imgdb.cn/item/60331c9b5f4313ce2572810e.jpg" alt="绝对定位的高度欺骗效果"></p><p>参照<a href="https://www.jianshu.com/p/07eb19957991">博客-CSS浮动float详解</a>,会发现float和absolute的效果是一样的，但是两者背后的原理是有区别的。加点文字就看出来了：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border:4px solid blue;&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/25/1.jpg&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border:4px solid red;&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position: absolute;&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/25/2.jpg&quot;</span> /&gt;</span>  我是一个绝对定位的absolute元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><img src="https://img.imgdb.cn/item/60331d7f5f4313ce2573161a.jpg"></p><p>显然，文字被图片遮盖了，这点和float不同。float是欺骗父元素，让其父元素误以为其高度塌陷了，但float元素本身仍处于文档流中，文字会环绕着float元素，不会被遮蔽。</p><p>但是absolute不算是欺骗父元素了，而是出现了<strong>层级</strong>关系。处于正常文档流中的父元素和设置了absolute的元素已经不是一个次元上的，从父元素的视点看，设置为absolute的图片已经完全消失不见了，因此从最左边开始显示文字。而absolute的层级高，所以图片遮盖了文字。<br>有了以上基础之后，还需要了解absolute的以下特点：</p><ul><li>如何确定定位点</li><li>和relative相爱相杀</li><li>和z-index的关系</li><li>减少重绘和回流的开销</li></ul><ol><li><strong>如何确定定位点？</strong></li></ol><p>由于设置了absolute之后会出现分层，那么该让浏览器在何处显示该元素呢？普通文档流里的元素，浏览器可以根据父子兄弟的大小和位置，计算出该元素的位置。但是分层之后改怎么办？基本思路如下：</p><p><font color=green>第一种情况：</font>用户只给元素指定了absolute，未指定left/top/right/bottom。此时absolute元素的左上角定位点位置就是该元素正常文档流的位置。如上图例子中，图片熊猫是父元素的第一个孩子，因此左上角定位到就是父元素的content的左上角。</p><p>如果将熊猫图片和下面的文字顺序改一下，让其成为父元素的第二个孩子：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border:4px solid red;&quot;</span>&gt;</span>  我是一个绝对定位的absolute元素  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position: absolute;&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/25/2.jpg&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>那么排版就成了这样：<br><img src="https://img.imgdb.cn/item/6034eb355f4313ce25554119.jpg" alt="定位点"></p><p><font color=green>第二种情况：</font>用户给absolute元素指定了left/right/top/bottom</p><p>首先最简单的一种，absolute元素的父元素均是默认的position：static布局，此时absolute所处的层是铺满全屏的，即铺满body。这时，会根据用户指定位置在body上进行定位。</p><p>只指定left时,元素的左上角定位点的left值会变成用户指定值，但是top值仍旧是该元素在正常文档流中的top值：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border:4px solid red;&quot;</span>&gt;</span>  我是一个绝对定位的absolute元素  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position: absolute;left:50px;&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/25/2.jpg&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><img src="https://img.imgdb.cn/item/6034eca35f4313ce2555e0f3.jpg" alt="只指定left的定位点"></p><p>只指定top时，元素的左上角定位点的top值会变成用户指定值，但是left值仍旧是该元素在正常文档中的left值。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border:4px solid red;&quot;</span>&gt;</span>  我是一个绝对定位的absolute元素  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position: absolute;top:50px;&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/25/2.jpg&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><img src="https://img.imgdb.cn/item/6034ed405f4313ce25561b0d.jpg" alt="只指定top的定位点"></p><p>只指定bottom时，元素的<strong>左下角</strong>定位点的bottom值会变成用户指定值，但是left值仍旧是该元素在正常文档流中的left值。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border:4px solid red;&quot;</span>&gt;</span>  我是一个绝对定位的absolute元素  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position: absolute;bottom:50px;&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/25/2.jpg&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><img src="https://img.imgdb.cn/item/6034ee165f4313ce25567fbb.jpg" alt="只指定bottom时的定位点"></p><p>通过对left/top/right/bottom的组合设置，由于没有position：static以外的父元素，此时absolute元素可以去任意想去的地方。</p><ol start="2"><li><strong>和relative相爱相杀</strong></li></ol><p>通常我们对relative的认识是：它用于限制absolute，所谓“子绝（absolute）父相(relative)”。上面说了，如果absolute元素的父元素都是position：static，那么它就相对body定位，天空才是它的极限。一旦父元素被设置为relative，那么absolute子元素将<strong>相对于其父元素定位</strong>，就像是脚被绑了绳子的鸟。</p><p>举个栗子：<br>比如你要实现下图APP右上角的红圈圈：<br><img src="https://img.imgdb.cn/item/6035b1735f4313ce259f29b6.jpg"><br>通常的做法是将app图片所处的div设为relative，然后将红色圈设成absolute，再设置top/right调整即可。这样无论用户怎么改变app图片的位置，红色圈圈永远固定再右上角。<br>例如：</p><pre><code class="hljs css"><span class="hljs-selector-class">.tipIcon</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f00</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;  <span class="hljs-attribute">border-radius</span>:<span class="hljs-number">50%</span>;  <span class="hljs-attribute">text-align</span>: center;  <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;  right:-10px;  //负值为自身体积的一半  <span class="hljs-selector-tag">top</span><span class="hljs-selector-pseudo">:-10px</span>;&#125;</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: inline-block;position:relative;&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/25/2.jpg&quot;</span> /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tipIcon&quot;</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><img src="https://img.imgdb.cn/item/6035b25a5f4313ce259f99ba.jpg"></p><p>这种实现方法是可行的，兼容性也ok。但是CSS世界里要实现一个效果可以有很多种方式，具体选哪个方案要视情况而定。一般遵循的原则是：1.简洁 2.尽量让每个属性干其本职工作。用这两个标准看上诉实现，其实是可以改进的。首先外层div多了relative未能简洁到极致。其次<strong>relative的本职工作是让元素在相对其正常文档流位置进行偏移</strong>，但是父层div并不需要任何位置偏移，之所以设成relative的唯一目的是限制absolute子元素的定位点。这其实并没有让relative干本职工作。</p><p>那么怎么改进呢？其实在上面探讨absolute定位点时说了：在未指定top/right/bottom/left的absolute元素，其在所处层级的定位点就是正常文档流中该元素的定位点。因此改进如下：</p><pre><code class="hljs css"><span class="hljs-selector-class">.tipIcon2</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f00</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;  <span class="hljs-attribute">border-radius</span>:<span class="hljs-number">50%</span>;  <span class="hljs-attribute">text-align</span>: center;  <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;  margin:-10px 0 0 -10px;   //不需要top和right了，改用margin来进行偏移&#125;&lt;div style=&quot;display: inline-block;&quot;&gt;  //父元素不需要relative了  &lt;img src=&quot;img/25/2.jpg&quot; /&gt;&lt;!-- --&gt;&lt;span class=&quot;tipIcon2&quot;&gt;6&lt;/span&gt; &lt;/div&gt;//img和soan间的HTML注释的目的是消除换行符，你也可以将span紧跟在img后面写到一行里</code></pre><p>更深入一点看，多一个属性意味着多一层维护。如果父relative+子absolute来实现定位，万一将来页面需要调整，父元素的尺寸需要变化呢？</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: inline-block; position:relative;width: 200px;&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/25/2.jpg&quot;</span> /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tipIcon&quot;</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><img src="https://img.imgdb.cn/item/6035b4ec5f4313ce25a0ca9b.jpg"></p><p>可以看到，仅仅是父元素的width变了就导致右上角absolute图标错位了。由于absolute和relative耦合在一起了，父元素有任何风吹草动，子元素就需要重新寻找定位点。但是如果用上例中absolute自身的定位特点，无论父元素怎么折腾，红色的圈圈都牢牢靠在图片的右上角。</p><p>但是absolute和relative也不应该因此断绝关系，它俩在某些功能实现上依然相爱。例如，用absolute常见的一个案例是透明层覆盖元素，要实现对全屏加一层滤镜等效果，这时应该怎么办呢?<br><img src="https://img.imgdb.cn/item/6035b67e5f4313ce25a18a40.jpg" alt="全屏滤镜"></p><pre><code class="hljs css"><span class="hljs-selector-class">.cover</span> &#123;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;    <span class="hljs-attribute">opacity</span>: .<span class="hljs-number">5</span>;    <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">alpha</span>(opacity=<span class="hljs-number">50</span>);&#125;&lt;div style=&quot;display: inline-block;&quot;&gt;  &lt;img src=&quot;img/25/2.jpg&quot; /&gt;&lt;!--  --&gt;&lt;span class=&quot;tipIcon2&quot;&gt;6&lt;/span&gt;&lt;/div&gt;现在是全屏滤镜时间&lt;span class=&quot;cover&quot;&gt;&lt;/span&gt;</code></pre><p>CSS里个细节需要关注：用absolute的<code>left:0; right:0; top:0; bottom:0;</code> 来实现全屏拉伸。对于absolute元素来说，如果同时设置left和right会水平拉伸，同时设置top和bottom会垂直拉伸。（为何不设置width/height为100%呢？前面说了，不设top/right/bottom/left的话absolute元素会从正常文档流应处的位置开始定位，因此做不到全屏。除非设置width/height为100%后，再设置left:0; top:0; 但这样会显得啰嗦。</p><p>那我如果不想全屏滤镜，只想对图片部分加滤镜呢？这时就可以使用relative了。</p><pre><code class="hljs html">//CSS部分不变<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: inline-block;position: relative;&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cover&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/25/2.jpg&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!--</span><span class="hljs-comment">  --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tipIcon2&quot;</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>现在是图片滤镜时间</code></pre><p>效果如下：<br><img src="https://img.imgdb.cn/item/6035b8985f4313ce25a26ab8.jpg" alt="图片加滤镜"></p><p><font color=red>结论：</font><br>（1）相对定位时，不必拘泥于relative+absolute，尝试去掉relative，充分利用absolute自身定位的特点，将relative+absolute解耦，耦合度越低越容易维护。<br>（2）拉伸平铺时，用relative可以有效控制子absolute元素的拉伸平铺范围（注意是拉伸，不是缩小，缩小需要再加上width/height：100%）</p><ol start="3"><li><strong>和z-index的关系</strong></li></ol><p>z-index经常被滥用，很多人思维定势只要设了absolute就需要同步设置z-index。其实不是这样的，上面所有例子都没有用到z-index,同样正常分层覆盖。</p><p>以下情况根本不需要设置z-index:</p><ul><li>让absolute元素覆盖正常文档流内元素（不用设z-index，自然覆盖）</li><li>让后一个absolute元素覆盖前一个absolute元素（不用设z-index，只要在html中按先后顺序正确放置两个元素即可）</li></ul><p>什么情况下需要设置z-index呢？<br>当absolute元素覆盖另一个absolute元素，且html中不方便调整DOM的先后顺序时，需要设置z-index：1; 非常少见的情况下多个absolute交错覆盖，或者需要显示最高层次的模态对话框时，可以设置z-index&gt;1。</p><p>查看京东的首页源码，设置z-index的地方也只设了1，2，3。少数地方设置了11，12，13。像是一种内部潜规则，表明更高层级的需要。</p><p>查看新浪微博的源码，发现设置了z-index:999; 如果设置了z-index:99;那如果现在需要一个更高的层级怎么办？重构页面代码，将99等数值重构成1，2，3？ 不会，通常为了省事就再设一个z-index:999;</p><p><img src="https://img.imgdb.cn/item/6035bdbc5f4313ce25a4ae0c.jpg" alt="新浪微博源码"></p><ol start="4"><li><strong>减少重绘和回流的开销</strong></li></ol><p>例如将元素隐藏，你或许会用<code>display: none;</code>。但是使用display：none隐藏容易显示难。比如，A隐藏前是display:block;B隐藏前display:inline;A和B都改成none隐藏后，要显示出来时，必须事先保存元素的display的属性，否则做不到显示后display仍旧是原先的值。</p><p>其实使用absolute控制隐藏和显示很好用，<strong>方法是：使用absolute+top: -9999em; 或者absolute+ visibility：hidden;</strong> 这样实现隐藏和显示的优点是：absolute由于层级关系，隐藏和显示只会重绘，但不会回流。（或者说absolute的回流开销小于正常DOM流中回流的开销） 而用display:none 会导致render tree重绘和回流。</p><p>另外，考虑到重绘和回流的开销，可以将动效果放在absolute元素中，避免浏览器将render tree回流。</p><p>参考：<a href="https://www.jianshu.com/p/a3da5e27d22b">博客-CSS绝对定位absolute详解</a></p><p>关于重绘和回流：参考<a href="https://juejin.cn/post/6844903569087266823#comment">掘金-浏览器的回流与重绘 (Reflow &amp; Repaint)</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS布局04-浮动float</title>
    <link href="/2021/02/09/CSS%E5%B8%83%E5%B1%8004-%E6%B5%AE%E5%8A%A8float/"/>
    <url>/2021/02/09/CSS%E5%B8%83%E5%B1%8004-%E6%B5%AE%E5%8A%A8float/</url>
    
    <content type="html"><![CDATA[<h3 id="一、浮动的背景知识"><a href="#一、浮动的背景知识" class="headerlink" title="一、浮动的背景知识"></a>一、浮动的背景知识</h3><p>最初，引入float属性是为了让web开发人员实现简单的布局，包括在一列文本中浮动的图像，文字环绕在它的左边或右边。</p><p>但是，开发人员发现，万物皆可浮动，而不仅仅是图片，所以浮动的使用范围扩大了。浮动层被用来实现整个网站页面的布局，它使信息列得以横向排列（默认是按照在源码中出现得顺序纵向排列）。目前出现了更新更好的页面布局技术，所以使用浮动来进行页面布局是传统的布局方法之一。</p><h3 id="二、一个简单的浮动例子"><a href="#二、一个简单的浮动例子" class="headerlink" title="二、一个简单的浮动例子"></a>二、一个简单的浮动例子</h3><p>HTML文件：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Simple float example<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://mdn.mozillademos.org/files/13340/butterfly.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;A pretty butterfly with red, white, and brown coloring, sitting on a large leaf&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><p>CSS文件：</p><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">90%</span>;  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">900px</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;&#125;<span class="hljs-selector-tag">p</span> &#123;  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">2</span>;  <span class="hljs-attribute">word-spacing</span>: <span class="hljs-number">0.1rem</span>;&#125;</code></pre><p>文本排版如下：<br><img src="https://img.imgdb.cn/item/60223e0f3ffa7d37b318d964.jpg"></p><p>现在我们给img元素加上浮动：</p><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;  float：left;  <span class="hljs-selector-tag">margin-right</span>: 30<span class="hljs-selector-tag">px</span>;&#125;</code></pre><p>原文档现在排版如下：</p><p><img src="https://img.imgdb.cn/item/60223d9e3ffa7d37b318a540.jpg"></p><p>浮动是如何工作的： 浮动元素img会脱离正常的文档布局流，并吸附到其父容器（body元素）的左边。在正常布局中位于该浮动元素之下的内容，此时会围绕着浮动元素，填满其右侧的空间。</p><p>浮动元素内容仍然遵循盒子模型（外边距，边界等），设置图片的右侧外边距就能阻止右侧的文字紧贴着图片。向右浮动的内容效果一样，只是反过来了——浮动元素会吸附在父元素的右边。</p><h3 id="三、首字下沉案例"><a href="#三、首字下沉案例" class="headerlink" title="三、首字下沉案例"></a>三、首字下沉案例</h3><p>HTML文件：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is my very important paragraph. I am a distinguished gentleman of such renown that my paragraph needs to be styled in a manner befitting my majesty. Bow beforemy splendour, dear students, and go forth and learn CSS!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><p>css文件：</p><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;&#125;<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123;    <span class="hljs-attribute">text-transform</span>: uppercase;&#125;<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-letter</span> &#123;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">3em</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;    <span class="hljs-attribute">background</span>: red;    <span class="hljs-attribute">float</span>: left;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">2px</span>;    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">4px</span>;&#125;</code></pre><p>最终的实现效果如下：<br><img src="https://img.imgdb.cn/item/602240ad3ffa7d37b31a31c3.jpg" alt="首字下沉"></p><h3 id="四、多列浮动布局"><a href="#四、多列浮动布局" class="headerlink" title="四、多列浮动布局"></a>四、多列浮动布局</h3><p>浮动通常用于创建多个列布局，但是会有一些奇怪的副作用，后面再讨论。现在，我们先看两列布局和三列布局是如何实现的。</p><h4 id="4-1-两列布局"><a href="#4-1-两列布局" class="headerlink" title="4.1 两列布局"></a>4.1 两列布局</h4><p>HTML文件：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>2 column layout example<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>First column<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Second column<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>CSS文件：</p><pre><code class="hljs css"><span class="hljs-comment">/* 在宽度&lt;900px时，整个视图的宽度占90%</span><span class="hljs-comment">   在宽度&gt;900px时，它将保持这个宽度，并在视口居中</span><span class="hljs-comment"> */</span><span class="hljs-selector-tag">body</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">90%</span>;    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">900px</span>;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;&#125;<span class="hljs-comment">/* </span><span class="hljs-comment">左右两个div总占96%，两者间的沟槽占4%</span><span class="hljs-comment"> */</span><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-of-type(1)</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">48%</span>;    <span class="hljs-attribute">float</span>: left;&#125;<span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-of-type(2)</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">48%</span>;    <span class="hljs-attribute">float</span>: right;&#125;</code></pre><p>最终的效果如下图：<br><img src="https://img.imgdb.cn/item/602252c23ffa7d37b3232143.jpg" alt="两列布局"></p><p>这个例子里，我们所有列使用宽度百分比——这个策略会创建一个<strong>流式布局</strong>（liquid layout），可以根据不同的屏幕尺寸调整，在较小的尺寸下保持相同的列宽度比例。这是响应式网页设计的一个有价值的工具。</p><h4 id="4-2-三列布局"><a href="#4-2-三列布局" class="headerlink" title="4.2 三列布局"></a>4.2 三列布局</h4><p>我们在上面的例子中再追加一个第三列，通过添加一个div:</p><p>追加HTML文件：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Third column<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Nam consequat scelerisque mattis. Duis pulvinar dapibus magna, eget congue purus mollis sit amet. Sed euismod lacus sit amet ex tempus, a semper felis ultrices. Maecenas a efficitur metus. Nullam tempus pharetra pharetra. Morbi in leo mauris. Nullam gravida ligula eros, lacinia sagittis lorem fermentum ut. Praesent dapibus eros vel mi pretium, nec convallis nibh blandit. Sed scelerisque justo ac ligula mollis laoreet. In mattis, risus et porta scelerisque, augue neque hendrerit orci, sit amet imperdiet risus neque vitae lectus. In tempus lectus a quam posuere vestibulum. Duis quis finibus mi. Nullam commodo mi in enim maximus fermentum. Mauris finibus at lorem vel sollicitudin.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>更新CSS文件：</p><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>&#123;    <span class="hljs-attribute">width</span>:<span class="hljs-number">90%</span>;    <span class="hljs-attribute">max-width</span>:<span class="hljs-number">900px</span>;    <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span> auto;&#125;<span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-of-type(1)</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">36%</span>;    <span class="hljs-attribute">float</span>: left;&#125;<span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-of-type(2)</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">30%</span>;    <span class="hljs-attribute">float</span>: left;    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">4%</span>;&#125;<span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-of-type(3)</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">26%</span>;    <span class="hljs-attribute">float</span>: right;&#125;</code></pre><p>三列布局如下：</p><p><img src="https://img.imgdb.cn/item/602254c73ffa7d37b324135d.jpg" alt="三列布局"></p><p>需要注意的是，必须考虑清楚将列放在什么位置，以及如何浮动他们，以获得需要的效果。比如，如果我们将第二列的float值改为right，那么的三个div的顺序将变为：</p><blockquote><p>div1 div3 div2</p></blockquote><p>这是因为div2的源代码顺序在div3上，所以浮动顺序等级比div3高，两者又同时右浮动，所以div2更靠右。</p><h3 id="五、清除浮动"><a href="#五、清除浮动" class="headerlink" title="五、清除浮动"></a>五、清除浮动</h3><p>设置元素浮动带来的问题——所有在浮动下面的自身不浮动的内容将围绕浮动元素进行包装，如果没有处理这些元素，排版将变得很糟糕。</p><p>举例：现在在4.2的例子中追加一个footer<br>追加HTML文件：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;copy;</span>2016 your imagination. This isn&#x27;t really copyright, this is a mockery of the very concept. Use as you wish.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span></code></pre><p>排版将会变成这样：<br><img src="https://img.imgdb.cn/item/6022579e3ffa7d37b32588df.jpg" alt="浮动的影响"></p><p>你会发现页脚在最长的列旁边环绕着，而正常情况下我们希望footer保持在所有列的下面。这时，我们便需要清除浮动。使用clear属性可以清除浮动，当把这个属性应用到一个元素上时，它意味着“此处停止浮动”——这个元素和源码中后面的元素都将不再浮动（除非你设置了新的float在后面的元素身上）</p><pre><code class="hljs css"><span class="hljs-selector-tag">footer</span> &#123;    clear：both;&#125;</code></pre><p>现在排版就正常了：<br><img src="https://img.imgdb.cn/item/602258b03ffa7d37b326396b.jpg" alt="清除浮动"></p><p>clear属性可以取三个值：</p><ul><li>left: 停止任何活动的左浮动</li><li>right: 停止任何活动的右浮动</li><li>both: 停止任何活动的左右浮动</li></ul><p><strong>1.清除浮动的本质</strong></p><p><strong>清除浮动</strong>：本质是为解决父级元素因为子级元素浮动而引起高度为0的问题。</p><p>很多时候，我们不方便给父盒子一个确定的高度，因为我们不知道有多少子盒子，有多少内容，通常都是让内容来撑开父盒子的高度。</p><p>但是如果父盒子中有子盒子浮动了之后，就会影响到后面的盒子。因为浮动元素脱离了标准流，会把后面还在标准流的盒子覆盖，解决这个问题的方法就是<strong>清除浮动</strong></p><p>原理图:<br><img src="https://img.imgdb.cn/item/60234d5c3ffa7d37b387e061.jpg" alt="清除浮动原理图"></p><p><strong>2.常见的清除浮动的方法：</strong></p><p>清除浮动其实叫做闭合浮动更合适，因为是把浮动的元素圈起来，让父元素闭合出口和入口不然他们出来影响其他的元素。上文的例子中已经提到，CSS中用于清除浮动的是clear属性。</p><p><font color=green>（1）额外标签法:</font></p><ul><li>尾部标签法：通过在<strong>浮动元素的末尾</strong>添加一个空标签。这时W3C推荐的用法，虽然简单但是添加了无意义的标签，导致结构化较差，所以不推荐使用。<br>三种写法：<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 第一种 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;clear:both&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- 第二种 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;clear&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>.clear &#123;clear: both&#125;<span class="hljs-comment">&lt;!-- 第三种 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;clear&#x27;</span> /&gt;</span>.clear &#123;clear: both&#125;</code></pre></li><li>内部标签法：把div放进父盒子里，盒子会撑开，一般也不用。</li></ul><p><font color=green>（2）父元素添加overflow法:</font></p><p>给父级元素添加overflow的样式，也可以清除浮动。但是因为overflow的本质是溢出隐藏的效果，所以也存在一些问题（比如内容增多的时候不会自行换行导致内容被隐藏掉，无法显示出要溢出的元素）</p><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;  <span class="hljs-attribute">overflow</span>: auto;  <span class="hljs-comment">/* overflow: hidden|auto|scroll</span><span class="hljs-comment">  都可以实现清除浮动 */</span>&#125;</code></pre><p><font color=green>（3）✨伪元素法:</font></p><p>伪元素法是最常用的清除浮动的方法，常见的有以下几种：</p><ul><li><strong>after伪元素法</strong>：</li></ul><p>在父元素上加一个类名clearfix。after在父元素中加一个盒子，这个元素是通过css添加的，符合闭合浮动思想，结构语义化正确。</p><p>但是这个方法IE6，7不识别，要进行兼容的话，需要使用<code>zoom:1</code>触发hasLayout来清除浮动。</p><p>代表网站：百度，网易，淘宝等</p><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;.&#x27;</span>; <span class="hljs-comment">/*尽量不要为空，一般写一个点*/</span>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;  <span class="hljs-comment">/*盒子高度为0，看不见*/</span>  <span class="hljs-attribute">display</span>: block;  <span class="hljs-comment">/*插入伪元素是行内元素，要转化为块级元素*/</span>  <span class="hljs-attribute">visibility</span>: hidden; <span class="hljs-comment">/*content有内容，将元素隐藏*/</span>  <span class="hljs-attribute">clear</span>: both;&#125;<span class="hljs-selector-class">.clearfix</span> &#123;  *zoom: 1; /*只有IE6，7识别*/&#125;</code></pre><blockquote><p>在Unicode字符里有一个“零宽度空格”,级U+200B，代替”.”，可以减少代码量，不需要再使用<code>visibility:hidden</code></p></blockquote><p>代表网站：阿里巴巴</p><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;    <span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;\200B&quot;</span>;   <span class="hljs-comment">/* content:&#x27;\0200&#x27;; 也可以 */</span>    <span class="hljs-attribute">display</span>:block;    <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;    <span class="hljs-attribute">clear</span>:both;&#125;<span class="hljs-selector-class">.clearfix</span> &#123;    *zoom: 1; &#125;</code></pre><ul><li><strong>before和after双伪元素法：</strong>（推荐）</li></ul><p>完全符合闭合浮动思想的方法。</p><p>做法：给父元素加一个类名clearfix ，需要兼容IE6，7</p><p>代码网站：小米，腾讯</p><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:before</span>, <span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span>&#123;  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>,  display: table;&#125;<span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;  <span class="hljs-attribute">clear</span>: both;&#125;<span class="hljs-selector-class">.clearfix</span> &#123;  *zoom: 1;&#125;</code></pre><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Floats">MDN–浮动float</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS布局03--Grid布局</title>
    <link href="/2021/02/08/CSS%E5%B8%83%E5%B1%8003-Grid%E5%B8%83%E5%B1%80/"/>
    <url>/2021/02/08/CSS%E5%B8%83%E5%B1%8003-Grid%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>上一节中讲到的Flexbox布局用户设计横向或纵向的布局，而Grid布局则被设计用于同时在两个维度上把元素按行和列排列整齐。<br>同flex一样，可以指定display属性来实现grid布局：<code>display: grid</code> 。grid布局又叫网格布局。</p><h3 id="一、什么是网格布局？"><a href="#一、什么是网格布局？" class="headerlink" title="一、什么是网格布局？"></a>一、什么是网格布局？</h3><p>网格是一系列水平及垂直的线构成的一种布局模式。根据网格，我们能够将设计元素进行排列，帮助我们设计出一系列具有固定位置以及宽度的元素的页面。</p><p>一个网格通常具有许多的列（column）和行（row），以及行与行、列与列之间的间隙（亦称沟槽，gutter）组成。<br><img src="https://img.imgdb.cn/item/6020eb233ffa7d37b38dd0c6.jpg" alt="网格"></p><p>举个例子：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Four<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Five<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Six<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Seven<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>默认情况下，子项按照正常布局流自定向下排布。如下所示：<br><img src="https://img.imgdb.cn/item/6020ec363ffa7d37b38e6dac.jpg"></p><p>现在我们逐一加上样式，来了解网格是如何工作的。</p><h3 id="二、定义网格："><a href="#二、定义网格：" class="headerlink" title="二、定义网格："></a>二、定义网格：</h3><p>与flex布局一样，我们是对父元素添加样式，使其改为<strong>网格容器</strong>，它的直接子项会变为<strong>网格项</strong></p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;    <span class="hljs-attribute">display</span>: grid;&#125;</code></pre><p>与flex布局不同的是，在定义网格后，你的网页并不会马上发生变化。因为<code>display:grid</code> 的声明只创建了一个只要一列的网格，所有的子项还是像正常布局流那样一个接一个的上下排列。<br>为了让我们的容器更像一个网格，我们要给刚定义的网格加一些列。现在加上三个200px的列（这里可以使用任何单位长度，甚至是百分比）</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">200px</span> <span class="hljs-number">200px</span>;&#125;</code></pre><p>现在你的网页将变为下面这种：<br><img src="https://img.imgdb.cn/item/6020ee2b3ffa7d37b38f7578.jpg"></p><h3 id="三、使用fr单位的灵活网格"><a href="#三、使用fr单位的灵活网格" class="headerlink" title="三、使用fr单位的灵活网格"></a>三、使用fr单位的灵活网格</h3><p>除了使用长度和百分比，我们也可以用fr这个单位灵活定义网格的行与列的大小。这个单位表示可用空间的一个比例。</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">2</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;&#125;</code></pre><p>这里，第一列被分配了2fr的可用空间，余下的两列都各被分配了1fr的可用空间，这会使得第一列的宽度是第二三列的两倍。每一列的宽度都会随着可用空间变小而变小。</p><p>另外，fr可以与一般的长度单位混合使用，比如<code>grid-template-columns: 200px 2fr 1fr</code>，那么第一列的宽度是200px,剩下的两列会根据除去200px后的可用空间按照比例分配。</p><p>🐖：fr单位分配的是“可用空间” 而不是“所有空间”，如果某一格包含的内容变多，那么整个可用空间就减少。</p><h3 id="四、网格间隙"><a href="#四、网格间隙" class="headerlink" title="四、网格间隙"></a>四、网格间隙</h3><p>使用grid-column-gap属性定义列间隙；使用gird-row-gap属性定义行间隙；使用grid-gap可以同时设定两者。</p><p>间隙距离可以使用任何长度单位包括百分比单位表示，但是不能使用fr单位。</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-temmplate-columns</span>: <span class="hljs-number">2</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;    <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;&#125;</code></pre><p>效果如下图：<br><img src="https://img.imgdb.cn/item/6020f1903ffa7d37b3915514.jpg"><br><img src="https://img.imgdb.cn/item/6020f1c73ffa7d37b39171c8.jpg"></p><p>🐖：grid-gap属性现在也写作gap属性，目的是让它们能够在不同的布局方法中都起作用。为了代码的健壮性，你可以把两个属性都写上。</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">display</span>: grid;  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">2</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;  <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;&#125;</code></pre><h3 id="五、重复构建行-列"><a href="#五、重复构建行-列" class="headerlink" title="五、重复构建行/列"></a>五、重复构建行/列</h3><p>可以使用repeat来重复构建具有某些宽度配置的某些列。</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-columns</span>:<span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>fr);    <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;&#125;</code></pre><p>这里得到了3个1fr的列，第一个传入repeat函数的值（3）表明了后续列宽的配置要重复多少次，第二个值（1fr）表示需要重复的构建配置，这个配置可以具有多个长度设定，例如repeat(2,2fr,1fr)，这相当于填入了2fr,1fr,2fr,1fr</p><h4 id="六、显式网格与隐式网格"><a href="#六、显式网格与隐式网格" class="headerlink" title="六、显式网格与隐式网格"></a>六、显式网格与隐式网格</h4><p>显式网格是我们用grid-template-columns或grid-template-rows属性构建的。而隐式网格则是当有内容被放到网格外时才会生成的。简单地说，隐式网格就是为了放显式网格放不下的元素，浏览器根据已经定义的显示网格自动生成的网格部分。</p><p>隐式网格中生成的行/列大小的默认参数是auto，大小会根据放入的内容自动调整。当然也可以使用grid-auto-rows/grid-auto-columns属性手动设定隐式网格的大小。</p><p>举个例子，现在将上面案例中的隐式网格中的行设为100px:</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>fr);    <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;&#125;</code></pre><p>则网格的样式如下所示：<br><img src="https://img.imgdb.cn/item/6021f0a23ffa7d37b3f5dd99.jpg"><br><img src="https://img.imgdb.cn/item/6021f0c03ffa7d37b3f5eeca.jpg"></p><p>你可以看到那些隐式网格中的行（因为这个例子里没有设置grid-template-rows,因此所有的行都位于隐式网格内）现在都是100像素高了。</p><h4 id="七、方便的minmax-函数"><a href="#七、方便的minmax-函数" class="headerlink" title="七、方便的minmax()函数"></a>七、方便的minmax()函数</h4><p>将行/列设死为100px时，我们要方进去的内容可能会超过100像素。所以我们希望可以将行/列设为“至少100px”,而且可以跟随内容来自动拓展尺寸保证能容纳所有内容。因此，我们有了minmax()函数。</p><p>minmax函数为一个行/列的尺寸设置了取值范围，比如设定为<code>minmax(100px,auto)</code>，那么尺寸就至少为100像素，并且如果内容尺寸大于100像素则会根据内容自动调整。</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>fr);    <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>,auto);    <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;&#125;</code></pre><h4 id="八、自动使用多列填充"><a href="#八、自动使用多列填充" class="headerlink" title="八、自动使用多列填充"></a>八、自动使用多列填充</h4><p>现在把repeat与minmax函数组合起来，来实现一个非常有用的功能。某些情况下，我们需要让网格自动创建很多列来填满整个容器，通过设置grid-template-columns属性，我们可以实现这个效果，但是现在，我们使用repeat函数中的一个关键字auto-fill来替代确定的重复次数。repeat函数中的第二个参数，我们使用minmax函数来设定一个行/列的最小值，以及最大值1fr</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill,minmax(<span class="hljs-number">200px</span>,<span class="hljs-number">1</span>fr));    <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>,auto);    <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;&#125;</code></pre><p><img src="https://img.imgdb.cn/item/6021f7ab3ffa7d37b3f848fc.jpg" alt="自动多列填充"></p><p>可以看到形成了一个包含许多至少200像素的列的网络将容器填满。随着容器宽度的改变，网格回自动根据宽度进行体调整，每一列的宽度总是大于200像素，并且容器总会被列填满。</p><h4 id="九、基于线的元素放置"><a href="#九、基于线的元素放置" class="headerlink" title="九、基于线的元素放置"></a>九、基于线的元素放置</h4><p>在定义完网格之后，我们要把元素放入网格之中。我们的网格有许多分隔线。我们根据这些分隔线来放置元素，通过以下属性来指定哪条线开始到哪条线结束。</p><ul><li>grid-column-start</li><li>grid-column-end</li><li>grid-row-start</li><li>grid-row-end</li></ul><p>这些属性的值均为分隔线序号，也可以用以下缩写形式来同时指定开始与结束的线。</p><ul><li>grid-column: 开始线/结束线</li><li>grid-row：开始线/结束线</li></ul><p>🐖：可以用-1来定位到最后一条列分隔线/行分隔线，并且可以用负数来指定倒数的某一条分隔线。但这只能用于显式网格。</p><p>参考：<br>1.<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids">MDN–Grid布局</a><br>2.<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout#Guides">MDN–CSS网格指南</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS布局02--flex布局</title>
    <link href="/2021/02/08/CSS%E5%B8%83%E5%B1%8002-flex%E5%B8%83%E5%B1%80/"/>
    <url>/2021/02/08/CSS%E5%B8%83%E5%B1%8002-flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>flex布局全称CSS弹性盒子布局（FlexBox），它定义了一种针对用户界面设计而优化的CSS盒子模型。在弹性布局模型种，弹性容器的子元素在任何方向上排布，也可以“弹性伸缩”其尺寸。既可以增加尺寸以填满未使用的空间，也可以收缩尺寸以避免父元素溢出。子元素的水平对齐和垂直对齐都很好控制，通过嵌套水平框和垂直框，可以在两个维度上构建布局。</p><p>要想使用flex布局，只需要在父元素上应用<code>display: flex</code>，所有直接子元素都会按照flex进行布局。</p><p>举个例子：<br>一个父元素wrapper，它的内部有三个div子元素，默认情况下会作为块元素从上到下显示。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box3&quot;</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>现在我们给父元素wrapper加一个样式</p><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span>&#123;    <span class="hljs-attribute">display</span>: flex;&#125;</code></pre><p>那么布局会如下：<br><img src="https://img.imgdb.cn/item/6020ba8c3ffa7d37b37489f3.jpg" alt="flex布局例子"><br>可以看到三个子元素自动按列排列。这是由于它们变成了flex项（flex items),按照flex容器（即父元素）的一些flex相关的默认初始值排布：</p><ul><li>它们整整齐齐排成一行，是因为父元素上flex-direction的初值是row</li><li>它们全都被拉伸至和最高的元素高度相同，是因为父元素上align-items属性的初值是stretch</li></ul><p>上述的flex-direction和align-items属性都是用在<strong>flex容器</strong>，即父元素上的。还有很多属性是用在<strong>flex项</strong>（flex items)上的，这些属性可以改变flex项在flex布局种占用宽、高的方式，允许它们通过伸缩来适应可用空间。</p><p>再举个例子：<br>我们在所有的子元素上添加一个样式：</p><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;    <span class="hljs-attribute">display</span>: flex;&#125;<span class="hljs-selector-class">.wrapper</span> &gt; <span class="hljs-selector-tag">div</span> &#123;    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;&#125;</code></pre><p>那么三个子元素的排布会变成如下样式：<br><img src="https://img.imgdb.cn/item/6020bc6b3ffa7d37b3756831.jpg"></p><p>所有的子元素上都添加了<code>flex:1</code>，这会使得所有的子元素都伸展并填充flex容器，而不是尾部留下空白。如果有更多空间，子元素们会变得更宽；反之会变得更窄。如果你在HTML中追加了一个新元素，它们也会变得更小来为新元素创造空间——不管怎样，最终它们会调整自己直到占用向他宽度的空间。</p><p>相关的CSS属性：</p><ul><li>flex,flex-basis,flex-direction</li><li>flex-flow, flex-grow, flex-shrink,flex-wrap</li><li>order</li></ul><p>对齐属性：</p><ul><li>align-content,align-items,align-self</li><li>justify-content,place-content,row-gap</li><li>column-gap,gap</li></ul><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout">MDN–FlexBox弹性盒子布局</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS布局01--正常布局流</title>
    <link href="/2021/02/08/CSS%E5%B8%83%E5%B1%8001-%E6%AD%A3%E5%B8%B8%E5%B8%83%E5%B1%80%E6%B5%81/"/>
    <url>/2021/02/08/CSS%E5%B8%83%E5%B1%8001-%E6%AD%A3%E5%B8%B8%E5%B8%83%E5%B1%80%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>在介绍正常布局流之前，我们需要先了解下用于布局的元素：盒子。</p><h3 id="一、盒模型"><a href="#一、盒模型" class="headerlink" title="一、盒模型"></a>一、盒模型</h3><h4 id="1-1-块级盒子和内联盒子"><a href="#1-1-块级盒子和内联盒子" class="headerlink" title="1.1 块级盒子和内联盒子"></a>1.1 块级盒子和内联盒子</h4><p>在CSS中我们广泛的使用两种盒子——块级盒子（block box)和内联盒子（inline box），这两种盒子在页面流和元素之间的关系方面会表现出不同的行为：<br><img src="https://img.imgdb.cn/item/6020a0123ffa7d37b3684039.jpg" alt="块级盒子vs内联盒子"></p><p>默认情况下：</p><ul><li><p>常见的块级盒子：h1-h6、p、div、ul、ol、table、form<br>…详细见<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements">MDN-块级元素</a></p></li><li><p>常见的内联盒子：a、span、em、strong、i、img、input、select、textarea…详细见<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elements">MDN-行内元素</a></p></li></ul><p>我们可以通过设置display属性，来控制盒子的外部显示类型。</p><p><strong>补充：内部和外部显示类型</strong></p><blockquote><p>css的box模型有一个<strong>外部显示类型</strong>，来决定盒子是块级还是内联。<br>css的box模型有一个<strong>内部显示类型</strong>，来决定盒子内部元素的如何布局的（默认情况下是安装正常文档流布局）<br>但是我们可以通过使用display: flex的类似属性值来更改内部显示类型。例如，如果一个元素的外部显示类型是block，但是内部显示类型修改为flex，该盒子内的所有直接子元素都会成为flex元素，这些子元素会根据弹性盒子规则进行布局。</p></blockquote><p>接下来的内容我们专注于盒模型的外部显示类型。</p><h4 id="1-2-盒模型的主要内容"><a href="#1-2-盒模型的主要内容" class="headerlink" title="1.2 盒模型的主要内容"></a>1.2 盒模型的主要内容</h4><p>完整的CSS盒模型主要应用与块级盒子，内联盒子只使用盒模型中定义的部分内容。盒模型定义了盒子的每个部分——margin，border，padding，content。常见的有标注盒模型和IE盒模型。</p><h5 id="1-2-1-盒模型的各个部分"><a href="#1-2-1-盒模型的各个部分" class="headerlink" title="1.2.1 盒模型的各个部分"></a>1.2.1 盒模型的各个部分</h5><p>CSS中组成一个块级盒子需要以下几个部分：</p><ul><li>Content box: 内容区域，大小可通过width 和 height设置</li><li>Padding box: 内边距（包围在内容区域外部的空白区域），大小可通过padding相关属性设置。</li><li>Border box：边框盒（包裹内容和内边距），大小可通过border相关属性设置</li><li>Margin box: 外边距（盒子和其他元素之间的空白区域），大小可通过margin相关属性设置。</li></ul><p>如下图所示：<br><img src="https://img.imgdb.cn/item/6020a4d63ffa7d37b36a644c.jpg" alt="盒模型"></p><h5 id="1-2-2-标准盒模型"><a href="#1-2-2-标准盒模型" class="headerlink" title="1.2.2 标准盒模型"></a>1.2.2 标准盒模型</h5><p>在标准盒模型中，如果你给盒设置width和height，实际设置的是Content box。padding 和 border再加上盒子的width height才一起决定了整个盒子的大小。</p><p>举个栗子：</p><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">350px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">26px</span>;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">25px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid black;&#125;</code></pre><p>使用标准盒模型，该盒子的宽度width = 350px+25px+25px+5px+5px = 410px; 该盒子的高度height = 150px+25px+25px+5px+5px = 210px;(content+padding+border)</p><p><img src="https://img.imgdb.cn/item/6020add03ffa7d37b36e6757.jpg" alt="标准盒模型"></p><p>🐖：margin不计入实际盒子的大小，当然，它会影响盒子在页面的所占空间，但是影响的是盒子外部空间。盒子的范围到border为止，不会延神到margin。</p><h5 id="1-2-3-替代-IE-盒模型"><a href="#1-2-3-替代-IE-盒模型" class="headerlink" title="1.2.3 替代(IE)盒模型"></a>1.2.3 替代(IE)盒模型</h5><p>盒子的大小还得加上边框和内边距，这样有些麻烦。所以CSS还有一个替代盒模型，使用整个模型，所有宽度都是可见宽度，所以内容宽度 content= 该宽度-border-padding</p><p><img src="https://img.imgdb.cn/item/6020afca3ffa7d37b36f258a.jpg" alt="替代盒模型"></p><p>默认情况下，浏览器会使用标准模型。如果需要使用替代模型，可以通过设置<code> box-sizing: border-box;</code> 来实现。这样你设置的width和height就是盒子的实际宽高。<br>如果你希望所以的元素都使用替代盒模型，可以像下面这样设置：</p><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;    <span class="hljs-attribute">box-sizing</span>: border-box;&#125;*,*<span class="hljs-selector-pseudo">::before</span>,*<span class="hljs-selector-pseudo">::after</span>&#123;    <span class="hljs-attribute">box-sizing</span>: inherit;&#125;</code></pre><h3 id="二、正常布局流（Normal-flow）"><a href="#二、正常布局流（Normal-flow）" class="headerlink" title="二、正常布局流（Normal flow）"></a>二、正常布局流（Normal flow）</h3><p>正常布局流是指在不对页面进行任何布局控制时，浏览器默认的HTML布局方式。<br>举个例子：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>I love my cat<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Buy cat food<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Exercise<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Cheer up friend<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The end!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><p>默认情况下，浏览器的显示如下:<br><img src="https://img.imgdb.cn/item/6020b1df3ffa7d37b36fec6b.jpg"></p><p>HTML元素完全安按照源码中出现的先后次序显示。<strong>块级元素</strong>出现在一个元素的下面，<strong>内联元素</strong>出现在另一个元素的旁边。对于页面上的多数元素，<strong>正常布局流</strong>完全足够创建一个你所需要的布局。所以，从一个结构良好的HTML文档开始非常重要，因为你可以按照默认的方式来搭建页面，而不是自造车轮！</p><p>下面的布局技术会覆盖默认的正常流式布局：</p><ul><li>display属性——标准的value值如：block,inline,inline-block影响元素在正常布局流中的表现形式。还有一些全新的布局可以通过设置display的值实现，如CSS Grid 和 Flexbox。</li><li>浮动——应用float值，例如left能让块级元素互相排成一行，而不是一个在另一个的下面。</li><li>position属性——允许你精准设置盒子中的盒子的位置，正常布局流中默认为static，使用其他值会引起元素不同的布局方式。例如，将元素固定在浏览器视口的左上角。</li><li>表格布局—— 使用<code>display: table</code>可以将表格的布局方式用在非表格内容上。</li><li>多列布局—— 这个<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Columns">Multi-column layout</a>属性，可以让块按列布局，比如报纸的布局就是一列一列排布的。</li></ul><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Introduction">MDN–CSS布局</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试08-列举一种你了解的React状态管理框架</title>
    <link href="/2021/02/05/%E9%9D%A2%E8%AF%9508-%E5%88%97%E4%B8%BE%E4%B8%80%E7%A7%8D%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84React%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/02/05/%E9%9D%A2%E8%AF%9508-%E5%88%97%E4%B8%BE%E4%B8%80%E7%A7%8D%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84React%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="面试场景8：列举一种你了解的react状态管理框架？"><a href="#面试场景8：列举一种你了解的react状态管理框架？" class="headerlink" title="面试场景8：列举一种你了解的react状态管理框架？"></a>面试场景8：列举一种你了解的react状态管理框架？</h3><p><strong>破题</strong>：</p><p>正如面试07组件间通信中提到的：跨越多个层级之间的组件仍然需要共享状态、响应变化。传统的状态提升方案例如Context，难以高效地解决这个问题。</p><p>Context存储的变量难以追溯数据源以及确认变动点。当组件依赖Context，会提高组件耦合度，不利于组件的复用与测试。而状态管理框架就很好地解决了这个问题。</p><p>当前React社区最流行的三大状态管理框架：Flux，React， Mobx。</p><h4 id="一、Flux"><a href="#一、Flux" class="headerlink" title="一、Flux"></a>一、Flux</h4><p>Flux提出了一种MVC以外的成功实践——<strong>单向数据流</strong>。 2014年Facebook F8大会上提出了一个观点，MVC更适用于小型应用，大型前端项目使用MVC会使项目变得复杂（每当添加新的功能，系统复杂度就会疯狂增长）。如下图所示，Model与View的关联是错综复杂的，很难理解和调式，尤其是Model与View之间存在<strong>双向数据流动</strong></p><p><img src="https://img.imgdb.cn/item/601d2cc93ffa7d37b3f544dc.jpg" alt="MVC架构图"></p><p>这种MVC模式，对于就接手老代码的人也是个令人头疼的难题，因为他们害怕承担风险，所以不敢轻易修改代码。所以，facebook提出了一种基于单向数据流的架构。如下图所示：</p><p><img src="https://img.imgdb.cn/item/601d2ec03ffa7d37b3f5f5e5.jpg" alt="Flux架构"></p><p>几个核心概念：</p><ul><li>View是视图层，即代码中的React组件</li><li>Store是数据层，维护了数据和数据处理的逻辑</li><li>Dispatcher是管理数据流动的中央枢纽。每一个Store提供一个回调，当Dispatcher接收一个Action时，所以的Store接收注册表中的Action，然后通过回调产生数据</li><li>Action可以理解为一种事件通知,通常用type标记。</li></ul><p>具体的流程是：Store存储了视图层的所有数据，当Store变化后会引起View层的更新。如果在View层触发一个Action，比如点击一个按钮，当前的页面数据值会发生变化。Action会被Dispatcher进行统一的收发处理，传递给Store层。由于Store层以及注册过相关Action的处理逻辑，处理相应的内部状态变化后，会触发View层更新。</p><p>从应用场景来看，Flux除了在FaceBook内部大规模应用以外，业界很少使用，它的概念和样板代码与后起之秀比略显冗余。</p><h4 id="二、Redux"><a href="#二、Redux" class="headerlink" title="二、Redux"></a>二、Redux</h4><p><strong>前言–Elm</strong>:</p><p>Elm是一种主要用于网页开发的语言，它设计了一种Model、View、Message、Update的更新思想。</p><p><img src="https://img.imgdb.cn/item/601e05143ffa7d37b345b584.jpg" alt="elm架构"></p><p>Elm的主要思想：</p><ul><li>全局单一数据源：不像Flux一样有多个Store</li><li>纯函数：可以保证输入输出的恒定。</li><li>静态类型：可以保证允许安全</li></ul><p>Redux借鉴了Elm的这个设计，确立的自己的三原则：</p><ul><li><strong>单一数据源</strong>：整个应用的state被存储在一个object tree中，并且这个object tree 只存在于唯一的store中</li><li><strong>纯函数Reducer</strong>: 即为了描述Action如何改变状态树，编写的一个纯函数的Reducer</li><li><strong>state是只读的</strong>：唯一可以改变state的方法是触发Action，Action是一个用于描述已发生事件的普通对象</li></ul><p>如何解决副作用(Side Effect): </p><p>==&gt; 任何具备业务价值的Web应用都必然执行复杂的逻辑，比如Ajax请求等异步工作，这类逻辑函数在每次的执行过程中产生不同的变化，这样与外界的交互被称为“副作用”。 一个常见的副作用的栗子：你发送你一个网络请求，需要界面先显示Loading，再根据请求是否成功来决定界面是显示报错还是数据内容。面对这样的场景，你会发现在整个过程中，异步操作在Redux中无从添加，因为Redux本身深受函数式编程的影响。导致：</p><ul><li>所有的事件都收拢到Action中去触发</li><li>所有的UI状态都交给Store去管理</li><li>所有的业务逻辑都交给Reducer去处理</li></ul><p>这里的Action和Reducer是纯函数，Store只是一个状态树，都不能完成处理副作用的操作。真正可以解决副作用的方案有两类：</p><ol><li>在Dispatch的时候有一个<font color=green>middleware中间件层</font>，拦截分发的Action并添加额外的复杂行为，还可以添加副作用。</li></ol><p>这类方案中的代表是Redux-thunk，其作用是处理异步Action，它的源码经常在面试中经常被要求独立编写。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createThunkMiddleware</span>(<span class="hljs-params">extraArgument</span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">&#123; dispatch, getState &#125;</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">next</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">Action</span>) =&gt;</span> &#123;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-keyword">typeof</span> Action === <span class="hljs-string">&#x27;function&#x27;</span></span>)</span>&#123;            <span class="hljs-keyword">return</span> Action(dispatch,getState,extraArgument);        &#125;        <span class="hljs-keyword">return</span> next(Action)    &#125;&#125;<span class="hljs-keyword">const</span> thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware();<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> thunk;</code></pre><p>redux-thunk通过添加中间件来判断Action是否是函数：</p><ul><li>如果是函数：则Dispatch,将当前的整个state以及额外的参数传入其中</li><li>否则继续流转Action</li></ul><p>这类方案是最经典的处理redux副作用的方案，用户还可以自定义Store的middleware。如果Action是一个数组或者是一个promise，还可以是迭代器，或者rxjs, 社区中有相应的中间件，redux-saga, redux-promise,redux-observable等。</p><ol start="2"><li>第二类方案较为冷门，但是设计上思考得更为深刻。例如redux loop就深入地借鉴了Elm。Elm的副作用处理是在update层，这样的设计叫<font color=green>分形架构</font>【如果子组件能够以同样的结构，作为一个应用使用，这样的结构就是分形架构】</li></ol><p>分形架构的好处显而易见，复用容易，组合方便。Redux Loop就做出了这样的尝试，但是在实际的项目中应用的很少。</p><pre><code class="hljs js"><span class="hljs-comment">//redux-loop</span><span class="hljs-keyword">import</span> &#123;loop,Cmd&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-loop&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initAction</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> &#123;        type:<span class="hljs-string">&#x27;INIT&#x27;</span>,    &#125;;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchUser</span>(<span class="hljs-params">userId</span>)</span>&#123;    <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">`/api/user/<span class="hljs-subst">$&#123;userId&#125;</span>`</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">userFetchSuccessAction</span>(<span class="hljs-params">user</span>)</span>&#123;    <span class="hljs-keyword">return</span> &#123;        type: <span class="hljs-string">&#x27;USER_FETCH_SUCCESS&#x27;</span>,        user    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">userFetchFailAction</span>(<span class="hljs-params">err</span>)</span>&#123;    <span class="hljs-keyword">return</span> &#123;        type: <span class="hljs-string">&#x27;USER_FETCH_FAILED&#x27;</span>,        err    &#125;&#125;<span class="hljs-keyword">const</span> initialState = &#123;    initStarted:<span class="hljs-literal">false</span>,    user:<span class="hljs-literal">null</span>,    error:<span class="hljs-literal">null</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Reducer</span>(<span class="hljs-params">state=initialState,Action</span>)</span>&#123;    <span class="hljs-function"><span class="hljs-title">switch</span>(<span class="hljs-params">Action.type</span>)</span>&#123;        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;INIT&#x27;</span>:            <span class="hljs-keyword">return</span> loop(                &#123;...state, <span class="hljs-attr">initStarted</span>:<span class="hljs-literal">true</span>&#125;,                Cmd.run(fetchUser, &#123;                    successActionCreator: userFetchSuccessAction,                    failActionCreator:userFetchFailAction,                    args:[<span class="hljs-string">&#x27;123&#x27;</span>]                &#125;)            );        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;USER_FETCH_SUCCESS&#x27;</span>:            <span class="hljs-keyword">return</span> &#123;...state, <span class="hljs-attr">user</span>: Action.user&#125;;        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;USER_FETCH_FAILED&#x27;</span>:            <span class="hljs-keyword">return</span> &#123;...state, <span class="hljs-attr">error</span>: Action.error&#125;;        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">return</span> state;    &#125;&#125;</code></pre><p>虽然redux loop在分形架构上做出了探索，但是redux作者并不是那么满意，甚至写了一篇<a href="https://redux.canny.io/feature-requests/p/there-is-no-easy-way-to-compose-redux-applicati">There is no easy way to compose Redux applications</a>认为没有一种简单的方案可以组合redux应用，并提出了一个长久为未被解决的<a href="https://github.com/reduxjs/redux/issues/1528">issue</a></p><p>最后就是关于redux的一揽子解决方案：</p><ul><li>在国外社区流行的方案是rematch,它提供了一个标准的范式写redux。有一些<a href="https://github.com/rematch/rematch/tree/next/examples">rematch案例</a>可供参考，rematch的模块更为内聚，插件更丰富。</li><li>国内的流行解决方案是<a href="https://github.com/dvajs/dva">dva</a></li></ul><h4 id="三、Mobx"><a href="#三、Mobx" class="headerlink" title="三、Mobx"></a>三、Mobx</h4><p>先看一个Mobx的官方示例：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;observable,autorun&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mobx&#x27;</span>;<span class="hljs-keyword">var</span> todoStore = observable(&#123;    <span class="hljs-comment">//一些观察的状态</span>    todos:[],    <span class="hljs-comment">//推导值</span>    <span class="hljs-keyword">get</span> <span class="hljs-title">completedCount</span>()&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span>=&gt;</span>todo.completed).length;    &#125;&#125;);<span class="hljs-comment">//观察状态改变的函数</span>autorun(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;completed %d id %d items&quot;</span>,        todoStore.completedCount,        todoStore.todos.length    )&#125;);<span class="hljs-comment">//一些改变状态的动作</span>todoStore.todos[<span class="hljs-number">0</span>]=&#123;    title: <span class="hljs-string">&#x27;take a walk&#x27;</span>,    completed: <span class="hljs-literal">false</span>&#125;<span class="hljs-comment">// -&gt;同步打印 ‘Completed 0 of 1 items&#x27;</span>todoStore.todos[<span class="hljs-number">0</span>].completed=<span class="hljs-literal">true</span>;<span class="hljs-comment">// -&gt;同步打印 ‘Completed 1 of 1 items&#x27;</span></code></pre><p>Mobx是通过监听数据的属性变化，直接在数据上更改来触发UI的渲染。Mobx的监听方式有两种：</p><ul><li>在Mobx5之前，实现监听的方式是Object.defineProperty</li><li>在Mobx5之后，采用的是Proxy方案。</li></ul><p><strong>答题</strong>：<br><img src="https://img.imgdb.cn/item/601e8c683ffa7d37b3801282.jpg" alt="状态管理库总结"></p><blockquote><p>一、首先介绍Flux,Flux是一种使用单向数据流的形式来组合React组件的应用架构。</p><p>Flux包含了4个部分：Dispatcher,Store,View,Action。Store存储了视图层所有的数据，当Store变化后引起View层的更新。如果在视图层触发一个Action,就会使当前的页面数据值发生变化。Action会被Dispatcher进行统一的收发处理，传递给Store层，Store层已经注册过相关Action的处理逻辑，处理对应的内部状态变化后，触发View层更新。</p><p>Flux的优点使单向数据流，解决了MVC中数据流向不清的问题，使开发者可以快速了解应用行为。从项目结构上简化了视图层设计，数据与业务逻辑也统一存放管理，使在大型架构中更容易管理与维护代码。</p></blockquote><blockquote><p>二、其次是Redux，Redux 中整个数据流的方案与 Flux 大同小异。它的核心设计包含三大原则：单一数据源、纯函数reducer、state是只读的。</p><p>Redux 中的另一大核心点是处理“副作用”，AJAX 请求等异步工作，或不是纯函数产生的第三方的交互都被认为是 “副作用”。这就造成在纯函数设计的 Redux 中，处理副作用变成了一件至关重要的事情。社区通常有两种解决方案：<br>(1)第一类是在 Dispatch 的时候会有一个 middleware 中间件层，拦截分发的 Action 并添加额外的复杂行为，还可以添加副作用。第一类方案的流行框架有 Redux-thunk、Redux-Promise、Redux-Observable、Redux-Saga 等。<br>(2)第二类是允许 Reducer 层中直接处理副作用，采取该方案的有 React Loop，React Loop 在实现中采用了 Elm 中分形的思想，使代码具备更强的组合能力。</p><p>Redux 的优点很多：结果可预测；代码结构严格易维护；模块分离清晰且小函数结构容易编写单元测试；Action 触发的方式，可以在调试器中使用时间回溯，定位问题更简单快捷；单一数据源使服务端同构变得更为容易；社区方案多，生态也更为繁荣。</p></blockquote><blockquote><p>三、最后是 Mobx，Mobx 通过监听数据的属性变化，可以直接在数据上更改触发UI 的渲染。在使用上更接近 Vue，比起 Flux 与 Redux 的手动挡的体验，更像开自动挡的汽车。Mobx 的响应式实现原理与 Vue 相同，以 Mobx 5 为分界点，5 以前采用 Object.defineProperty 的方案，5 及以后使用 Proxy 的方案。它的优点是样板代码少、简单粗暴、用户学习快、响应式自动更新数据让开发者的心智负担更低。</p></blockquote><p><font color=red>总结:</font></p><p>对技术进行横向比较的时候切忌踩一捧一!谈个人观点的时候可以使用类似下面这种说法：</p><p>我认为Flux的设计更偏向Facebook内部的应用场景，Facebook的方案略显臃肿，拓展能力不佳，所以在社区中热度不够。而Redux因为纯函数的元婴，简洁而不简单的API设计使社区疯狂贡献发展。但从工程角度而言，不是每一个项目都适合单一数据源。因为有的项目数据是按页面级别划分的，页面之间相对隔绝，并不需要共享数据源，是否需要用Redux要视情况而定。Modx在开发项目是简单快速，但应用Mobx的场景其实可以使用Vue取代，而且使用Vue体积会更小巧。</p>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试07-如何面向组件跨层级通信？</title>
    <link href="/2021/01/18/%E9%9D%A2%E8%AF%9507-%E5%A6%82%E4%BD%95%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E8%B7%A8%E5%B1%82%E7%BA%A7%E9%80%9A%E4%BF%A1/"/>
    <url>/2021/01/18/%E9%9D%A2%E8%AF%9507-%E5%A6%82%E4%BD%95%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E8%B7%A8%E5%B1%82%E7%BA%A7%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="面试场景7：如何面向组件层级通信？"><a href="#面试场景7：如何面向组件层级通信？" class="headerlink" title="面试场景7：如何面向组件层级通信？"></a>面试场景7：如何面向组件层级通信？</h3><p>React是一个组件化框架，基于组件树的位置分布，组件与组件之间的关系，大致分为4种：</p><ul><li>父与子：父组件包裹子组件，父组件向子组件传递数据</li><li>子与父：子组件存在父组件之中，子组件需要向父组件传递数据。</li><li>兄弟：两个组件并列存于父组件种，需要进行相互传递数据。</li><li>无直接关系：两个组件并没有直接的关联关系，但是需要共享、传递数据。</li></ul><p>每一种通信方式都具有一定的实际意义，以及具体的业务场景对应，而不只是代码的呈现。这种题一定要结合实际的场景才具有说服力。</p><h4 id="一-父向子传递数据"><a href="#一-父向子传递数据" class="headerlink" title="一.父向子传递数据"></a>一.父向子传递数据</h4><p>父与子的通信是最常见的场景，React开发的每个组件都在使用这样的设计模式。父向子传递数据，是以Props完成的。<br>举例，使用Props传递的类似场景有：</p><ul><li>在初始化时展示默认文案</li><li>初始化以后通过网络请求拉取文案数据</li><li>通过Props传递state的文案数据，来更新按钮中的文案。</li></ul><pre><code class="hljs js"><span class="hljs-keyword">const</span> Button = <span class="hljs-function">(<span class="hljs-params">&#123;text&#125;</span>) =&gt;</span> &#123;    &lt;button&gt;&#123;text&#125;&lt;/button&gt;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;    state = &#123;        text: <span class="hljs-string">&#x27;默认文案&#x27;</span>    &#125;    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;./api/buttonText&#x27;</span>);        <span class="hljs-built_in">this</span>.setState(&#123;            text: reponse.buttonText;        &#125;)    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">const</span> &#123;text&#125; = <span class="hljs-built_in">this</span>.state;        <span class="hljs-keyword">return</span> (            &lt;Button text=&#123;text&#125; /&gt;        )    &#125;&#125;</code></pre><p>这样的通信方式适用于面试第5讲中的展示组件。在这段示例代码中，HomePage是一个容器组件，而Button是一个展示组件。</p><h4 id="二-子向父传递数据"><a href="#二-子向父传递数据" class="headerlink" title="二.子向父传递数据"></a>二.子向父传递数据</h4><p>子组件向父组件的通信主要依赖回调函数。</p><p><strong>2.1 回调函数</strong>：</p><p>回调函数在JS中称为callback，React允许函数作为参数赋值给子组件。<br>举个例子：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Input</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;    handleChanged = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span>&#123;        <span class="hljs-built_in">this</span>.props.onChangeText(e.target.text)    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleTextChanged&#125;</span> /&gt;</span></span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Compoent</span></span>&#123;    handleTextChanged = <span class="hljs-function">(<span class="hljs-params">text</span>) =&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(text);    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> (            &lt;Input onChangeText=&#123;<span class="hljs-built_in">this</span>.handleTextChanged&#125; /&gt;        )    &#125;&#125;</code></pre><p>回调函数不仅仅用于传递值，它还可以用在渲染中，父组件根据返回的结果，决定子组件该渲染什么。比如在React Router中，我们常常会这样使用：</p><pre><code class="hljs js">&lt;Route path=<span class="hljs-string">&#x27;/hello&#x27;</span> render=&#123;<span class="hljs-function">()=&gt;</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello Everyone<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&#125; /&gt;</code></pre><p>这里的回调没有使用具体的参数，我们可再看一个案例：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FetchPosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;    state=&#123;        loading: <span class="hljs-literal">true</span>,        data:[]    &#125;    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/api/posts&#x27;</span>);        <span class="hljs-built_in">this</span>.setState(&#123;            data: response.data,            loading: <span class="hljs-literal">false</span>,        &#125;)    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-built_in">this</span>.state.loading</span>)</span>&#123;            <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Loading</span> /&gt;</span></span>        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.props.renderPosts(<span class="hljs-built_in">this</span>.state.data)    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> (            &lt;FetchPosts                 renderPosts=&#123;<span class="hljs-function"><span class="hljs-params">posts</span>=&gt;</span>(                    &lt;ul&gt;                        &#123;posts.map(<span class="hljs-function"><span class="hljs-params">post</span>=&gt;</span>(                            &lt;li key=&#123;post.id&#125;&gt;                                &lt;h2&gt;&#123;post.title&#125;&lt;/h2&gt;                                &lt;p&gt;&#123;post.description&#125;&lt;/p&gt;                            &lt;/li&gt;                        ))&#125;                    &lt;/ul&gt;                )&#125;            /&gt;        )    &#125;&#125;</code></pre><p>采取这样的策略可以使<strong>子组件专注业务逻辑，父组件专注渲染效果</strong></p><p><strong>2.2 实例函数</strong></p><p>实例函数是一种不被推荐的使用方式，这种通信方式主要见于React流行初期，那时有很多组件都通过jQuery插件生成。最常见的一种情况是在Modal中使用。<br>示例：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-keyword">const</span> modalRef = React.createRef();    showModal = <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-built_in">this</span>.modalRef.show();    &#125;    hideModal = <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-built_in">this</span>.modaRef.hide();    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> (            &lt;&gt;                &lt;Button onClick=&#123;<span class="hljs-built_in">this</span>.showModal&#125;&gt;展示Modal&lt;/Button&gt;                &lt;Button onClick=&#123;<span class="hljs-built_in">this</span>.hideModal&#125;&gt;隐藏Modal&lt;/Button&gt;                &lt;Modal ref=&#123;modalRef&#125; /&gt;            &lt;/&gt;        )    &#125;&#125;</code></pre><p>但是上述并不符合React的设计理念，像Antd的Modal都是将显隐的控制放在visible参数上，直接通过参数控制。</p><h4 id="三-兄弟之间传递数据"><a href="#三-兄弟之间传递数据" class="headerlink" title="三.兄弟之间传递数据"></a>三.兄弟之间传递数据</h4><p>兄弟组件之间的通信，往往依赖于共同的父组件进行中转。</p><p>举个栗子：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Input</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    handleChanged = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span>&#123;        <span class="hljs-built_in">this</span>.props.onChangeText(e.target.text)    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleChanged&#125;</span> /&gt;</span></span>    &#125;&#125;<span class="hljs-keyword">const</span> StaticText = <span class="hljs-function">(<span class="hljs-params">&#123;children&#125;</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> (        &lt;p&gt;&#123;children&#125;&lt;/p&gt;    )&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    state=&#123;        text:<span class="hljs-string">&quot;默认文字&quot;</span>    &#125;    handleTextChanged = <span class="hljs-function">(<span class="hljs-params">text</span>)=&gt;</span>&#123;        <span class="hljs-built_in">this</span>.setState(&#123;            text,        &#125;)    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> (            &lt;&gt;                &lt;Input onChangeText=&#123;<span class="hljs-built_in">this</span>.handleTextChanged&#125; /&gt;                &lt;StaticText&gt;<span class="hljs-built_in">this</span>.state.text&lt;/StaticText&gt;            &lt;/&gt;        )    &#125;&#125;</code></pre><p>在上述案例中，StaticText组件需要展示的内容来自输入框输入的值，那么通过父组件的state进行收集、中转、赋值给StaticText，就完成了以上的通信。这种模式主要负责在容器组件中协调各组件的通信。</p><h4 id="四-无直接关系的组件之间传递数据"><a href="#四-无直接关系的组件之间传递数据" class="headerlink" title="四.无直接关系的组件之间传递数据"></a>四.无直接关系的组件之间传递数据</h4><p>无直接关系的组件之间传递数据有三种方式：消息订阅-发布、集中式管理（redux等）、生产者-消费者模式context(开发用的少，封装插件用的多)。</p><p><strong>跨级组件通信</strong>：</p><ol><li>层层传递props:</li></ol><p>例如A组件和B组件之间要进行通信，先找到A和B公共的父组件C，A先向C组件通信，C组件通过props和B组件通信。此时，C组件起的就是中间件的作用。</p><ol start="2"><li>使用context:</li></ol><p>context是一个全局变量，像是一个大容器，在其他组件任何地方都可以随意取到；但是React官方并不建议大量使用context，因为当组件结构复杂的时候，我们并不知道context是从哪里传过来的，而且context是一个全局变量，全局变量正是导致应用走向混乱的罪魁祸首。</p><p>栗子：ListItem是List的子组件，List是App的子组件</p><pre><code class="hljs js"><span class="hljs-comment">//ListItem.jsx</span><span class="hljs-keyword">import</span> React,&#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;props-types&#x27;</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListItem</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-comment">//子组件声明自己要使用context</span>    <span class="hljs-keyword">static</span> contextTypes = &#123;        color: PropTypes.string    &#125;    <span class="hljs-keyword">static</span> propTypes = &#123;        value: PropTypes.string    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">const</span> &#123;value&#125; = <span class="hljs-built_in">this</span>.props;        <span class="hljs-keyword">return</span> (            &lt;li style=&#123;&#123; <span class="hljs-attr">background</span>: <span class="hljs-built_in">this</span>.context.color&#125;&#125;&gt;                &lt;span&gt;&#123;value&#125;&lt;/span&gt;            &lt;/li&gt;        )    &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ListItem;</code></pre><pre><code class="hljs js"><span class="hljs-comment">//List.jsx</span><span class="hljs-keyword">import</span> ListItem <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ListItem&#x27;</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;    <span class="hljs-comment">//父组件声明自己支持context</span>    <span class="hljs-keyword">static</span> childContextTypes = &#123;        color: PropTypes.string    &#125;    <span class="hljs-keyword">static</span> propTypes = &#123;        list: PropTypes.array    &#125;    <span class="hljs-comment">//提供一个函数，用来返回相应的context对象</span>    <span class="hljs-function"><span class="hljs-title">getChildContext</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> &#123;            color: <span class="hljs-string">&#x27;red&#x27;</span>,        &#125;;    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">const</span> &#123; list &#125; = <span class="hljs-built_in">this</span>.props;        <span class="hljs-keyword">return</span> (            &lt;div&gt;                &lt;ul&gt;                    &#123;                        list.map(<span class="hljs-function">(<span class="hljs-params">entry,index</span>)=&gt;</span>                            &lt;ListItem key=&#123;<span class="hljs-string">`list-<span class="hljs-subst">$&#123;index&#125;</span>`</span>&#125; value=&#123;entry.text&#125; /&gt;                        )                    &#125;                &lt;/ul&gt;            &lt;/div&gt;        )    &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> List;</code></pre><pre><code class="hljs js"><span class="hljs-comment">//App.jsx</span><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">import</span> List <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/List&#x27;</span>;<span class="hljs-keyword">const</span> list = [    &#123;        text: <span class="hljs-string">&#x27;题目1&#x27;</span>,    &#125;,    &#123;        text: <span class="hljs-string">&#x27;题目2&#x27;</span>,    &#125;,];<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> (            &lt;div&gt;                &lt;List list=&#123;list&#125;/&gt;            &lt;/div&gt;        )    &#125;&#125;<span class="hljs-string">``</span><span class="hljs-string">` </span><span class="hljs-string"></span><span class="hljs-string">**没有嵌套关系的组件通信**：</span><span class="hljs-string"></span><span class="hljs-string">使用自定义事件机制：在componentDidMount事件中，如果组件挂载完成，再订阅事件；在组件卸载的时候，componentWillUnmount中取消事件的订阅。</span><span class="hljs-string">以常用的发布/订阅模式举例，借用Node.js Events模块的浏览器版实现</span><span class="hljs-string"></span><span class="hljs-string">栗子：</span><span class="hljs-string">List1和List2没有任何嵌套关系，App是他们的父组件。</span><span class="hljs-string">实现的功能：点击List2中的一个按钮，改变List1中的信息显示。</span><span class="hljs-string">`</span><span class="hljs-string">``</span>js<span class="hljs-comment">//首先安装events包</span>npm install events --save<span class="hljs-comment">//在src下新建一个util目录，里面建一个events.js</span><span class="hljs-keyword">import</span> &#123; EventEmitter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;events&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> EvenetEmitter();</code></pre><pre><code class="hljs js"><span class="hljs-comment">//List1.jsx</span><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">import</span> emitter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../util/events&#x27;</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;        <span class="hljs-built_in">super</span>(props);        <span class="hljs-built_in">this</span>.state = &#123;            message: <span class="hljs-string">&#x27;List1&#x27;</span>,        &#125;    &#125;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-comment">//组件挂载完成以后声明一个自定义事件</span>        <span class="hljs-built_in">this</span>.eventEmitter = emitter.addListener(<span class="hljs-string">&#x27;changeMessage&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">message</span>)=&gt;</span>&#123;            <span class="hljs-built_in">this</span>.setState(&#123;                message            &#125;)        &#125;)    &#125;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-comment">//组件卸载完成后，移出事件</span>        emitter.removeListener(<span class="hljs-built_in">this</span>.eventEmitter);    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> (            &lt;div&gt;                &#123;<span class="hljs-built_in">this</span>.state.message&#125;            &lt;/div&gt;        )    &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> List;</code></pre><pre><code class="hljs js"><span class="hljs-comment">//List2.jsx</span><span class="hljs-keyword">import</span> React, &#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">import</span> emitter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../util/events&#x27;</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;    handleClick = <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span>&#123;        emitter.emit(<span class="hljs-string">&#x27;changeMessge&#x27;</span>,message);    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> (            &lt;div&gt;                &lt;button onClick=&#123;<span class="hljs-built_in">this</span>.handleClick.bind(<span class="hljs-built_in">this</span>,<span class="hljs-string">&#x27;List2&#x27;</span>)&#125;&gt;点我改变List1组件中显示信息&lt;/button&gt;            &lt;/div&gt;        )    &#125;&#125;<span class="hljs-keyword">export</span>  <span class="hljs-keyword">default</span> List2;</code></pre><pre><code class="hljs js"><span class="hljs-comment">//App.jsx</span><span class="hljs-keyword">import</span> React, &#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">import</span> List1 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/List1&#x27;</span>;<span class="hljs-keyword">import</span> List2 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/List2&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span>(            &lt;div&gt;                &lt;List1 /&gt;                &lt;List2 /&gt;            &lt;/div&gt;        )    &#125;&#125;</code></pre><p>自定义事件是典型的发布订阅模式，通过向事件对象添加监听器和触发事件来实现组件之间的通信。 </p><p><font color='green'>总结：</font></p><ul><li>父组件向子组件通信：props</li><li>子组件向父组件通信：回调函数/自定义事件</li><li>跨级组件通信：层层组件传递props/context</li><li>没有嵌套关系组件之间的通信：自定义事件</li></ul><p>在进行组件通信的时候主要看业务的具体需求，选择最合适的。当业务逻辑比较复杂时，就可以引入Mobx/Redux等状态管理工具。</p>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试06-setState是同步更新还是异步更新？</title>
    <link href="/2020/12/22/%E9%9D%A2%E8%AF%9506-setState%E6%98%AF%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%EF%BC%9F/"/>
    <url>/2020/12/22/%E9%9D%A2%E8%AF%9506-setState%E6%98%AF%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="面试场景6：setState是同步更新还是异步更新？"><a href="#面试场景6：setState是同步更新还是异步更新？" class="headerlink" title="面试场景6：setState是同步更新还是异步更新？"></a>面试场景6：setState是同步更新还是异步更新？</h4><p>分析问题：“是A还是B”是一个面试中经常问的问题，这种题可能在不同的场景中会有不同的选择：</p><ul><li>可能是A</li><li>也可能是B</li><li>甚至是A和B同时存在</li></ul><p>所以需要把问题放在具体的场景中探讨，一定不要想当然，不要觉得肯定是XXX啊。在面对类似的问题，要先把场景理清楚，再思考如何回答。</p><p>回到setState本身上来，setState用于变更状态，触发组件重新渲染，更新试图UI。在分析场景之前，需要先了解一个概念<font color=blue>合成事件</font>，它也经常在React面试中被问到。合成事件与setState的触发有千丝万缕的联系。</p><h4 id="一、合成事件"><a href="#一、合成事件" class="headerlink" title="一、合成事件"></a>一、合成事件</h4><p>在没有合成事件之前，大家是怎么处理事件的呢？先看一个很常见的场景：假设ul标签下有10000个li标签，现在需要添加点击事件，通过点击li获取当前li标签中的文本。之前大家的做法是：为每一个li标签添加onclick事件。</p><pre><code class="hljs js">&lt;ul&gt;    &lt;li onclick=<span class="hljs-string">&#x27;getText(this&#x27;</span>)&gt;<span class="hljs-number">1</span>&lt;/li&gt;    &lt;li onclick=<span class="hljs-string">&#x27;getText(this&#x27;</span>)&gt;<span class="hljs-number">2</span>&lt;/li&gt;    &lt;li onclick=<span class="hljs-string">&#x27;getText(this&#x27;</span>)&gt;<span class="hljs-number">3</span>&lt;/li&gt;    ...    &lt;li onclick=<span class="hljs-string">&#x27;getText(this&#x27;</span>)&gt;<span class="hljs-number">10000</span>&lt;/li&gt;&lt;/ul&gt;</code></pre><p>这是一种非常不友好的方式，会对页面的性能产生影响。</p><p>如何优化呢?最恰当的处理方式是采用<font color=blue>事件委托</font>。通过将事件绑定在ul标签上，当li被点击的时候，由事件冒泡到父级的ul标签上触发，并在ul的onclick事件中，确认是哪一个li标签触发的点击事件。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;test&#x27;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    ...    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>10000<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEventTarget</span>(<span class="hljs-params">e</span>) </span>&#123;</span><span class="javascript">        <span class="hljs-comment">//处理兼容性</span></span><span class="javascript">        e = e||<span class="hljs-built_in">window</span>.event;</span><span class="javascript">        <span class="hljs-keyword">return</span> e.target || e.srcElement;</span>    &#125;<span class="javascript">    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test&#x27;</span>);</span><span class="javascript">    ul.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>&#123;</span><span class="javascript">        <span class="hljs-keyword">var</span> target = getEventTarget(event);</span>        alert(target.innerHTML);    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>同样地，出于性能考虑，合成事件也是类似的做法：</p><ol><li>React给document挂上事件监听</li><li>DOM事件触发后冒泡到document</li><li>React找到对应的组件，造成一个合成事件出来</li><li>并按组件树模拟一遍事件冒泡</li></ol><p><img src="https://pic.downk.cc/item/5fe1dd603ffa7d37b37d3071.jpg" alt="React17之前的事件冒泡流程图"></p><p>由于事件挂在了document上，这样在一个页面中只能有一个版本的react。如果有多个版本，事件就乱套了。React17中解决了这个问题，事件委托不再挂在document上，而是挂在DOM容器上，也就是ReactDOM.render所调用的根节点上。<br><img src="https://pic.downk.cc/item/5fe1de423ffa7d37b37e2fb4.jpg" alt="React17后的事件冒泡流程图"></p><p>那么到底哪些事件会被捕获生成事件呢？可以从React的源码中一探究竟。下面的测试快照中罗列了大量的事件名，只有这些事件会被捕获成合成事件。</p><pre><code class="hljs js"><span class="hljs-comment">// react/packages/react-dom/src/__tests__/__snapshots__/ReactTestUtils-test.js.snap</span><span class="hljs-built_in">Array</span> [      <span class="hljs-string">&quot;abort&quot;</span>,  <span class="hljs-string">&quot;animationEnd&quot;</span>,  <span class="hljs-string">&quot;animationIteration&quot;</span>,  <span class="hljs-string">&quot;animationStart&quot;</span>,  <span class="hljs-string">&quot;auxClick&quot;</span>,  <span class="hljs-string">&quot;beforeInput&quot;</span>,  <span class="hljs-string">&quot;blur&quot;</span>,  <span class="hljs-string">&quot;canPlay&quot;</span>,  <span class="hljs-string">&quot;canPlayThrough&quot;</span>,  <span class="hljs-string">&quot;cancel&quot;</span>,  <span class="hljs-string">&quot;change&quot;</span>,  <span class="hljs-string">&quot;click&quot;</span>,  <span class="hljs-string">&quot;close&quot;</span>,  <span class="hljs-string">&quot;compositionEnd&quot;</span>,  <span class="hljs-string">&quot;compositionStart&quot;</span>,  <span class="hljs-string">&quot;compositionUpdate&quot;</span>,  <span class="hljs-string">&quot;contextMenu&quot;</span>,  <span class="hljs-string">&quot;copy&quot;</span>,  <span class="hljs-string">&quot;cut&quot;</span>,  <span class="hljs-string">&quot;doubleClick&quot;</span>,  <span class="hljs-string">&quot;drag&quot;</span>,  <span class="hljs-string">&quot;dragEnd&quot;</span>,  <span class="hljs-string">&quot;dragEnter&quot;</span>,  <span class="hljs-string">&quot;dragExit&quot;</span>,  <span class="hljs-string">&quot;dragLeave&quot;</span>,  <span class="hljs-string">&quot;dragOver&quot;</span>,  <span class="hljs-string">&quot;dragStart&quot;</span>,  <span class="hljs-string">&quot;drop&quot;</span>,  <span class="hljs-string">&quot;durationChange&quot;</span>,  <span class="hljs-string">&quot;emptied&quot;</span>,  <span class="hljs-string">&quot;encrypted&quot;</span>,  <span class="hljs-string">&quot;ended&quot;</span>,  <span class="hljs-string">&quot;error&quot;</span>,  <span class="hljs-string">&quot;focus&quot;</span>,  <span class="hljs-string">&quot;gotPointerCapture&quot;</span>,  <span class="hljs-string">&quot;input&quot;</span>,  <span class="hljs-string">&quot;invalid&quot;</span>,  <span class="hljs-string">&quot;keyDown&quot;</span>,  <span class="hljs-string">&quot;keyPress&quot;</span>,  <span class="hljs-string">&quot;keyUp&quot;</span>,  <span class="hljs-string">&quot;load&quot;</span>,  <span class="hljs-string">&quot;loadStart&quot;</span>,  <span class="hljs-string">&quot;loadedData&quot;</span>,  <span class="hljs-string">&quot;loadedMetadata&quot;</span>,  <span class="hljs-string">&quot;lostPointerCapture&quot;</span>,  <span class="hljs-string">&quot;mouseDown&quot;</span>,  <span class="hljs-string">&quot;mouseEnter&quot;</span>,  <span class="hljs-string">&quot;mouseLeave&quot;</span>,  <span class="hljs-string">&quot;mouseMove&quot;</span>,  <span class="hljs-string">&quot;mouseOut&quot;</span>,  <span class="hljs-string">&quot;mouseOver&quot;</span>,  <span class="hljs-string">&quot;mouseUp&quot;</span>,  <span class="hljs-string">&quot;paste&quot;</span>,  <span class="hljs-string">&quot;pause&quot;</span>,  <span class="hljs-string">&quot;play&quot;</span>,  <span class="hljs-string">&quot;playing&quot;</span>,  <span class="hljs-string">&quot;pointerCancel&quot;</span>,  <span class="hljs-string">&quot;pointerDown&quot;</span>,  <span class="hljs-string">&quot;pointerEnter&quot;</span>,  <span class="hljs-string">&quot;pointerLeave&quot;</span>,  <span class="hljs-string">&quot;pointerMove&quot;</span>,  <span class="hljs-string">&quot;pointerOut&quot;</span>,  <span class="hljs-string">&quot;pointerOver&quot;</span>,  <span class="hljs-string">&quot;pointerUp&quot;</span>,  <span class="hljs-string">&quot;progress&quot;</span>,  <span class="hljs-string">&quot;rateChange&quot;</span>,  <span class="hljs-string">&quot;reset&quot;</span>,  <span class="hljs-string">&quot;scroll&quot;</span>,  <span class="hljs-string">&quot;seeked&quot;</span>,  <span class="hljs-string">&quot;seeking&quot;</span>,  <span class="hljs-string">&quot;select&quot;</span>,  <span class="hljs-string">&quot;stalled&quot;</span>,  <span class="hljs-string">&quot;submit&quot;</span>,  <span class="hljs-string">&quot;suspend&quot;</span>,  <span class="hljs-string">&quot;timeUpdate&quot;</span>,  <span class="hljs-string">&quot;toggle&quot;</span>,  <span class="hljs-string">&quot;touchCancel&quot;</span>,  <span class="hljs-string">&quot;touchEnd&quot;</span>,  <span class="hljs-string">&quot;touchMove&quot;</span>,  <span class="hljs-string">&quot;touchStart&quot;</span>,  <span class="hljs-string">&quot;transitionEnd&quot;</span>,  <span class="hljs-string">&quot;volumeChange&quot;</span>,  <span class="hljs-string">&quot;waiting&quot;</span>,  <span class="hljs-string">&quot;wheel&quot;</span>,]</code></pre><h4 id="二、调用顺序"><a href="#二、调用顺序" class="headerlink" title="二、调用顺序"></a>二、调用顺序</h4><p>setState是不是异步的？我们从头梳理</p><p><strong>异步场景</strong></p><p>通常情况我们认为setState是异步的，看一个简单的例子：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    state = &#123;        count: <span class="hljs-number">0</span>    &#125;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">this</span>.setState(&#123;           count: <span class="hljs-number">1</span>         &#125;, <span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count) <span class="hljs-comment">//1</span>         &#125;);        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count) <span class="hljs-comment">// 0</span>    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;          ...    &#125;&#125;</code></pre><p>由于我们认为setState是异步的，所以会认为回调函数是异步回调，控制台先输出0后输出1。<br>再看一个例子：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    state = &#123;        count: <span class="hljs-number">0</span>    &#125;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">this</span>.setState(&#123;           count: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span>         &#125;, <span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count) <span class="hljs-comment">//1</span>         &#125;);         <span class="hljs-built_in">this</span>.setState(&#123;           count: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span>         &#125;, <span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count) <span class="hljs-comment">//1</span>         &#125;);    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        ...    &#125;&#125;</code></pre><p>在这个例子中，连续调用两次setState，但是React在同一个周期内会对多个setState进行批处理。相同于：</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.assign(    previousState,    &#123;<span class="hljs-attr">count</span>: state.count + <span class="hljs-number">1</span>&#125;,    &#123;<span class="hljs-attr">count</span>: state.count + <span class="hljs-number">1</span>&#125;)</code></pre><p>后调用的setState()将覆盖同一周期内先调用setState的值，因此count其实只增加1次。如果后续状态取决于当前状态，setState(updater[,callback]) 中的第一个参数建议使用函数形式的代替。</p><pre><code class="hljs js"><span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.count + <span class="hljs-number">1</span>&#125;&#125;)</code></pre><p>再看一个具有迷惑性的例子：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    state = &#123;        count: <span class="hljs-number">0</span>    &#125;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-comment">//第一次setState</span>        <span class="hljs-built_in">this</span>.setState(          preState=&gt; (&#123;            count:preState.count + <span class="hljs-number">1</span>        &#125;),<span class="hljs-function">()=&gt;</span>&#123;           <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count);<span class="hljs-comment">//2</span>        &#125;);        <span class="hljs-comment">//第二次setState</span>        <span class="hljs-built_in">this</span>.setState(          preState=&gt;(&#123;            count:preState.count + <span class="hljs-number">1</span>        &#125;),<span class="hljs-function">()=&gt;</span>&#123;           <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count);<span class="hljs-comment">//2</span>        &#125;);    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        ...    &#125;&#125;</code></pre><p>这里为什么又会输出2，2呢？当调用seState函数时，就会把当前的操作放入一个队列中。React根据队列内容，<strong>合并state数据</strong>，合并完成后再逐一执行回调，根据结果渲染虚拟DOM，触发渲染.所以回调时,state已经合并计算完成了,输出的结果就是2, 2了。</p><p>为什么React团队采用这样一种行为模式，而不是同步进行呢？一种常见的说法是：为了优化。通过异步操作的方式，累计更新后批量合并处理，减少渲染次数，提升性能。但是同步就不能批量处理吗？github上有人提出了<a href="https://github.com/facebook/react/issues/11527">为什么setState是异步的</a>这个问题，官方团队进行了回答：</p><ol><li><p>保持内部一致性。如果改为同步更新的方式，尽管setState变成了同步，但是props不是（you can’t know props until you rerender the parent component ,and if you do this synchronously, batching goes out of the window–props是同步的话，批处理将无法进行）</p></li><li><p>为后续的架构升级启用并发更新。为了完成异步渲染，react会在setState时，根据它们的数据来源分配不同的优先级，这些数据来源有：事件回调句柄、动画效果等，再根据优先级并发处理，提升渲染性能。</p></li></ol><p>从React17的角度分析，异步的设计是合理的，它可以使得异步渲染等最终能在React落地。那什么情况下它是同步的呢？</p><h4 id="三、同步场景"><a href="#三、同步场景" class="headerlink" title="三、同步场景"></a>三、同步场景</h4><p>上面的异步场景让我们觉得：setState是异步的，但是下面这个案例中，将setState放在setTimeout中，情况又完全不同了。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    state = &#123;        count: <span class="hljs-number">0</span>    &#125;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span> &#125;);        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count);<span class="hljs-comment">//0</span>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span> &#125;);          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;setTimeout: &quot;</span> + <span class="hljs-built_in">this</span>.state.count); <span class="hljs-comment">//1</span>        &#125;, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        ...    &#125;&#125;</code></pre><p>为什么会输出0，1呢？因为setState并不是真正的异步函数，<strong>它实际上是通过队列延迟执行操作实现的</strong>，通过isBatchingUpdates来判断setState是先存进state队列还是直接更新。isBatchingUpdates值为true,则执行异步操作，isBatchingUpdates值为false,则直接更新。<br><img src="https://ae02.alicdn.com/kf/Hae4f7b71dba44f14b0405b74c565c191R.png" alt="setState的执行机制"></p><p>在onClick,onFocus等事件中，由于合成事件封装了一层，所以可以将isBatchingUpdates的状态更新为true; 在React自己的生命周期和合成事件中，可以拿到isBatchingUpdates的控制权，将状态放进队列，控制执行节奏。而在外部的原生事件中，并没有外层封装和拦截，无法更新isBatchingUpdates的状态为true。这就造成isBatchingUpdates的状态只会为false, 且立即执行。所以在addEventListener、setTimeout、setInterval这些原生事件中都会同步更新。</p><h4 id="四、回答问题"><a href="#四、回答问题" class="headerlink" title="四、回答问题"></a>四、回答问题</h4><blockquote><p>setState 并非真异步，只是看上去像异步。在源码中，通过isBatchingUpdates来判断setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。</p><p>那么什么情况下 isBatchingUpdates 会为 true 呢?</p><p>A. 在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。</p><p>B. 但在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。</p><p>一般认为，做异步设计是为了性能优化、减少渲染次数，React 团队还补充了两点。</p><ol><li><p>保持内部一致性。如果将 state 改为同步更新，那尽管 state 的更新是同步的，但是 props不是。</p></li><li><p>启用并发更新，完成异步渲染。</p></li></ol></blockquote><p>可以看出，setState是异步还是同步的关键在于：更新队列。将上述过程整理为思维导图如下：</p><p><img src="https://ae02.alicdn.com/kf/Hac1e627114684a4db843b27cdfaf12edm.png" alt="setState的执行场景"></p><p><font color=green>进阶</font> — 再看一道题</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  state  = &#123;      count: <span class="hljs-number">0</span>  &#125;;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span>&#125;);    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count);<span class="hljs-comment">//0</span>    <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span>&#125;);    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count);<span class="hljs-comment">//0</span>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span>&#125;);      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count);<span class="hljs-comment">//2</span>      <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span>&#125;);      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count);<span class="hljs-comment">//3</span>    &#125;, <span class="hljs-number">0</span>);  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  &#125;&#125;;</code></pre><p>输出：0 0 2 3</p><p>分析：</p><ul><li>首先第一次和第二次的 console.log，都在 React 的生命周期事件中，所以是异步的处理方式，则输出都为 0；</li><li>而在 setTimeout 中的 console.log 处于原生事件中，所以会同步的处理再输出结果，但需要注意，虽然 count 在前面经过了两次的 this.state.count + 1，但是由于前面说的批处理和覆盖的特点，setTimeout中拿到的值是1，那么后续在 setTimeout 中的输出则是 2 和 3</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试05-如何设计React组件？</title>
    <link href="/2020/12/17/%E9%9D%A2%E8%AF%9505-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1React%E7%BB%84%E4%BB%B6%EF%BC%9F/"/>
    <url>/2020/12/17/%E9%9D%A2%E8%AF%9505-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1React%E7%BB%84%E4%BB%B6%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="面试场景5：如何设计React组件？"><a href="#面试场景5：如何设计React组件？" class="headerlink" title="面试场景5：如何设计React组件？"></a>面试场景5：如何设计React组件？</h4><p>分析问题：“如何设计React组件？”其实就是在考察你是否了解React的设计模式。</p><p>如果在实际开发中，缺乏一个指导性的设计模式，代码会非常凌乱，经常出现下面的情况：</p><ul><li>将一个页面写成一个组件</li><li>一个组件包含上千行代码</li></ul><p>这些都没有明显的模块划分，缺乏组合的思想。所以，如何将组件更好地组合，这是第一个需要探讨的问题。基于不同的业务场景，组件的组合形式是不一样的。所以，回答这个问题，可以结合具体的场景来谈。</p><h4 id="一、React组件的分类"><a href="#一、React组件的分类" class="headerlink" title="一、React组件的分类"></a>一、React组件的分类</h4><p>React社区中非常经典的分类模式：</p><ul><li><font color=blue>展示组件</font>：把只做展示、独立运行，不额外增加功能的组件称为<strong>哑组件</strong>，或<strong>无状态组件</strong>，也叫做<strong>展示组件</strong>。</li><li><font color=blue>灵巧组件</font>：把处理业务逻辑与数据状态的组件称为有<strong>状态组件</strong>，或<strong>灵巧组件</strong>（灵巧组件一定包含至少一个灵巧组件或者展示组件）</li></ul><p>展示组件的复用性更强，灵巧组件更专注于业务本身。<br><img src="https://i.bmp.ovh/imgs/2020/12/bbe88509298c9a03.png" alt="组件设计模式"></p><h4 id="二、展示组件"><a href="#二、展示组件" class="headerlink" title="二、展示组件"></a>二、展示组件</h4><p>展示组件是没有状态管理的，完全受制于外部的props控制。展示组件的<strong>通用性和复用率很高</strong>，甚至可以做到跨项目级的复用。</p><p>展示组件中最常用的是代理组件。</p><h5 id="2-1、代理组件"><a href="#2-1、代理组件" class="headerlink" title="2.1、代理组件"></a>2.1、代理组件</h5><p>代理组件用于封装常用属性，减少重复代码。</p><p>举个例子，当需要定义一个按钮的时候，需要在按钮上添加button属性：</p><pre><code class="hljs js">&lt;button type=<span class="hljs-string">&#x27;button&#x27;</span> /&gt;</code></pre><p>但是在React中使用的时候，不可能每次都写这样一段代码，过于麻烦。常见的做法就是封装：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> Button = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span>    &lt;button type=<span class="hljs-string">&#x27;button&#x27;</span> &#123;...props&#125;&gt;</code></pre><p>在开发中使用Button组件代替原生button,可以确保type一致。</p><p>在使用Antd进行开发时，也可以采用类似的设计模式：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;Button <span class="hljs-keyword">as</span> AntdButton&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;<span class="hljs-keyword">const</span> Button = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span>     &lt;AntdButton size=<span class="hljs-string">&#x27;small&#x27;</span> type=<span class="hljs-string">&#x27;primary&#x27;</span> &#123;...props&#125;/&gt;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Button;</code></pre><p>进行封装可以切断外部组件库的强依赖特性。在大厂中引入外部组件库通常要考虑两点：</p><ul><li><p>如果当前组件库不能使用了，是否可以实现业务上的无痛切换？</p></li><li><p>如果需要进行批量修改基础组件的字段，如何解决？</p></li></ul><p>代理组件的设计模式很好地解决了这两个问题。从业务上看，代理组件隔绝了Antd，仅仅是一个组件Props API层地交互。这一层如果未来需要更换，可以保证兼容、快速替换。其次，如果要修改基础组件的颜色、大小、间距，代理组件也可以相对优雅地解决。</p><p>基于这个思想，可以封装类似的其他组件，比如样式组件。</p><h5 id="2-2、样式组件"><a href="#2-2、样式组件" class="headerlink" title="2.2、样式组件"></a>2.2、样式组件</h5><p>样式组件也是一种代理组件，只是焦点放在了处理样式上。在工程实践中，我们并不会因为一个className而封装一个组件：</p><pre><code class="hljs js"><span class="hljs-comment">//一般不会这样做</span><span class="hljs-keyword">const</span> Button = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span>(    &lt;button type=<span class="hljs-string">&#x27;button&#x27;</span> className=<span class="hljs-string">&#x27;btn btn-primary&#x27;</span>&gt;)</code></pre><p>真实工程中的样式管理往往比较复杂，类似于下面这样：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> classNames <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;classNames&#x27;</span>;<span class="hljs-keyword">const</span> StyleButton =<span class="hljs-function">(<span class="hljs-params">&#123;className, primary, isHeight,...props&#125;</span>) =&gt;</span> (    &lt;Button        type=<span class="hljs-string">&#x27;button&#x27;</span>        className=&#123;classNames(<span class="hljs-string">&#x27;btn&#x27;</span>,&#123;btn-primary:primary,<span class="hljs-attr">highLight</span>:isHighLighted,&#125;className)&#125;        &#123;...props&#125;    / &gt;)</code></pre><p>如果直接使用Button,在属性上修改，对于工程代码而言就是编写大量的面条代码。而StyleButton的思路是将样式判断逻辑分离到自身上，更友好。</p><h5 id="2-3、布局组件"><a href="#2-3、布局组件" class="headerlink" title="2.3、布局组件"></a>2.3、布局组件</h5><p>布局组件的基本设计与样式组件完全一样，但是它基于自身特性做了一个小优化。</p><p>布局组件主要用于安放其他组件，类似于这样：</p><pre><code class="hljs js">&lt;Layout    Top=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">NavBar</span> /&gt;</span></span>&#125;    Content=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Article</span> /&gt;</span></span>&#125;    Bottom=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">BottomBar</span> /&gt;</span></span>&#125;/&gt;</code></pre><p>布局本身是确定的，不需要根据外部状态变化去修改内部组件，所以这也是一个减少渲染的优化点。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Layout</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-comment">//由于布局组件无需更新，就可以把shouldComponentUpdate的返回值写死，从而阻断渲染过程</span>    <span class="hljs-function"><span class="hljs-title">shouldComponentUpdate</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        &lt;div&gt;            &lt;div&gt;&#123;<span class="hljs-built_in">this</span>.props.NavBar&#125;&lt;/div&gt;            &lt;div&gt;&#123;<span class="hljs-built_in">this</span>.props.Article&#125;&lt;/div&gt;            &lt;div&gt;&#123;<span class="hljs-built_in">this</span>.props.BottomBar&#125;&lt;/div&gt;        &lt;/div&gt;    &#125;&#125;</code></pre><h4 id="三、灵巧组件"><a href="#三、灵巧组件" class="headerlink" title="三、灵巧组件"></a>三、灵巧组件</h4><p>由于灵巧组件面向业务，相对于展示组件来说，其功能更加丰富、复杂性更高，所以其复用性更低。<strong>展示组件专注于组件本身特性，灵巧组件更专注于组合组件</strong>。最常见的案例就是容器组件。</p><h5 id="3-1、容器组件"><a href="#3-1、容器组件" class="headerlink" title="3.1、容器组件"></a>3.1、容器组件</h5><p>容器组件几乎没有复用性，它主要用于：拉取数据与组合组件。<br>一个例子：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> CardList = <span class="hljs-function">(<span class="hljs-params">&#123;cards&#125;</span>) =&gt;</span> (    &lt;div&gt;        &#123;cards.map(<span class="hljs-function"><span class="hljs-params">card</span>=&gt;</span>(            &lt;CardLayout                header=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&#123;card.avatarUrl&#125;</span> /&gt;</span></span>&#125;                Content=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Card</span> &#123;<span class="hljs-attr">...card</span>&#125; /&gt;</span></span>&#125;            /&gt;            &#123;comment.body&#125; - &#123;comment.author&#125;        ))&#125;    &lt;/div&gt;)</code></pre><p>上述代码中的CardList组件，负责将cards数据渲染出来。接下来就是获取网络数据：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CardListContainer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    state=&#123; <span class="hljs-attr">cards</span>: []&#125;    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/api/cards&#x27;</span>)        <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">cards</span>:response &#125;)    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CardList</span> <span class="hljs-attr">cards</span>=<span class="hljs-string">&#123;this.state.cards&#125;</span> /&gt;</span></span>    &#125;&#125;</code></pre><p>这样切分代码后，容器组件内非常干净，没有冗余得样式和逻辑处理。其实这也用到了“关注点分离”的策略。那么面对复用性更强的业务逻辑用什么处理呢？</p><h5 id="3-2、高阶组件"><a href="#3-2、高阶组件" class="headerlink" title="3.2、高阶组件"></a>3.2、高阶组件</h5><p>React官方文档中将高阶组件称为是react中<strong>复用组件逻辑的高级技术</strong>。高阶组件本身并不是React API的一部分，它是一种基于React的组合特性而形成的设计模式。实际上，高阶组件就是以组件为参数，返回一个新组件的函数。</p><p>这听起来非常像<strong>高阶函数</strong>：如果一个函数可以接收另一个函数作为参数，且在执行后返回一个函数，则称其为高阶函数。 react团队在组件方向也汲取了同样的设计模式，源自高阶函数的高阶组件，可以优雅地抽取公共逻辑。</p><p>参考：<a href="https://zh-hans.reactjs.org/docs/higher-order-components.html#gatsby-focus-wrapper">React官网-高阶组件</a></p><p><strong>高阶组件抽取公共逻辑</strong>：</p><p>一个常见的例子，登录态的判断。假设当前项目有订单页面、用户信息页面及购物车首页，那么订单页面和用户信息页面都需要检查当前是否已登录。如果没有登录，则应该跳转至登录页面。</p><p>一般思路如下：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> checkLogin = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-comment">//!!XXX用于转为布尔值</span>    <span class="hljs-keyword">return</span> !!LocalStorage.getItem(<span class="hljs-string">&#x27;token&#x27;</span>)&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    ...&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">!checkLogin</span>)</span>&#123;            <span class="hljs-comment">//重定向到登录页面</span>        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">!checkLogin</span>)</span>&#123;            <span class="hljs-comment">//重定向到登录页面</span>        &#125;    &#125;&#125;</code></pre><p>上述代码虽然将登录态的判断抽取到了一个函数中，但是还是需要在相应的页面加上判断逻辑。如果有高阶组件的话，情况会完全不同：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> checkLogin = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-keyword">return</span> !!LocalStorage.getItem(<span class="hljs-string">&#x27;token&#x27;</span>)&#125;<span class="hljs-keyword">const</span> checkLogin = <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> checkLogin() ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span>: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoginPage</span>/&gt;</span></span>    &#125;&#125;<span class="hljs-comment">//1、函数写法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RawUserPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;    ...&#125;<span class="hljs-keyword">const</span> UserPage = checkLogin(RawUserPage);<span class="hljs-comment">//2、装饰器写法</span>@checkLogin<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    ...&#125;@checkLogin<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    ...&#125;</code></pre><p>可以看出，使用了高阶组件后，无论采用函数写法还是装饰器写法，重复代码量都下降了一个维度。<br>还有一个非常经典的常见就是<strong>页面埋点统计</strong>：如果采用装饰器写，大致如下：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> trakPageView = <span class="hljs-function">(<span class="hljs-params">pageName</span>) =&gt;</span>&#123;    <span class="hljs-comment">//发送埋点信息</span>&#125;<span class="hljs-keyword">const</span> PV = <span class="hljs-function">(<span class="hljs-params">pageName</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>)=&gt;</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;            <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;                trackPageView(pageName)            &#125;            <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;                <span class="hljs-keyword">return</span> (                    &lt;WrappedComponent &#123;...this.props&#125; /&gt;                );            &#125;        &#125;    &#125;;&#125;@PV(<span class="hljs-string">&#x27;用户页面&#x27;</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    ...&#125;@PV(<span class="hljs-string">&#x27;购物车页面&#x27;</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    ...&#125;@PV(<span class="hljs-string">&#x27;订单页面&#x27;</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    ...&#125;</code></pre><p>这样就连埋点的繁琐操作都变得优雅了起来。如果我想同时判断登录态和埋点呢？就是同时使用checkLogin 与 PV应该怎么做呢？这里涉及了一个新的概念：链式调用。</p><p><strong>链式调用</strong>：</p><p>由于高阶组件返回的是一个新的组件，所以链式调用是默认支持的。基于checkLogin 与 PV两个例子，链式使用是这样的：</p><pre><code class="hljs js"><span class="hljs-comment">//函数调用方式</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RawUserPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    ...&#125;<span class="hljs-keyword">const</span> UserPage = checkLogin(PV(<span class="hljs-string">&#x27;用户页面&#x27;</span>)(RawUserPage));<span class="hljs-comment">//装饰器调用方式</span>@checkLogin@PV(<span class="hljs-string">&#x27;用户界面&#x27;</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    ...&#125;</code></pre><p><strong>渲染劫持</strong>：</p><p>渲染劫持可以通过控制render函数修改输出内容，常见的场景是显示加载元素：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withLoding</span>(<span class="hljs-params">WrappedComponent</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WrappedComponent</span></span>&#123;        <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-built_in">this</span>.props.isLoding</span>)</span> &#123;                <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Loading</span> /&gt;</span></span>            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.render();            &#125;        &#125;    &#125;&#125;</code></pre><p>上述代码通过高阶组件继承原组件的方式，劫持修改render函数，篡改返回值，达到显示Loading的效果。但是高阶组件并非万能，它同样也有缺陷。</p><p><strong>高阶组件缺陷</strong>：</p><ol><li><font color=green>丢失静态函数</font>。 由于被包裹了一层，所以静态函数在外层是无法获取的。<pre><code class="hljs js"><span class="hljs-comment">//Userpage.jsx</span>@PV(<span class="hljs-string">&#x27;用户页面&#x27;</span>)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getUser</span>(<span class="hljs-params"></span>)</span>&#123;        ...    &#125;&#125;</code></pre>这里的getUser是无法被调用的，如果希望外界可以调用它，那么可以在PV函数中将静态函数复制过来。</li></ol><pre><code class="hljs js"><span class="hljs-keyword">const</span> PV = <span class="hljs-function">(<span class="hljs-params">pageName</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span>&#123;        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;            <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;                trackPageView(pageName)            &#125;            <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;                <span class="hljs-keyword">return</span> (                    &lt;WrappedComponent &#123;...props&#125; /&gt;                )            &#125;        &#125;        Wrap.getUser = WrappedComponent.getUser;        <span class="hljs-keyword">return</span> Wrap;    &#125;&#125;</code></pre><p>但是一个类的静态函数可能有很多，不可能都这样进行手动复制。于是，社区中出现了现成的工具：通过hoist-non-react-statics处理，可以自动复制所有静态函数。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> hoistNonReactStatics <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;hoist-non-react-statics&#x27;</span>;<span class="hljs-keyword">const</span> PV = <span class="hljs-function">(<span class="hljs-params">pageName</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> &#123;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;      <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;        trackPageView(pageName)      &#125;      <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> (          &lt;WrappedComponent &#123;...this.props&#125; /&gt;        );      &#125;    &#125;     hoistNonReactStatics(Wrap, WrappedComponent);     <span class="hljs-keyword">return</span> Wrap;  &#125;; &#125;</code></pre><ol start="2"><li><font color=green>refs属性不能透传。</font> ref属性由于被高阶组件包裹了一次，所以需要进行特殊处理才能获取。React为我们提供了一个React.forwardRef 的API来解决这个问题，以下是官方文档的一个案例：</li></ol><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withLog</span>(<span class="hljs-params">Component</span>) </span>&#123;  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogProps</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params">prevProps</span>)</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;old props:&#x27;</span>, prevProps);      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;new props:&#x27;</span>, <span class="hljs-built_in">this</span>.props);    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;      <span class="hljs-keyword">const</span> &#123;forwardedRef, ...rest&#125; = <span class="hljs-built_in">this</span>.props;      <span class="hljs-comment">// 将自定义的 prop 属性 “forwardedRef” 定义为 ref</span>      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;forwardedRef&#125;</span> &#123;<span class="hljs-attr">...rest</span>&#125; /&gt;</span></span>;    &#125;  &#125;  <span class="hljs-comment">// 注意 React.forwardRef 回调的第二个参数 “ref”。</span>  <span class="hljs-comment">// 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”</span>  <span class="hljs-comment">// 然后它就可以被挂载到被 LogProps 包裹的子组件上。</span>  <span class="hljs-keyword">return</span> React.forwardRef(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LogProps</span> &#123;<span class="hljs-attr">...props</span>&#125; <span class="hljs-attr">forwardedRef</span>=<span class="hljs-string">&#123;ref&#125;</span> /&gt;</span></span>;  &#125;);&#125;</code></pre><p>这段代码读起来会有点儿头皮发麻，它正确的阅读顺序应该是从最底下的 React.forwardRef 部分开始，通过 forwardedRef 转发 ref 到 LogProps 内部。</p><p>参考：<a href="https://zh-hans.reactjs.org/docs/react-api.html#reactforwardref">React官网 - React.forwardRef</a></p><h4 id="四、工程实践"><a href="#四、工程实践" class="headerlink" title="四、工程实践"></a>四、工程实践</h4><p>通过以上的梳理，我们来看一下如何在目录中给组件安排位置。</p><pre><code class="hljs js">src├── components│   ├── basic(基本展示组件)│   ├── container(容器组件)│   └── hoc(高阶组件)└── pages</code></pre><p>在实际开发中，针对basic组件，可以使用StoryBook的工具进行组件管理。它可以有组织地、高效地构建基础组件。可参考<a href="https://storybook.js.org/">Storybook官网</a>。</p><h4 id="五、答题"><a href="#五、答题" class="headerlink" title="五、答题"></a>五、答题</h4><p>经过上面几个章节的归类分析，关于React组件的设计，我们应该从设计与工程实际两个方向探讨。</p><blockquote><p>从设计上而言，社区主流分类的方案是展示组件与灵巧组件。</p><p>展示组件内部没有状态管理，仅仅用于最简单的展示表达。展示组件中最基础的一类组件称作代理组件。代理组件常用于封装常用属性、减少重复代码。很经典的场景就是引入 Antd 的 Button 时，你再自己封一层。如果未来需要替换掉 Antd 或者需要在所有的 Button 上添加一个属性，都会非常方便。基于代理组件的思想还可以继续分类，分为样式组件与布局组件两种，分别是将样式与布局内聚在自己组件内部。</p><p>灵巧组件由于面向业务，其功能更为丰富，复杂性更高，复用度低于展示组件。最经典的灵巧组件是容器组件。在开发中，我们经常会将网络请求与事件处理放在容器组件中进行。容器组件也为组合其他组件预留了一个恰当的空间。还有一类灵巧组件是高阶组件。高阶组件被 React 官方称为 React 中复用组件逻辑的高级技术，它常用于抽取公共业务逻辑或者提供某些公用能力。常用的场景包括检查登录态，或者为埋点提供封装，减少样板代码量。高阶组件可以组合完成链式调用，如果基于装饰器使用，就更为方便了。高阶组件中还有一个经典用法就是反向劫持，通过重写渲染函数的方式实现某些功能，比如场景的页面加载圈等。但高阶组件也有两个缺陷，第一个是静态方法不能被外部直接调用，需要通过向上层组件复制的方式调用，社区有提供解决方案，使用 hoist-non-react-statics 可以解决；第二个是 refs 不能透传，使用 React.forwardRef API 可以解决。</p><p>从工程实践而言，通过文件夹划分的方式切分代码。我初步常用的分割方式是将页面单独建立一个目录，将复用性略高的 components 建立一个目录，在下面分别建立 basic、container 和 hoc 三类。这样可以保证无法复用的业务逻辑代码尽量留在 Page 中，而可以抽象复用的部分放入 components 中。其中 basic 文件夹放展示组件，由于展示组件本身与业务关联性较低，所以可以使用 Storybook 进行组件的开发管理，提升项目的工程化管理能力。</p></blockquote><p>整理为思维导图如下：<br><img src="https://pic.downk.cc/item/5fdc10213ffa7d37b31b801d.jpg" alt="React组件设计"></p><p><strong>总结</strong>:</p><p>在本讲中主要对 React 组件的设计模式进行了梳理与回顾，并探讨了设计模式在工程实践中的作用。</p><p>在面试中面试官不仅希望听到设计模式有哪些，社区的推荐方式有哪些，更希望听到模式具体用在哪儿。如果你知道具体的场景，就会显得更有经验。设计模式并非有确定的标准答案，社区流行的分类方式也并非万能。如果你有自己的见解，在面试中与面试官进行探讨，也是非常值得鼓励的。</p>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试04-类组件与函数组件有什么区别呢？</title>
    <link href="/2020/12/10/%E9%9D%A2%E8%AF%9504-%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F/"/>
    <url>/2020/12/10/%E9%9D%A2%E8%AF%9504-%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="面试场景4：类组件与函数组件有什么区别？（比较题）"><a href="#面试场景4：类组件与函数组件有什么区别？（比较题）" class="headerlink" title="面试场景4：类组件与函数组件有什么区别？（比较题）"></a>面试场景4：类组件与函数组件有什么区别？（比较题）</h4><p>描述区别，就是求同存异的过程：</p><ul><li>在确认共性的基础上，才能找到它独特的个性</li><li>通过具体的场景逐个阐述它的个性。</li></ul><p>针对“ 类组件与函数组件有什么区别呢？”这个面试题，面试官想知道的是：</p><ul><li>你对组件的两种编写模式是否了解</li><li>你是否具备在合适的场景下选用合适技术栈的能力</li></ul><h4 id="一、函数组件与类组件的相同点"><a href="#一、函数组件与类组件的相同点" class="headerlink" title="一、函数组件与类组件的相同点"></a>一、函数组件与类组件的相同点</h4><p>&emsp;组件是Rect可复用的最小代码片段，它们会返回要在页面中渲染的React元素。也正因为组件时React的最小编码单位，所以无论时类组件还是函数组件，在基本使用方式和最终呈现的效果上都时完全一致的。<strong>函数组件和类组件作为组件本省的所有基础功能都是一致的，都可以用它们作为基础组件展示UI。</strong></p><p>&emsp;从使用者的角度看，很难从使用体验上区分两者，而且在现代浏览器中，闭包和类的性能只有在极端场景下才有明显的差别。你甚至可以将一个类组件改写为函数组件，或者把函组件改成一个类组件（虽然不推荐这种重构）</p><p>&emsp;基本上可以认为两种组件时完全一致的。</p><h4 id="二、函数组件与类组件的不同点"><a href="#二、函数组件与类组件的不同点" class="headerlink" title="二、函数组件与类组件的不同点"></a>二、函数组件与类组件的不同点</h4><p><strong>1、两种组件代表了两种不同的设计思想与心智模式。</strong></p><ul><li>类组件的根基是OOP(面向对象编程)，所以它有继承、有属性、有内部状态的管理。</li><li>函数组件的根基是FP（函数式编程），它属于结构化编程的一种，与数学函数思想类似。也就是假定输入与输出存在某种特定的映射关系，那么在输入一定的情况下，输出必然是确定的。</li></ul><p>本质上两者最大的不同：<strong>相比较于类组件，函数组件更纯粹、简单、易于测试。</strong></p><p>（函数组件的确定性：在函数组件的闭包中，它捕获的值永远是确定且安全的。也叫<font color=green>值捕获特性</font>）</p><p><strong>2、类组件的独有能力 VS  函数组件+Hooks</strong></p><p><strong>类组件可以通过生命周期包装业务逻辑，这是类组件所特有的。</strong> 我们可以在componentDidMount、componentWillUnmout、shouldComponentUpdate等生命周期完成一些业务逻辑。 </p><p>在还没有Hooks的年代，函数组件的能力很弱，只能用高阶组件包裹函数组件模拟生命周期，但是这样做并没有解决业务逻辑掺杂在生命周期中的问题。后来React团队引入了Hooks,并基于Hooks创建了一个完全耳目一新的方案：不是让函数组件去模仿类组件的功能，而是提供新的开发模式，让组件渲染和业务逻辑更加分离。</p><p>小结：在Hooks的加持下，函数式组件也可以实现类似生命周期的能力，类组件所特有的生命周期也不再是其独有的功能。类组件与函数组件的边界模糊化。</p><p><strong>3、设计模式</strong></p><p>在设计模式上，因为类本身的特点，类组件是可以实现继承的，而函数组件缺少继承的能力。 但是React本身有条铁律：<strong>组合优于继承</strong>。并不推崇继承已有组件，因为继承的灵活性更差，细节屏蔽过多。</p><p><strong>4、性能优化</strong></p><p>类组件和函数组件进行性能优化的方式: </p><ul><li>类组件的优化主要是依靠 shouldComponentUpdate函数去阻断渲染</li><li>函数组件一般是靠React.memo来优化。React.memo并不是去阻断渲染，具体参考<a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo">官方文档-React.memo</a></li></ul><p><strong>5、未来的趋势</strong></p><p>由于React Hooks的推出，<strong>函数组件成了社区未来主推的方案</strong>。React从实际业务出发，探索了时间切片与并发模式，考虑性能的进一步优化与组件间合理的代码拆分结构后，认为类组件并不能很好的适应未来的趋势，并给出了3个原因：</p><ul><li>this指代的模糊性</li><li>业务逻辑散落在生命周期中</li><li>React的组件代码缺乏标准的拆分方式</li></ul><p>而使用了Hooks的函数组件可以提供比原先更细粒度的逻辑组织与复用，且能更好地适用于时间切片与并发模式。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><img src="https://pic.downk.cc/item/5fd4636c3ffa7d37b3de82b8.jpg" alt="函数组件与类组件的区别"></p><p><font color=red>答题：</font></p><blockquote><p>作为组件而言，类组件与函数组件在使用与呈现上没有任何不同，性能上在现代浏览器中也不会有明显差异。<br>它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。</p><p>之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。</p><p>但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。</p><p>其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。</p><p>性能优化上，类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能，而函数组件依靠 React.memo 缓存渲染结果来提升性能。</p><p>从上手程度而言，类组件更容易上手，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的方案。</p><p>类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>React05-受控组件与非受控组件</title>
    <link href="/2020/12/09/React05-%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/"/>
    <url>/2020/12/09/React05-%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="Controlled-Components-VS-unControlled-Components"><a href="#Controlled-Components-VS-unControlled-Components" class="headerlink" title="Controlled Components VS unControlled Components"></a>Controlled Components VS unControlled Components</h3><h4 id="一、非受控组件"><a href="#一、非受控组件" class="headerlink" title="一、非受控组件"></a>一、非受控组件</h4><p>先看一个非受控组件的例子：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span>(    &lt;div&gt;        &lt;label&gt;            My uncontrolled Input:            &lt;input type=<span class="hljs-string">&#x27;text&#x27;</span>/&gt;        &lt;/label&gt;    &lt;/div&gt;)</code></pre><p>上述代码中的input是不受控制的HTML元素，通常我们也将封装了这种元素的APP组件称为是 “非受控组件”。</p><p>🐖：判断一个组件受控与否，跟它是函数组件还是类组件没有关系！</p><p>这里的input是不受控的，因为当我们启动这个application后，我们可以在输入框种编辑任何内容，但是我们编辑出来的东西没有展示在其他任何地方，也没有任何行为看可以去改变我们打进去的值。毕竟，这里的input就是一个原生的HTML元素，它自己管理自己的内部状态，而不受任何外界的控制。</p><p>我们再来看另外一个例子，这个例子更容易让我们混淆受控组件与非受控组件：</p><pre><code class="hljs js"><span class="hljs-comment">//添加state management 和 React Hooks</span><span class="hljs-keyword">import</span> React, &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">const</span> [value, setValue] = useState(<span class="hljs-string">&#x27;&#x27;</span>);    <span class="hljs-keyword">const</span> handleChange = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> setValue(event.target.value);    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;label&gt;                My still uncontrolled Input:                &lt;input type=<span class="hljs-string">&#x27;text&#x27;</span> onChange=&#123;handleChange&#125; /&gt;            &lt;/label&gt;            &lt;p&gt;                &lt;strong&gt;Output: &lt;/strong&gt; &#123;value&#125;            &lt;/p&gt;        &lt;/div&gt;    );&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>我们把在输入框编辑的内容展示到一个段落中（output的后面），当我们启动这个程序后，input输入框编辑什么，output后面也会展示什么。但是，它依然是个非受控组件。这是为什么呢？下面我们把initialState里面写入内容，来解释这个问题：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">const</span> [value, setValue] = useState(<span class="hljs-string">&#x27;Hello React&#x27;</span>);    <span class="hljs-keyword">const</span> handleChange = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> setValue(event.target.value);    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;label&gt;                My still uncontrolled Input:                &lt;input type=<span class="hljs-string">&#x27;text&#x27;</span> onChange=&#123;handleChange&#125; /&gt;            &lt;/label&gt;            &lt;p&gt;                &lt;strong&gt;Output: &lt;/strong&gt; &#123;value&#125;            &lt;/p&gt;        &lt;/div&gt;    );&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>运行这个程序后，我们可以看到区别了：<br><img src="https://pic.downk.cc/item/5fd0c0543ffa7d37b335df1a.jpg"></p><p>我们可以看到 input框里是空的，可是output后面却是有内容的（output后面展示的就是initial state）。只有当我们往输入框中输入东西时，二者才似乎重新开始保持“同步”。但其实，<strong>input框的内容仍然是它自己的内部状态，而output后面的内容却来自于真实的React state</strong>(from handler function)。所以when typing, output后面展示的内容虽然看起来似乎和我们在输入框打进去的一样，但其实它们俩的来源不同：</p><ul><li>input filed receives its value from internal DOM node state;</li><li>output paragraph receives its value from React’s state。</li></ul><p>在我们的React应用中使用非受控组件，可能会导致很多意想不到的bug。如果想利用一种事实来源（one source of truth)来驱动UI，就应该使用props或者是state。对于一个组件来说，有相同的props和state，就应该渲染出相同的UI界面：<strong>（props, state) =&gt; view</strong></p><h4 id="二、受控组件"><a href="#二、受控组件" class="headerlink" title="二、受控组件"></a>二、受控组件</h4><p>既然非受控组件可能导致bug, 那么我们就应该把input这种不受控制的元素改为受控元素。亦即，我们为input提供一个value (它的值来源于 React state)：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>; <span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> [value, setValue] = useState(<span class="hljs-string">&#x27;Hello React&#x27;</span>);   <span class="hljs-keyword">const</span> handleChange = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> setValue(event.target.value);   <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;label&gt;        My controlled Input:        &lt;input type=<span class="hljs-string">&quot;text&quot;</span> value=&#123;value&#125; onChange=&#123;handleChange&#125; /&gt;      &lt;/label&gt;       &lt;p&gt;        &lt;strong&gt;Output:&lt;/strong&gt; &#123;value&#125;      &lt;/p&gt;    &lt;/div&gt;  );&#125;; <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>通过给input输入框提供一个来源于react state的value值，它就不再使用自己本身的内部状态了。现在，我们再来启动这个程序时，input输入框里的值和output后面展示的内容就完全一致了！（因为它们都来自于react state）<br><img src="https://pic.downk.cc/item/5fd0c4643ffa7d37b33a6f41.jpg"></p><p>参考：<a href="https://www.robinwieruch.de/react-controlled-components">What are Controlled Components in React?</a></p>]]></content>
    
    
    <categories>
      
      <category>React学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>React04-函数组件</title>
    <link href="/2020/12/09/React04-%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6/"/>
    <url>/2020/12/09/React04-%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="React-Function-Components"><a href="#React-Function-Components" class="headerlink" title="React Function Components"></a>React Function Components</h3><p>&emsp; React函数组件是编写现代React应用程序的常用方式，自从React Hook被引入之后，使得完全使用函数式组件来编写一个React应用程序成为可能。函数式组件的核心：就是一个返回JSX的JavaScript函数。</p><h4 id="一、一个简单的函数组件的例子"><a href="#一、一个简单的函数组件的例子" class="headerlink" title="一、一个简单的函数组件的例子"></a>一、一个简单的函数组件的例子</h4><p>函数式组件的例子：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> greeting = <span class="hljs-string">&#x27;hello function component!&#x27;</span>;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;greeting&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>从上述代码中，我们可以注意到函数式组件中并没有类class组件里有的render()函数。实际上，函数主体里面定义的内容都是render函数，该函数最后返JSX。</p><p>如果想在React函数组件里面，再渲染一个组件，可以像下面这样写：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">//将Headline组件作为HTML元素，以JSX的方式渲染出来</span>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Headine</span> /&gt;</span></span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Headeline</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> greeting = <span class="hljs-string">&#x27;hello function component!&#x27;</span>;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;greeting&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><h4 id="二、函数组件的参数Props"><a href="#二、函数组件的参数Props" class="headerlink" title="二、函数组件的参数Props"></a>二、函数组件的参数Props</h4><p>&emsp;在React中，props被用于组件与组件之间传递信息（父组件通过props传递信息给子组件）。Essentially props in React are always passed down the component tree;</p><p>一个使用props的例子：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> greeting = <span class="hljs-string">&#x27;hello function component&#x27;</span>;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Headline</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&#123;greeting&#125;</span> /&gt;</span></span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Headline</span>(<span class="hljs-params">props</span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;props.value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>由于props通常都是一个对象，我们也可以使用JS 对象解构的方式从props中抽取我们想要的信息。比如上面的Headline组件也可以写成下面的形式：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Headline</span>(<span class="hljs-params">&#123;value&#125;</span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&#125;<span class="hljs-comment">//需要解构多个信息出来时：</span><span class="hljs-comment">//function Headline(&#123;value1,value2&#125;)&#123;...&#125;</span></code></pre><p>关于props的更多使用：可以参考<a href="https://www.robinwieruch.de/react-pass-props-to-component">How to pass props to components in React</a></p><h4 id="三、React-箭头函数组件"><a href="#三、React-箭头函数组件" class="headerlink" title="三、React 箭头函数组件"></a>三、React 箭头函数组件</h4><p>&emsp;箭头函数组件 Arrow Funciton Components(or Lambda Function Component)，是随着ES6箭头函数的出现，引入到React中的。</p><p>用箭头函数重构上面的函数组件例子：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App=<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">const</span> greeting = <span class="hljs-string">&#x27;hello function components!&#x27;</span>;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Headline</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;greeting&#125;</span> /&gt;</span></span>&#125;;<span class="hljs-keyword">const</span> Headline=<span class="hljs-function">(<span class="hljs-params">&#123;value&#125;</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&#125;;<span class="hljs-comment">//根据箭头函数的简写规则，上面的Headline可以简写为：</span><span class="hljs-keyword">const</span> Headline = <span class="hljs-function">(<span class="hljs-params">&#123;value&#125;</span>) =&gt;</span>     &lt;h1&gt;&#123;value&#125;&lt;/h1&gt;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><h4 id="四、Stateless-Function-Component"><a href="#四、Stateless-Function-Component" class="headerlink" title="四、Stateless Function Component"></a>四、Stateless Function Component</h4><p>&emsp;到目前为止，我们写的例子里都是无状态的函数组件。它们仅仅接收一个props,然后返回一个输出【以JSX：（props)=&gt;JSX】。 这种类型的组件不需要管理state，也没有任何副作用（例如，接受浏览器的本地存储），所以我们称为“Stateless Function Component”，因为它们是无状态的且以一个函数的形式表达出来。然而，React Hooks使得函数式组件有state成为可能。</p><h4 id="五、有state的函数组件"><a href="#五、有state的函数组件" class="headerlink" title="五、有state的函数组件"></a>五、有state的函数组件</h4><p>&emsp;现在我们先移除上面例子中函数组件里的所有props:</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>; <span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Headline</span> /&gt;</span></span>;&#125;; <span class="hljs-keyword">const</span> Headline = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> greeting = <span class="hljs-string">&#x27;Hello Function Component!&#x27;</span>;   <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;greeting&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;&#125;; <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>这样，使用这个application的用户就没法和它进行任何交互，也无法改变greeting变量。The application is static and not interactive at all。  State就是让React组件变得可交互，React Hooks 帮助我们实现函数式组件也可以使用state。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App=<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Headline</span> /&gt;</span></span>;&#125;<span class="hljs-keyword">const</span> Headline=<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">const</span> [greeting , setGreeting] = useState(        <span class="hljs-string">&#x27;hello function component!&#x27;</span>    );    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;greeting&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>useState hook函数将初始状态作为参数，返回一个数组（当前的state是这个数组的第一个元素，用于改变state的函数时这个数组的第二个元素）。我们使用了数组解构的方式来获取这个数组的元素。而且数组解构允许我们自己为变量命名。</p><p>现在，让我们添加一个input field 来改变state（使用setGreeting):</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App=<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Headline</span> /&gt;</span></span>;&#125;<span class="hljs-keyword">const</span> Headline=<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">const</span> [greeting , setGreeting] = useState(        <span class="hljs-string">&#x27;hello function component!&#x27;</span>    );    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;h1&gt;&#123;greeting&#125;&lt;h1&gt;                        &lt;input                type=<span class="hljs-string">&#x27;text&#x27;</span>                value=&#123;greeting&#125;                onChange=&#123;<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> setGreeting(event.target.value)&#125;            /&gt;        &lt;/div&gt;    )&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>上述代码中，我们通过在input中添加一个event handler，这样当input中的值变化时我们就可以利用回调函数做一些事情。回调函数的参数event是一个拥有当前input域中value值的<a href="https://reactjs.org/docs/events.html">synthetic React event</a>，亦即event.target.value，被用来更新函数组件的state。后续，我们会将这个onChange事件提取出来。</p><p>🐖：这个input field 可以接受这个组件的state值。当我们想控制input的value（state）而不想让原生的HTML元素的内部状态接管input中的值时，我们可以使用组件的state值。这时，这个input就成为了”受控组件”<a href="https://www.robinwieruch.de/react-controlled-components">controlled component</a>。</p><h4 id="六、函数组件：event-handler"><a href="#六、函数组件：event-handler" class="headerlink" title="六、函数组件：event handler"></a>六、函数组件：event handler</h4><p>在第五节中，我们给input元素添加了一个onChange事件，这样我们随时可以观察到input内容的变化。但是上一节中我们使用的是内联的箭头函数给onChange事件赋值。我们可以把它抽取出来作为一个命名函数:</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Headline</span> /&gt;</span></span>;&#125;<span class="hljs-keyword">const</span> Headline = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-keyword">const</span> [greeting, setGreeting] = useState(<span class="hljs-string">&#x27;hello function component&#x27;</span>)&#125;<span class="hljs-comment">//这里就是提取出来的命名函数</span><span class="hljs-keyword">const</span> handleChange = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span>setGreeting(event.target.value);<span class="hljs-keyword">return</span>(    &lt;div&gt;        &lt;h1&gt;&#123;greeting&#125;&lt;/h1&gt;        &lt;input type=<span class="hljs-string">&#x27;text&#x27;</span> value=&#123;greeting&#125; onChange = &#123;handleChange&#125; /&gt;    &lt;/div&gt;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><h4 id="七、父组件给子组件传值-包括callback-function"><a href="#七、父组件给子组件传值-包括callback-function" class="headerlink" title="七、父组件给子组件传值(包括callback function)"></a>七、父组件给子组件传值(包括callback function)</h4><p>在第六节中的例子中，我们把所有的逻辑（包括变量和函数）都放在了子组件，也就是Headline中。父组件没有向子组件传递props,。这一节，我们将把greeting和onChange事件的处理逻辑都放在父组件App中，再通过props传递给子组件Headline。如下所示：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React,&#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-keyword">const</span> [greeting, setGreeting] = useState(<span class="hljs-string">&#x27;hello function component&#x27;</span>);    <span class="hljs-keyword">const</span> handleChange = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> setGreeting(event.target.value);    <span class="hljs-keyword">return</span> (        &lt;Headline headline = &#123;greeting&#125; onChangeHeadline = &#123;handleChange&#125; /&gt;    )&#125;<span class="hljs-keyword">const</span> Headline = <span class="hljs-function">(<span class="hljs-params">&#123;headline,onChangeHeadline&#125;</span>) =&gt;</span> (    &lt;div&gt;        &lt;h1&gt;&#123;headline&#125;&lt;/h1&gt;        &lt;input type=<span class="hljs-string">&#x27;text&#x27;</span> value=&#123;headline&#125; onChange=&#123;onChangeHeadline&#125;/&gt;    &lt;/div&gt;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>进一步地，我们还可以把input抽取出来，使其到单独成为一个组件。从而，我们有个一个父组件App，两个子组件Headline和Input。父组件向两个子组件传递props:</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React,&#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-keyword">const</span> [greeting, setGreeting] = useState(<span class="hljs-string">&#x27;hello function component&#x27;</span>);    <span class="hljs-keyword">const</span> handleChange = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span>setGreeting(event.target.value);    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;Headline headline=&#123;greeting&#125; /&gt;            &lt;Input value=&#123;greeting&#125; onChangeInput=&#123;handleChange&#125;&gt;<span class="hljs-built_in">Set</span> Greeting: &lt;/Input&gt;        &lt;/div&gt;    )&#125;;<span class="hljs-keyword">const</span> Headline = <span class="hljs-function">(<span class="hljs-params">&#123;headline&#125;</span>) =&gt;</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;headline&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-keyword">const</span> Input = <span class="hljs-function">(<span class="hljs-params">&#123;value,onChangeInput, children&#125;</span>) =&gt;</span>(    &lt;label&gt;    &#123;children&#125;    &lt;input type=<span class="hljs-string">&#x27;text&#x27;</span> value=&#123;value&#125; onChange = &#123;onChangeInput&#125; /&gt;    &lt;/label&gt;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><h4 id="八、设置props的默认值"><a href="#八、设置props的默认值" class="headerlink" title="八、设置props的默认值"></a>八、设置props的默认值</h4><p>当父组件给子组件传递props的时候，我们可以在子组件中为这些props设置默认值（default value）去override传递的值。亦即，当父组件传递的props不为空时，我们就使用传递过来的，否则我们就使用子组件的默认值。</p><p>给子组件的props设置默认值,有以下三种方式：</p><pre><code class="hljs js"><span class="hljs-comment">//第一种：</span><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-keyword">const</span> sayHello = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">handleClick</span>=<span class="hljs-string">&#123;sayHello&#125;</span> /&gt;</span></span>&#125;;<span class="hljs-keyword">const</span> Button = <span class="hljs-function">(<span class="hljs-params">&#123;handleClick&#125;</span>) =&gt;</span>&#123;    <span class="hljs-keyword">const</span> sayDefault = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;default&#x27;</span>);    <span class="hljs-keyword">const</span> onClick = handleClick || sayDefault;    <span class="hljs-keyword">return</span> (        &lt;button type=<span class="hljs-string">&#x27;button&#x27;</span> onClick=&#123;onClick&#125;&gt;            Button        &lt;/button&gt;    )&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>我们也可以在子组件的函数签名（小括号内）为props设置默认值：</p><pre><code class="hljs js"><span class="hljs-comment">//第二种：</span><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> sayHello = <span class="hljs-function">() =&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello&#x27;</span>);    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">handleClick</span> = <span class="hljs-string">&#123;sayHello&#125;</span> /&gt;</span></span>&#125;;<span class="hljs-keyword">const</span> Button = (&#123;handleClick = <span class="hljs-function">()=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;default&#x27;</span>)&#125;) =&gt; (    &lt;button onClick=&#123;handleClick&#125;&gt;        Button    &lt;/button&gt;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>最后一种，我们也可以通过为函数组件增加defaultProps属性的方式来设置默认值：</p><pre><code class="hljs js"><span class="hljs-comment">//第三种：</span><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> sayHello = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello&#x27;</span>);   <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">handleClick</span>=<span class="hljs-string">&#123;sayHello&#125;</span> /&gt;</span></span>;&#125;; <span class="hljs-keyword">const</span> Button = <span class="hljs-function">(<span class="hljs-params">&#123;handleClick&#125;</span>) =&gt;</span>(    &lt;button onClick=&#123;handleClick&#125;&gt;        Button    &lt;/button&gt;);Button.defaultProps = &#123;    handleClick: <span class="hljs-function">()=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;default&#x27;</span>);&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><h4 id="九、React组件中的异步函数"><a href="#九、React组件中的异步函数" class="headerlink" title="九、React组件中的异步函数"></a>九、React组件中的异步函数</h4><p>让我们先来看一个异步函数的例子：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-comment">//通过setTimeout实现一个异步延迟执行</span>    <span class="hljs-keyword">const</span> sayHello = <span class="hljs-function">() =&gt;</span>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>),<span class="hljs-number">1000</span>);    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">handleClick</span> = <span class="hljs-string">&#123;sayHello&#125;</span> /&gt;</span></span>&#125;;<span class="hljs-keyword">const</span> Button = <span class="hljs-function">(<span class="hljs-params">&#123;handleClick&#125;</span>) =&gt;</span>(    &lt;button onClick=&#123;handleClick&#125;&gt;        Button    &lt;/button&gt;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;<span class="hljs-string">``</span><span class="hljs-string">` </span><span class="hljs-string"></span><span class="hljs-string">下面再看一个例子，通过使用setTimeout造成延迟执行的情况下，如何更新state。</span><span class="hljs-string"></span><span class="hljs-string">`</span><span class="hljs-string">``</span>js<span class="hljs-keyword">import</span> React, &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);    <span class="hljs-keyword">const</span> handleIncrement = <span class="hljs-function">() =&gt;</span>            <span class="hljs-built_in">setTimeout</span>(                <span class="hljs-comment">//这里很容易写成setCount(count+1),错！</span>                ()=&gt;setCount(<span class="hljs-function"><span class="hljs-params">count</span>=&gt;</span>count+<span class="hljs-number">1</span>),                <span class="hljs-number">1000</span>            );        <span class="hljs-keyword">const</span> handleDecrement = <span class="hljs-function">() =&gt;</span>            <span class="hljs-built_in">setTimeout</span>(                <span class="hljs-comment">//这里很容易写成setCount(count-1),错！</span>                ()=&gt;setCount(<span class="hljs-function"><span class="hljs-params">count</span>=&gt;</span>count-<span class="hljs-number">1</span>),                <span class="hljs-number">1000</span>            );    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;            &lt;Button handleClick=&#123;handleIncrement&#125;&gt;增加<span class="hljs-number">1</span>&lt;/Button&gt;            &lt;Button handleClick=&#123;handleDecrement&#125;&gt;减少<span class="hljs-number">1</span>&lt;/Button&gt;        &lt;/div&gt;    );    <span class="hljs-keyword">const</span> Button = <span class="hljs-function">(<span class="hljs-params">&#123;handleClick,children&#125;</span>) =&gt;</span>(        &lt;button onClick=&#123;handleClick&#125;&gt;&#123;children&#125;&lt;/button&gt;    );<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>注意观察上述代码是如何更新当前的count值的，我们通过使用setCount 状态函数来更新state。由于来源于useState的setter function 本质上是异步执行的，因此必须确保是对当前状态而不是任何过时状态执行更新。</p><p>了解更多，可参考<a href="https://www.robinwieruch.de/react-hooks-fetch-data"> how to fetch data with Function Components with React Hooks.</a></p><h4 id="十、函数组件中的生命周期实现——LifeCyrcle"><a href="#十、函数组件中的生命周期实现——LifeCyrcle" class="headerlink" title="十、函数组件中的生命周期实现——LifeCyrcle"></a>十、函数组件中的生命周期实现——LifeCyrcle</h4><p>如果你之前使用过类组件，一定用过componentDidMout、componentWillUnmount、shouldComponentUpdate等生命周期方法。但是在函数组件中没有这些方法，让我们看看如何在函数式组件中实现它们。</p><p>首先，在函数组件中没有constructor。在类组件中，constructor通常被用来设置initial state。但是在函数组件中我们使用useState hook就可以设置initial state，并且可以同时得到一个setter function 用于之后的业务逻辑。<br><img src="https://pic.downk.cc/item/5fd185883ffa7d37b3e1c35a.jpg"></p><p><strong>1.Funcitonal Component:  Mount</strong></p><p>react组件在第一次渲染的时候，会有一个mounting的阶段。如果你想在函数式组件里，当组件<strong>did mount</strong>的时候执行一些逻辑，可以使用<strong>useEffect</strong> hook:</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React ,&#123; useState, useEffect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);    <span class="hljs-keyword">const</span> handleIncrement = <span class="hljs-function">() =&gt;</span>        setCount(<span class="hljs-function"><span class="hljs-params">currentCount</span> =&gt;</span> currntCount+<span class="hljs-number">1</span>);        <span class="hljs-keyword">const</span> handleDecrement = <span class="hljs-function">() =&gt;</span>        setCount(<span class="hljs-function"><span class="hljs-params">currentCount</span> =&gt;</span> currntCount-<span class="hljs-number">1</span>);    useEffect(<span class="hljs-function">()=&gt;</span>setCount(<span class="hljs-function"><span class="hljs-params">currentCount</span> =&gt;</span> currentCount + <span class="hljs-number">1</span>),[]);    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;            &lt;button onClick=&#123;handleIncrement&#125;&gt;Increment&lt;/button&gt;            &lt;button onClick=&#123;handleDecrement&#125;&gt;Decrement&lt;/button&gt;        &lt;/div&gt;    )&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>当我们运行这段代码的时候，这个组件第一次渲染时会显示count的初始状态值0，然后当component did mount后，Effect hook 会将count设置为1。</p><p>🐖：Effect hook中的第二个参数（1个空数组）是非常重要的，它确保了只有在这个组件加载（mount)或者组件卸载（unmount)时才触发事件。如果不小心漏掉了这个空数组，我们会陷入count不断加1的死循环，因为当state更新了Effect hook总是会执行。然后Effect执行又会触发state更新，这样就会不停地对count+1<br><font color=green>todo: 这里为什么要用空数组而不是别的呢？？</font></p><p><strong>2.Funcitonal Component:  Update</strong></p><p>每次当入参props或者是组件本身的state变化时，react组件就会重新渲染以展示最新的status(from props and state)。在函数式组件中，一次render会执行函数体的所有内容。</p><p>如果函数组件没有正确地按照预期更新，我们可以在组件中使用console.log控制台输出state和props的值来debug。如果这两者的值都没有发生变化，就不会有新的render执行。<br><img src="https://pic.downk.cc/item/5fd1ca843ffa7d37b32b3cee.jpg"></p><p>如果我们想对组件重新渲染进行操作，我们可以再一次使用 Effect Hook (在组件did update之后)：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;useEffect, useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-comment">//count的初始值来源于本地存储中的值或0</span>    <span class="hljs-keyword">const</span> initialCount = +<span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&#x27;storageCount&#x27;</span>)||<span class="hljs-number">0</span>;    <span class="hljs-keyword">const</span> [count,setCount]=useState(initialCount);    <span class="hljs-keyword">const</span> handleIncrement = <span class="hljs-function">() =&gt;</span>        setCount(<span class="hljs-function"><span class="hljs-params">currentCount</span> =&gt;</span> currentCount + <span class="hljs-number">1</span>);     <span class="hljs-keyword">const</span> handleDecrement = <span class="hljs-function">() =&gt;</span>        setCount(<span class="hljs-function"><span class="hljs-params">currentCount</span> =&gt;</span> currentCount - <span class="hljs-number">1</span>);    <span class="hljs-comment">//每次组件重新渲染时，count都会被存入浏览器的本地存储</span>    useEffect(<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&#x27;storageCount&#x27;</span>,count));    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;            &lt;button onClick=&#123;handleIncrement&#125;&gt;+<span class="hljs-number">1</span>&lt;/button&gt;            &lt;button onClick=&#123;handleDecrement&#125;&gt;-<span class="hljs-number">1</span>&lt;/button&gt;        &lt;/div&gt;    )&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>你还可以通过给Effect Hook 传递第二个参数（是个数组）的方式，来控制它什么时候运行。每当第二个参数中的变量发生变化时，Effect Hook就会run。下面这个例子，只有当count发生变化的时候，才将其存入localStorage:<br><img src="https://pic.downk.cc/item/5fd1cdb33ffa7d37b32ef914.jpg"></p><p>现在我们可以总结，Effect Hook函数中第二个参数值的用法：（通过第二个参数值来控制它何时run)</p><ul><li>every time(no argument，不传第二个参数)</li><li>only on mount or unmount ([]argument, 空数组)</li><li>only when a certain variable changes(例如[count]，数组中放入指定变量)</li></ul><p>🐖：forceUpdate API可以强制让组件重新渲染，但是我们应该谨慎使用 ，参考<a href="https://zh-hans.reactjs.org/docs/react-component.html#forceupdate">forceUpdate</a>以及 <a href="https://reactjs.org/docs/hooks-faq.html#is-there-something-like-forceupdate">Is there something like forceUpdate</a></p><h4 id="十一、纯函数组件——Pure-React-Funtion-Component"><a href="#十一、纯函数组件——Pure-React-Funtion-Component" class="headerlink" title="十一、纯函数组件——Pure React Funtion Component"></a>十一、纯函数组件——Pure React Funtion Component</h4><p>类组件中，可以通过使用PureComponent 或者 shouldComponentUpdate 来避免重新渲染导致的性能瓶颈【<a href="https://www.robinwieruch.de/react-prevent-rerender-component">avoid performance bottlenecks in React by preventing rereders</a>】。让我们先看一个例子：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App =<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">const</span> [greeting,setGreeting]=useState(<span class="hljs-string">&#x27;hello react&#x27;</span>);    <span class="hljs-keyword">const</span>[count,setCount]=useState(<span class="hljs-number">0</span>);    <span class="hljs-keyword">const</span> handleIncrement = <span class="hljs-function">()=&gt;</span>        setCount(<span class="hljs-function"><span class="hljs-params">currentCount</span>=&gt;</span>currentCount+<span class="hljs-number">1</span>);    <span class="hljs-keyword">const</span> handleDecrement = <span class="hljs-function">()=&gt;</span>        setCount(<span class="hljs-function"><span class="hljs-params">currentCount</span>=&gt;</span>currentCount-<span class="hljs-number">1</span>);        <span class="hljs-keyword">const</span> handleChange = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> setGreeting(event.target.value);    <span class="hljs-keyword">return</span> (        &lt;div&gt;            &lt;input onChange=&#123;handleChange&#125; /&gt;            &lt;Count count=&#123;count&#125; /&gt;            &lt;button onClick=&#123;handleIncrement&#125;&gt;Increment&lt;/button&gt;            &lt;button onClick=&#123;handleDecrement&#125;&gt;Decrement&lt;/button&gt;        &lt;/div&gt;    )&#125;;<span class="hljs-keyword">const</span> Count=<span class="hljs-function">(<span class="hljs-params">&#123;count&#125;</span>)=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Does it (re)render?&#x27;</span>);    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>在这个例子中，每当我们向input输入框输入内容时，这个App组件就会更新它的stater然后重新渲染。与此同时，Count组件也会重新渲染（在控制台中我们可以看到，每次我们在输入框里操作，就会打印“Does it (re)render?”这句）。为了避免这种情况，react函数组件使用React Memo【<a href="https://reactjs.org/docs/react-api.html">React’s top level APIs</a>】来阻止当props没有变化时的重新渲染。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React,&#123;useState, memo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> APP=<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">const</span> [greeting,setGreeting] = useState(<span class="hljs-string">&#x27;hello react&#x27;</span>);    <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);    <span class="hljs-keyword">const</span> handleIncrement = <span class="hljs-function">() =&gt;</span>        setCount(<span class="hljs-function"><span class="hljs-params">currentCount</span> =&gt;</span> currentCount + <span class="hljs-number">1</span>);     <span class="hljs-keyword">const</span> handleDecrement = <span class="hljs-function">() =&gt;</span>        setCount(<span class="hljs-function"><span class="hljs-params">currentCount</span> =&gt;</span> currentCount - <span class="hljs-number">1</span>);   <span class="hljs-keyword">const</span> handleChange = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> setGreeting(event.target.value);   <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;input type=<span class="hljs-string">&quot;text&quot;</span> onChange=&#123;handleChange&#125; /&gt;       &lt;Count count=&#123;count&#125; /&gt;       &lt;button type=<span class="hljs-string">&quot;button&quot;</span> onClick=&#123;handleIncrement&#125;&gt;        Increment      &lt;/button&gt;      &lt;button type=<span class="hljs-string">&quot;button&quot;</span> onClick=&#123;handleDecrement&#125;&gt;        Decrement      &lt;/button&gt;    &lt;/div&gt;  );&#125;<span class="hljs-comment">//memo时把整个箭头函数的内容包裹起来</span><span class="hljs-keyword">const</span> Count = memo(<span class="hljs-function">(<span class="hljs-params">&#123;count&#125;</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;does it (re)render?&#x27;</span>);    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&#125;);<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>现在我们再来运行这个程序，当我们向input输入框输入内容时，只有App组件会rerender, Count组件不再rerender了！当然，这种性能优化不应该作为默认设置。当重新渲染组件时间过长遇到问题时可以进行类似的检查。（比如，rendering和updating Table组件中的大量内容）</p><h4 id="十二、React-Function-Component-Ref"><a href="#十二、React-Function-Component-Ref" class="headerlink" title="十二、React Function Component: Ref"></a>十二、React Function Component: Ref</h4><p>refs一般只在少数场景下使用：</p><ul><li>管理焦点，文本选择或者时媒体播放</li><li>触发强制动画</li><li>集成第三方DOM库</li></ul><p>在函数式组件中使用refs，要引入useRef。下面这个例子，input输入框将获得焦点（after component did mount)</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React,&#123;useState, useEffect, useRef&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> App=<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">const</span> [greeting, setGreeting] = useState(<span class="hljs-string">&#x27;hello React！&#x27;</span>);    <span class="hljs-keyword">const</span> handleChange = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span>setGreeting(event.target.value);    <span class="hljs-keyword">return</span>(        &lt;div&gt;            &lt;h1&gt;&#123;greeting&#125;&lt;/h1&gt;            &lt;Input value=&#123;greeting&#125; handleChange=&#123;handleChange&#125; /&gt;        &lt;/div&gt;    )&#125;;<span class="hljs-keyword">const</span> Input=<span class="hljs-function">(<span class="hljs-params">&#123;value,handleChange&#125;</span>)=&gt;</span>&#123;    <span class="hljs-keyword">const</span> ref=useRef();    useEffect(<span class="hljs-function">()=&gt;</span>ref.current.focus(),[]);    <span class="hljs-keyword">return</span> (        &lt;input             type=<span class="hljs-string">&#x27;text&#x27;</span>             value=&#123;value&#125;             onChange=&#123;handleChange&#125;             ref=&#123;ref&#125;        /&gt;    )&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>但是不能给一个函数组件提供一个ref作为props的一部分！The ref will be assigned to the component but not to the actual DOM node!<br><img src="https://pic.downk.cc/item/5fd1e2873ffa7d37b34ab442.jpg"></p><p>这样写会报错！因为ref指代的不是一个真实的dom节点，而是一个组件实例。</p><p><img src="https://pic.downk.cc/item/5fd1e2e03ffa7d37b34b4e87.jpg"></p><p>从上面的例子也可以看出，我们并不推荐父组件向子组件传递一个ref，这也就是为什么我们说”React function component can’t have  refs”。然而，如果我们不得不向一个函数组件传递一个ref(例如，我们想测量一个函数组件DOM节点的数量)，这种情况下我们可以<a href="https://reactjs.org/docs/forwarding-refs.html">forward the ref</a></p><p><img src="https://pic.downk.cc/item/5fd1e4643ffa7d37b3519759.jpg" alt="forwardRef"></p><p>想知道更多关于ref的问题，可以参考<a href="https://www.robinwieruch.de/react-ref-attribute-dom-node">How to use Ref in React</a> 以及 <a href="https://reactjs.org/docs/refs-and-the-dom.html">React 官方文档——Refs and the DOM</a></p><p>全文参考：<a href="https://www.robinwieruch.de/react-function-component">React Function Components</a></p>]]></content>
    
    
    <categories>
      
      <category>React学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS01-理解JavaScript函数调用和this</title>
    <link href="/2020/12/08/JS01-%E7%90%86%E8%A7%A3JavaScript%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8Cthis/"/>
    <url>/2020/12/08/JS01-%E7%90%86%E8%A7%A3JavaScript%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8Cthis/</url>
    
    <content type="html"><![CDATA[<h4 id="理解JavaScript函数调用与this的语义"><a href="#理解JavaScript函数调用与this的语义" class="headerlink" title="理解JavaScript函数调用与this的语义"></a>理解JavaScript函数调用与this的语义</h4><p>&emsp;我们经常对JS的函数调用，以及this在函数调用中的指代有很多的困惑。通过理解核心函数调用的原语可能会有助于消除很多此类的疑惑，也可以把其他函数调用方式看成是最原始函数调用的语法糖。The basic idea is the same.</p><h5 id="一、-The-Core-Primitive-核心原语："><a href="#一、-The-Core-Primitive-核心原语：" class="headerlink" title="一、 The Core Primitive 核心原语："></a>一、 The Core Primitive 核心原语：</h5><p>First, let’s look at the core function invocation primitive, a Function’s call method[1]. The call method is relatively straight forward.</p><ol><li>Make an argument list (<strong>argList</strong>) out of parameters 1 through the end</li><li>The first parameter is <strong>thisValue</strong></li><li>Invoke the function with <strong>this</strong> set to <strong>thisValue</strong> and the <strong>argList</strong> as its argument list<br>例子：<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params">thing</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;say hello&#x27;</span> + thing);&#125;hello.call(<span class="hljs-string">&#x27;Yehuda&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>);<span class="hljs-comment">//Yehuda says hello world</span></code></pre></li></ol><p>As you can see, we invoked the <strong>hello</strong> method with this set to “Yehuda” and a single argument “world”. This is the core primitive of JavaScript function invocation. You can think of all other function calls as desugaring to this primitive. (to “desugar” is to take a convenient syntax and describe it in terms of a more basic core primitive).</p><h5 id="二、简单函数调用"><a href="#二、简单函数调用" class="headerlink" title="二、简单函数调用"></a>二、简单函数调用</h5><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params">thing</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello&#x27;</span> + thing);&#125;<span class="hljs-comment">//简单函数调用</span>hello(<span class="hljs-string">&#x27;world&#x27;</span>);<span class="hljs-comment">//desugars to:</span>hello.call(<span class="hljs-built_in">window</span>, <span class="hljs-string">&#x27;world&#x27;</span>)<span class="hljs-comment">//在ES5的严格模式中，desugars to:</span>hello.call(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;world&#x27;</span>)</code></pre><p>在内联声明的函数中，也有相同的“解糖”：<br>(function() {})()  = (function() {}).call(window或undefined)</p><h5 id="三、成员函数"><a href="#三、成员函数" class="headerlink" title="三、成员函数"></a>三、成员函数</h5><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = &#123;    name: <span class="hljs-string">&#x27;Eich&#x27;</span>,    hello: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thing</span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;say hello&#x27;</span> + thing)    &#125;&#125;<span class="hljs-comment">//成员函数调用</span>person.hello(<span class="hljs-string">&#x27;world&#x27;</span>);<span class="hljs-comment">//desugars to:</span>person.hello.call(person,<span class="hljs-string">&#x27;world&#x27;</span>)</code></pre><p>如果为一个对象动态的添加成员函数，也有相同的“解糖”：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params">thing</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;say hello&#x27;</span> + thing);&#125;person = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Eich&#x27;</span>&#125;;person.hello = hello;person.hello(<span class="hljs-string">&#x27;world&#x27;</span>);<span class="hljs-comment">//still desugars to :</span><span class="hljs-comment">//person.hello.call(person,&#x27;world&#x27;)</span>hello(<span class="hljs-string">&#x27;world&#x27;</span>);<span class="hljs-comment">//&quot;[object DOMwindow] say hello world&quot;</span></code></pre><p>🐖：Notice that the function doesn’t have a persistent notion of its ‘this’. It is always set at call time based upon the way it was invoked by its caller.</p><h5 id="四、使用函数原型绑定-Function-prototype-bind"><a href="#四、使用函数原型绑定-Function-prototype-bind" class="headerlink" title="四、使用函数原型绑定 Function.prototype.bind"></a>四、使用函数原型绑定 Function.prototype.bind</h5><p>&emsp;因为有时使用持久化this值引用函数可能会很方便，所以人们一直以来都使用简单的闭包技巧将函数转换成不变的this值。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = &#123;    name: <span class="hljs-string">&#x27;Eich&#x27;</span>,    hello: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">this</span></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;says hello&#x27;</span> +thing);    &#125;&#125;<span class="hljs-keyword">var</span> boundHello = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thing</span>)</span>&#123;    <span class="hljs-comment">//使用原始的call方法把this转换为我们想要它指代的值</span>    <span class="hljs-keyword">return</span> person.hello.call(person,thing)&#125;boundHello(<span class="hljs-string">&#x27;world&#x27;</span>);<span class="hljs-comment">//desugars to: boundHello.call(window, &#x27;world&#x27;)</span></code></pre><p>我们还可以进一步改进，让上面的写法更加通用：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> bind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">func,thisValue</span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> func.apply(thisValue, <span class="hljs-built_in">arguments</span>);    &#125;&#125;<span class="hljs-keyword">var</span> boundHello = bind(person.hello, person);boundHello(<span class="hljs-string">&#x27;world&#x27;</span>)<span class="hljs-comment">//&#x27;Eich says hello world&#x27;</span></code></pre><p>上述代码中，arguments是类数组对象，代表所有被传入函数的参数值。apply() 方法跟call类似，除了它接收的是类数组对象作为参数，而call接收的是一个一个参数组成的列表 call(thisArg, arg1,arg2,…)。<br>对上述代码的解释：Our <strong>bind</strong> method simply returns a new function. When it is invoked, our new function simply invokes the original function that was passed in, setting the original value as <strong>this</strong>. It also passes through the arguments.</p><p>参考文章： <a href="https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/">Understanding JavaScript Function Invocation and “this”</a></p>]]></content>
    
    
    <categories>
      
      <category>JS学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试03-如何避免生命周期中的坑？</title>
    <link href="/2020/12/07/%E9%9D%A2%E8%AF%9503-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E7%9A%84%E5%9D%91%EF%BC%9F/"/>
    <url>/2020/12/07/%E9%9D%A2%E8%AF%9503-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E7%9A%84%E5%9D%91%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="面试场景3：如何避免生命周期中的坑？（经验题）"><a href="#面试场景3：如何避免生命周期中的坑？（经验题）" class="headerlink" title="面试场景3：如何避免生命周期中的坑？（经验题）"></a>面试场景3：如何避免生命周期中的坑？（经验题）</h4><p>如何避免坑？换种思维也就是”为什么会有坑?”,在代码编写中，遇到的坑通常有两种：</p><ul><li>1.在不恰当的时机调用了不合适的代码</li><li>2.在需要调用时，却忘了调用</li></ul><p>那么针对生命周期的坑，可以通过梳理生命周期，明确周期函数职责，确认什么时候该做什么事，依次来避免坑。因此现在主要思考两个问题：</p><ul><li>1.基于周期类型的梳理，确认生命周期函数的<strong>使用方式</strong></li><li>2.基于职责的梳理，确认生命周期函数的<strong>适用范围</strong></li></ul><p><img src="https://pic.downk.cc/item/5fcdeaf03ffa7d37b3c10890.jpg" alt="生命周期的梳理"></p><h5 id="一、生命周期的概念"><a href="#一、生命周期的概念" class="headerlink" title="一、生命周期的概念"></a>一、生命周期的概念</h5><p>当我们在讨论React组件生命周期的时候，一定是在讨论类组件（Class Component)。函数式组件并没有生命周期的概念，它本身就是一个函数，只会从头执行到尾。</p><p>生命周期其实是一个抽象的概念，提到生命周期我们第一时间想到的是componentDidMount, componenetWillMount等函数。然而这些函数并不等同于组件的生命周期，只是在生命周期中按顺序被调用的函数。<strong>挂载 -&gt; 更新 -&gt;卸载</strong>，这一完整的流程，才是React组件的生命周期。</p><h5 id="二、生命周期流程梳理"><a href="#二、生命周期流程梳理" class="headerlink" title="二、生命周期流程梳理"></a>二、生命周期流程梳理</h5><p><strong>1.挂载阶段</strong><br>&emsp;挂载阶段是指组件从初始化到完成加载的过程。</p><ul><li>✨<strong>constructor函数</strong>：constructor是类通用的构造函数，常用于初始化（通常是初始化state,以及绑定函数）<pre><code class="hljs js"><span class="hljs-comment">//过去的写法</span><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;        <span class="hljs-built_in">super</span>(props);        <span class="hljs-built_in">this</span>.state=&#123;            count:<span class="hljs-number">0</span>        &#125;        <span class="hljs-built_in">this</span>.handleClick=<span class="hljs-built_in">this</span>.handleClick.bind(<span class="hljs-built_in">this</span>);    &#125;    <span class="hljs-function"><span class="hljs-title">handleClick</span>(<span class="hljs-params"></span>)</span>&#123;        ...    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;&#125;<span class="hljs-string">``</span><span class="hljs-string">` </span><span class="hljs-string">当类属性开始流行后，现在React社区的写法发生了变化，去除了constructor。</span><span class="hljs-string"></span><span class="hljs-string">`</span><span class="hljs-string">``</span>js<span class="hljs-comment">//现在的写法</span><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    state=&#123;        count:<span class="hljs-number">0</span>,    &#125;    <span class="hljs-comment">//类属性第三阶段提案，这种不再需要额外绑定</span>    handleClick=<span class="hljs-function">()=&gt;</span>&#123;        ...    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;&#125;</code></pre>React社区去除constructor的原因：</li></ul><ol><li>constructor本身并不属于React的生命周期，它只是Class组件的初始化函数</li><li>constructor中并不推荐去处理初始化以外的逻辑</li><li>通过去除constructor，代码变得更加简洁</li></ol><ul><li>✨<strong>getDerivedStateFromProps函数</strong>： 使组件在props变化时更新state</li></ul><p>它的触发时机是：</p><ol><li>当props被传入时</li><li>state发送变化时</li><li>forceUpdate被调用时</li></ol><p>🐖：一个常见错误是认为只有props发送变化时，getDerivedStateFromProps才会被调用，实际上只要父组件重新渲染时，getDerivedStateFromProps就会被调用，外部参数props传入时就会发生变化。以下是官方文档给出的例子：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-comment">// 在构造函数中初始化 state，</span>  <span class="hljs-comment">// 或者使用属性初始化器。</span>  state = &#123;    isScrollingDown: <span class="hljs-literal">false</span>,    lastRow: <span class="hljs-literal">null</span>,  &#125;;  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getDerivedStateFromProps</span>(<span class="hljs-params">props, state</span>)</span> &#123;    <span class="hljs-keyword">if</span> (props.currentRow !== state.lastRow) &#123;      <span class="hljs-keyword">return</span> &#123;        isScrollingDown: props.currentRow &gt; state.lastRow,        lastRow: props.currentRow,      &#125;;    &#125;    <span class="hljs-comment">// 返回 null 表示无需更新 state。</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  &#125;&#125;</code></pre><p>按照官方的说话，它的使用场景是非常有限的。由于太多使用错误的案例，React团队还因此写了<a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html">你可能不需要使用派生state</a>，文中列举了错误使用getDerivedStateFromProps的两个典型反面案例：</p><ol><li>直接复制prop到state</li><li>在props变化后修改state</li></ol><p>这两种写法除了增加代码的维护成本外，没有带来任何好处。</p><ul><li>✨<strong>UNSAFE_componentWillMount函数</strong>： 也就是componentWillMount，用于组件加载前做某些操作。在React的异步渲染机制下，该方法可能会被多次调用，所以目前被标记为弃用。</li></ul><p>一个常见的错误是componentWillMount跟服务器端同构渲染时，如果在该函数里面发起网络请求，拉取数据，那么会在服务器端和客户端分别执行一次。所以更推荐使用componentDidMount中完成拉取数据的操作。</p><ul><li><p>✨<strong>render函数</strong>： render函数返回的JSX结构，用于描述具体的渲染内容。但是，render函数并没有真正的去渲染组件，渲染是依靠React操作JSX结构完成的。<br>🐖：render函数应该是一个纯函数，不能在里面产生副作用，比如调用setState或者绑定事件。① 不能setState是因为render函数在每次渲染时都会被调用，而setState会触发渲染，就会造成死循环。② 不能绑定事件是因为容易被频繁调用注册。</p></li><li><p>✨<strong>componentDidMount函数</strong>： 主要用于组件加载完成后进行某些操作，比如发起网络请求或者绑定事件，该函数是接着render之后调用的。但是componentDidMount一定是在真实DOM绘制完成之后调用吗？在浏览器端可以这么认为。但是在其他场景下，尤其是React Native场景下，componentDidMount并不意味着真实的界面已经绘制完毕。（由于机器的性能限制，视图可能还在绘制中）</p></li></ul><p><strong>2.更新阶段</strong><br>&emsp;更新阶段是指外部props传入，或者state发生变化时的阶段。这个阶段主要有以下6个函数：</p><ul><li>💖<strong>UNSAFE_componentWillReceiveProps函数</strong>： 该函数已经被标记弃用，因为其功能可被getDerivedStateFromProps所替代。当getDerivedStateFromProps存在时，UNSAFE_componentWillReceiveProps不会被调用。</li><li>💖<strong>getDerivedStateFromProps函数</strong>: 同挂载阶段的变现一致。</li><li>💖<strong>shouldComponentUpdate函数</strong>: 该方法通过返回true或者false来确定是否需要触发新的渲染，因为渲染触发最后一道关卡，所以也是性能优化的必争之地。通过添加判断条件来阻止不必要的渲染。</li></ul><p>React官方提供了一个通用的优化方案，也就是PureComponent。PureComponent的核心原理是默认实现了shouldComponentUpdate函数，在这个函数中对props和state进行浅比较，用来判断是否触发更新。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">shouldComponentUpdate</span>(<span class="hljs-params">nextProps, nextState</span>)</span> &#123;  <span class="hljs-comment">// 浅比较仅比较值与引用，并不会对 Object 中的每一项值进行比较</span>  <span class="hljs-keyword">if</span> (shadowEqual(nextProps, <span class="hljs-built_in">this</span>.props) || shadowEqual(nextState, <span class="hljs-built_in">this</span>.state) ) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre><ul><li><p>💖<strong>UNSAFE_componentWillUpdate函数</strong>: 同样已废弃，因为在后续的React异步渲染设计中，可能会出现组件暂停更新渲染的情况。</p></li><li><p>💖<strong>render函数</strong>: 跟挂载阶段的表现一致</p></li><li><p>💖<strong>getSnapshotBeforeUpdate函数</strong>: getSnapshotBeforeUpdate是配合React新的异步渲染机制，在DOM更新发生之前被调用，返回值作为对componentDidUpdate的第三个参数。官方示例如下：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScrollingList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props);    <span class="hljs-built_in">this</span>.listRef = React.createRef();  &#125;  <span class="hljs-function"><span class="hljs-title">getSnapshotBeforeUpdate</span>(<span class="hljs-params">prevProps, prevState</span>)</span> &#123;    <span class="hljs-comment">// Are we adding new items to the list?</span>    <span class="hljs-comment">// Capture the scroll position so we can adjust scroll later.</span>    <span class="hljs-keyword">if</span> (prevProps.list.length &lt; <span class="hljs-built_in">this</span>.props.list.length) &#123;      <span class="hljs-keyword">const</span> list = <span class="hljs-built_in">this</span>.listRef.current;      <span class="hljs-keyword">return</span> list.scrollHeight - list.scrollTop;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  &#125;  <span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState, snapshot</span>)</span> &#123;    <span class="hljs-comment">// If we have a snapshot value, we&#x27;ve just added new items.</span>    <span class="hljs-comment">// Adjust scroll so these new items don&#x27;t push the old ones out of view.</span>    <span class="hljs-comment">// (snapshot here is the value returned from getSnapshotBeforeUpdate)</span>    <span class="hljs-keyword">if</span> (snapshot !== <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">const</span> list = <span class="hljs-built_in">this</span>.listRef.current;      list.scrollTop = list.scrollHeight - snapshot;    &#125;  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> (      &lt;div ref=&#123;<span class="hljs-built_in">this</span>.listRef&#125;&gt;&#123;<span class="hljs-comment">/* ...contents... */</span>&#125;&lt;/div&gt;    );  &#125;</code></pre></li><li><p>💖<strong>componentDidUpdate函数</strong>: 正如上面的案例，getSnapshotBeforeUpdate的返回值会作为componentDidUpdate的第三个参数使用。componentDidUpdate函数中可以使用setState来触发重新渲染，但是一定要小心，避免死循环！</p></li></ul><p><strong>3.挂载阶段</strong><br>&emsp;挂载阶段，只有一个回调函数。</p><ul><li>✌<strong>componentWillUnmount函数</strong>：该函数主要用于清理工作，一个比较常见的bug是忘记在componentWillUnmount中取消定时器，导致定时操作依然在组件销毁后不停地执行。所以在该阶段一定要完成事件解绑，取消定时器。</li></ul><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p> 根据上面的内容，可以做一个思维导图：<br> <img src="https://pic.downk.cc/item/5fce2a393ffa7d37b3f47cbd.jpg" alt="React生命周期思维导图"></p><h5 id="二、生命周期职责梳理"><a href="#二、生命周期职责梳理" class="headerlink" title="二、生命周期职责梳理"></a>二、生命周期职责梳理</h5><p> 职责梳理主要是搞清楚两个事情：<br> 1、什么情况下会触发重新渲染？<br> 2、渲染中发生报错后会怎样？</p><p> <strong>1.触发重新渲染的三种情况</strong>：</p><ul><li><p>😊<strong>函数组件</strong>： 函数组件在任何情况下都有可能重新渲染。它没有生命周期，但是官方提供了一个优化手段，那就是React.memo:</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> MyComponent = React.memo(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params">props</span>)</span>&#123;    <span class="hljs-comment">/*使用props渲染*/</span>&#125;)</code></pre><p>React.memo并不阻断渲染，而是跳过渲染组件的操作并直接复用最新一次渲染的结果，这与shouldComponentUpdate是完全不同的。</p></li><li><p>😊<strong>React.Component</strong>：如果不实现shouldComponentUpdate函数，那么有两种情况触发渲染：<br>1、当state发生变化时。（最常见的情况）<br>2、当父组件的Props传入时。（无论Props有没有发生变化，只有传入就会引发重新渲染）</p></li><li><p>😊<strong>React.PureComponent</strong>: PureComponent默认实现了shouldComponentUpdate函数，所以仅在props与state进行浅比较后，确认有变更时才会触发重新渲染。</p></li><li><p>*2.错误边界**： </p></li></ul><p>&emsp;错误边界是一种React组件，这种组件可以捕获并打印发生在其子组件树上任何位置的JavaScript错误，并且，它会渲染出备用UI，如下官方示例：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props);    <span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> &#125;;  &#125;  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getDerivedStateFromError</span>(<span class="hljs-params">error</span>)</span> &#123;    <span class="hljs-comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> &#125;;  &#125;  <span class="hljs-function"><span class="hljs-title">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>)</span> &#123;    <span class="hljs-comment">// 你同样可以将错误日志上报给服务器</span>    logErrorToMyService(error, errorInfo);  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state.hasError) &#123;      <span class="hljs-comment">// 你可以自定义降级后的 UI 并渲染</span>      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Something went wrong.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.props.children;   &#125;&#125;</code></pre><p>无论是React,还是React Native,如果没有错误边界，在用户侧看到的现象是：在执行某个错误操作时，触发了bug, 引发了崩溃，页面会突然白屏。</p><p>🐖：在渲染时的报错，只能通过componentDidCatch捕获。这是在做线上页面报错监控时，及其容易忽略的点。</p><h5 id="三、答题："><a href="#三、答题：" class="headerlink" title="三、答题："></a>三、答题：</h5><p>经过上面的梳理,现在可以回答开头的问题了。</p><blockquote><p>避免生命周期中的坑需要做好两件事：</p><p>1.不在恰当的时候调用了不该调用的代码；<br>2.在需要调用时，不要忘了调用。</p></blockquote><p>那么，有7种情况容易造成React生命周期的坑：</p><blockquote><p>1.getDerivedStateFromProps 容易编写反模式代码，使受控组件与非受控组件区分模糊。</p></blockquote><blockquote><p>2.componentWillMount 在 React 中已被标记弃用，不推荐使用，主要原因是新的异步渲染架构会导致它被多次调用。所以网络请求及事件绑定代码应移至 componentDidMount中。</p></blockquote><blockquote><p>3.componentWillReceiveProps 同样被标记弃用，被 getDerivedStateFromProps 所取代，主要原因是性能问题。</p></blockquote><blockquote><p>4.shouldComponentUpdate 通过返回 true 或者 false 来确定是否需要触发新的渲染。主要用于性能优化。</p></blockquote><blockquote><p>5.componentWillUpdate 同样是由于新的异步渲染机制，而被标记废弃，不推荐使用，原先的逻辑可结合 getSnapshotBeforeUpdate 与 componentDidUpdate 改造使用。</p></blockquote><blockquote><p>6.如果在 componentWillUnmount 函数中忘记解除事件绑定，取消定时器等清理操作，容易引发 bug。</p></blockquote><blockquote><p>7.如果没有添加错误边界处理，当渲染发生异常时，用户将会看到一个无法操作的白屏，所以一定要添加。</p></blockquote><h5 id="四、进阶提问：React-的请求应该放在哪里，为什么"><a href="#四、进阶提问：React-的请求应该放在哪里，为什么" class="headerlink" title="四、进阶提问：React 的请求应该放在哪里，为什么?"></a>四、进阶提问：React 的请求应该放在哪里，为什么?</h5><p> 对于异步请求，应该放在componentDidUpdate中操作。从时间顺序上看，似乎还有两个选择，但是它们都有各自的弊端：</p><ul><li><p>constructor：可以放，但是从设计上看不推荐，constructor主要用于初始化state和函数绑定，并不应该承载业务逻辑。而且随着类属性的流行，constructor已经很少使用了。</p></li><li><p>componentWillMout: 已经被标废弃，在新的异步渲染机制下回触发多次渲染，容易引发bug,不利于React升级后的代码维护。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>npm01--dependencies与devDependencies的区别</title>
    <link href="/2020/12/06/npm01-dependencies%E4%B8%8EdevDependencies%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/12/06/npm01-dependencies%E4%B8%8EdevDependencies%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="dependencies-与-devDependencies"><a href="#dependencies-与-devDependencies" class="headerlink" title="dependencies 与 devDependencies"></a>dependencies 与 devDependencies</h4><p>&emsp;当我们在使用npm install 安装node模块时，有两种命令参数将这些node模块的信息写入到package.json文件中：</p><ul><li>npm install *** –save，这个命令是将依赖包的信息添加到package.json文件的dependencies键下。</li><li>npm install *** –save-dev，这个命令是将依赖包的信息添加到devDependencies键下。</li></ul><h4 id="1-不同点："><a href="#1-不同点：" class="headerlink" title="1.不同点："></a>1.不同点：</h4><p><strong>devDependencies是开发环境</strong>，我们使用的一些构建工具如webpack、glup等只是在开发过程中用的包，上线后就和它们没有关系了，所以这种都写入devDependencies（还有一些单元测试工具也卸载这里）</p><p><strong>dependencies是生产环境</strong>，比如我们写一个项目需要依赖React/Vue/jQuery才能执行，没有这个包的依赖运行就会出错，这时候就必须把依赖写入dependencies里。</p><h4 id="2-相同点："><a href="#2-相同点：" class="headerlink" title="2.相同点："></a>2.相同点：</h4><p>dependencies和 devDependencies相同的地方在于：就是当我们clone别人的库进行开发测试的时候，可以通过npm install 一键安装这两个目录下的所有依赖，而不需要一行行地查找别人到底在文件中引用了哪些依赖。</p><p>参考：<a href="https://docs.npmjs.com/cli/v6/configuring-npm/package-json#dependencies">npm官方文档–dependencies</a></p>]]></content>
    
    
    <categories>
      
      <category>npm学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试02-为什么React要用JSX？</title>
    <link href="/2020/12/02/%E9%9D%A2%E8%AF%9502-%E4%B8%BA%E4%BB%80%E4%B9%88React%E8%A6%81%E7%94%A8JSX%EF%BC%9F/"/>
    <url>/2020/12/02/%E9%9D%A2%E8%AF%9502-%E4%B8%BA%E4%BB%80%E4%B9%88React%E8%A6%81%E7%94%A8JSX%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="面试场景2：为什么React要用JSX？（论证题）"><a href="#面试场景2：为什么React要用JSX？（论证题）" class="headerlink" title="面试场景2：为什么React要用JSX？（论证题）"></a>面试场景2：为什么React要用JSX？（论证题）</h4><p>&emsp;针对”为什么采用改技术方案？”类型的题，其实主要在考察两个方面：</p><ul><li>技术广度，深挖知识面涉猎广度，对流行框架的模板方案是否知悉了解。</li><li>技术方案调研能力</li></ul><p>所以，针对这类问题，可以采用 “一句话解释，核心概念，方案对比” 三步走的技巧来作答：</p><p>1、一句话解析JSX。用一句话说清楚JSX到底是什么。<br>2、核心概念。JSX用于解决什么问题？如何使用？<br>3、方案对比。与其他方案进行对比，说明React选用JSX的必要性。</p><h5 id="一、一句话解释"><a href="#一、一句话解释" class="headerlink" title="一、一句话解释"></a>一、一句话解释</h5><p>&emsp;按照React官方解释，<strong>JSX是一个JavaScript的语法扩展，或者说是一个类似于XML的ECMAScript语法扩展</strong>，它本身没有太多的语法定义，也不期望引入更多的标准。</p><h5 id="二、核心概念"><a href="#二、核心概念" class="headerlink" title="二、核心概念"></a>二、核心概念</h5><p>&emsp;其实React本身并不强制使用JSX，在没有JSX的时候，React实现一个组件依赖于使用React.createElement函数。代码如下：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> React.createElment(            <span class="hljs-string">&#x27;div&#x27;</span>,            <span class="hljs-literal">null</span>,            <span class="hljs-string">`Hello <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.props.toWhat&#125;</span>`</span>        );    &#125;&#125;ReactDOM.render(    React.createElement(<span class="hljs-string">&#x27;Hello,&#123;toWhat:&#x27;</span>World<span class="hljs-string">&#x27;&#125;),</span><span class="hljs-string">    document.getElementById(&#x27;</span>root<span class="hljs-string">&#x27;)</span><span class="hljs-string">)</span></code></pre><p>而JSX更像是语法糖，通过类似XML的描述方式，描写函数对象。采用JSX之后，上述代码会变成如下：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello,&#123;this.props.toWhat&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    &#125;&#125;ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Hello</span> <span class="hljs-attr">toWhat</span>=<span class="hljs-string">&#x27;world&#x27;</span>/&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>))</code></pre><p>通过这样对比，显然可以看出，<strong>JSX使得代码变得更为简洁，而且代码结构层次更为清晰。</strong></p><p>因为React需要将组件转化为虚拟DOM树，所以我们手写代码时，其实是在手写一颗结构树。而XML在树结构的描述上天然具有可读性强优势。<br>🐖：实际在运行的时候，会使用Babel插件将JSX语法的代码还原为React.createElement的代码。</p><h5 id="三、方案对比"><a href="#三、方案对比" class="headerlink" title="三、方案对比"></a>三、方案对比</h5><p><strong>1.React设计初衷</strong></p><p>React的设计初衷是：关注点分离（Separation of concerns)。在React种，关注点的基本单位是组件。React单个组件时高内聚的，而组件与组件之间时低耦合的。</p><blockquote><p>关注点分离：是计算机科学里面的一个重要概念。主要思想是将代码分隔为不同部分，每一部分都有各自的关注点。优点： 当关注点分开时，各部分可以重复使用，独立开发和更新。具有特殊价值的部分能够稍后改进或修改一段代码，而无须知道其他部分的细节做出的相应更改。</p></blockquote><p><strong>2.React为什么不使用模板呢？</strong></p><p>React团队认为引入模板是一种不佳的实现。因为模板分离了技术栈，而非关注点的模板同时又引入了很多的概念，比如新的模板语法、模板指令等。以AngularJS为例，可以看下有多少新概念：</p><pre><code class="hljs js">&lt;!doctype html&gt;&lt;html ng-app=<span class="hljs-string">&quot;docsBindExample&quot;</span>&gt;  &lt;head&gt;    &lt;script src=<span class="hljs-string">&quot;http://code.angularjs.org/1.2.25/angular.min.js&quot;</span>&gt;&lt;/script&gt;    &lt;script src=<span class="hljs-string">&quot;script.js&quot;</span>&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div ng-controller=<span class="hljs-string">&quot;Ctrl1&quot;</span>&gt;      Hello &lt;input ng-model=<span class="hljs-string">&#x27;name&#x27;</span>&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span></span>      &lt;span ng-bind=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;<span class="hljs-regexp">/span&gt; &lt;br/</span>&gt;      &lt;span ng:bind=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;<span class="hljs-regexp">/span&gt; &lt;br/</span>&gt;      &lt;span ng_bind=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;<span class="hljs-regexp">/span&gt; &lt;br/</span>&gt;      &lt;span data-ng-bind=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;<span class="hljs-regexp">/span&gt; &lt;br/</span>&gt;      &lt;span x-ng-bind=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;<span class="hljs-regexp">/span&gt; &lt;br/</span>&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;angular.module(<span class="hljs-string">&#x27;docsBindExample&#x27;</span>, [])  .controller(<span class="hljs-string">&#x27;Ctrl1&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Ctrl1</span>(<span class="hljs-params">$scope</span>) </span>&#123;    $scope.name = <span class="hljs-string">&#x27;Max Karl Ernst Ludwig Planck (April 23, 1858 – October 4, 1947)&#x27;</span>;  &#125;);</code></pre><p>看完会发现这段代码很难懂，因为它引入了非常多的AngularJS独有的概念，但是JSX却不会有很多新概念，它依然是JavaScript，就连条件表达式和循环都仍然是JavaScript的方式。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> App=<span class="hljs-function">(<span class="hljs-params">props</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span>(        &lt;div&gt;            &#123;props.isShow?<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>show<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>:<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>hidden<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>&#125;            &#123;props.names.map(<span class="hljs-function"><span class="hljs-params">name</span>=&gt;</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>)&#125;        &lt;/div&gt;    )&#125;</code></pre><p>这样比较下来，可以看出React代码更简洁，更具有可读性，更贴近HTML。</p><p>那模板字符串也可以套用HTML，为什么不用模板字符串呢？</p><p><strong>3.React为什么不使用模板字符串呢？</strong></p><p>来看一个模板字符串的例子：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> box = jsx<span class="hljs-string">`</span><span class="hljs-string"></span><span class="hljs-string">  &lt;<span class="hljs-subst">$&#123;Box&#125;</span>&gt;</span><span class="hljs-string"></span><span class="hljs-string">    <span class="hljs-subst">$&#123;</span></span><span class="hljs-string"><span class="hljs-subst"></span></span><span class="hljs-string"><span class="hljs-subst">      shouldShowAnswer(user) ?</span></span><span class="hljs-string"><span class="hljs-subst"></span></span><span class="hljs-string"><span class="hljs-subst">      jsx<span class="hljs-string">`&lt;<span class="hljs-subst">$&#123;Answer&#125;</span> value=<span class="hljs-subst">$&#123;<span class="hljs-literal">false</span>&#125;</span>&gt;no&lt;/<span class="hljs-subst">$&#123;Answer&#125;</span>&gt;`</span> :</span></span><span class="hljs-string"><span class="hljs-subst"></span></span><span class="hljs-string"><span class="hljs-subst">      jsx<span class="hljs-string">`</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">        &lt;<span class="hljs-subst">$&#123;Box.Comment&#125;</span>&gt;</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">         Text Content</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">        &lt;/<span class="hljs-subst">$&#123;Box.Comment&#125;</span>&gt;</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">      `</span></span></span><span class="hljs-string"><span class="hljs-subst"></span></span><span class="hljs-string"><span class="hljs-subst">    &#125;</span></span><span class="hljs-string"></span><span class="hljs-string">  &lt;/<span class="hljs-subst">$&#123;Box&#125;</span>&gt;</span><span class="hljs-string"></span><span class="hljs-string">`</span>;</code></pre><p>显然代码结构还是非常复杂（存在多次内部嵌套），也不利于开发工具的代码提示。</p><p><strong>4.React为什么不使用JXON呢？</strong></p><p>JXON很像目前使用的JSX，它的结构如下：</p><pre><code class="hljs js">&lt;catalog&gt;  &lt;product description=<span class="hljs-string">&quot;Cardigan Sweater&quot;</span>&gt;   &lt;catalog_item gender=<span class="hljs-string">&quot;Men&#x27;s&quot;</span>&gt;     &lt;item_number&gt;QWZ5671&lt;/item_number&gt;     &lt;price&gt;<span class="hljs-number">39.95</span>&lt;/price&gt;     &lt;size description=<span class="hljs-string">&quot;Medium&quot;</span>&gt;       &lt;color_swatch image=<span class="hljs-string">&quot;red_cardigan.jpg&quot;</span>&gt;Red&lt;/color_swatch&gt;       &lt;color_swatch image=<span class="hljs-string">&quot;burgundy_cardigan.jpg&quot;</span>&gt;Burgundy&lt;/color_swatch&gt;     &lt;/size&gt;     &lt;size description=<span class="hljs-string">&quot;Large&quot;</span>&gt;       &lt;color_swatch image=<span class="hljs-string">&quot;red_cardigan.jpg&quot;</span>&gt;Red&lt;/color_swatch&gt;       &lt;color_swatch image=<span class="hljs-string">&quot;burgundy_cardigan.jpg&quot;</span>&gt;Burgundy&lt;/color_swatch&gt;     &lt;/size&gt;   &lt;/catalog_item&gt;   &lt;catalog_item gender=<span class="hljs-string">&quot;Women&#x27;s&quot;</span>&gt;     &lt;item_number&gt;RRX9856&lt;/item_number&gt;     &lt;discount_until&gt;Dec <span class="hljs-number">25</span>, <span class="hljs-number">1995</span>&lt;/discount_until&gt;     &lt;price&gt;<span class="hljs-number">42.50</span>&lt;/price&gt;     &lt;size description=<span class="hljs-string">&quot;Medium&quot;</span>&gt;       &lt;color_swatch image=<span class="hljs-string">&quot;black_cardigan.jpg&quot;</span>&gt;Black&lt;/color_swatch&gt;     &lt;/size&gt;   &lt;/catalog_item&gt;  &lt;/product&gt;  &lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;&lt;![CDATA[<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchwo</span>(<span class="hljs-params">a,b</span>) </span>&#123;    <span class="hljs-keyword">if</span> (a &lt; b &amp;&amp; a &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;    <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;&#125;]]&gt;&lt;/script&gt;&lt;/catalog&gt;</code></pre><p>最后放弃JXON这一方案的原因是，大括号不能作为元素在树种开始和结束的位置，无法提供很好的语法提示。</p><p>最后总结下，React为什么使用JSX?</p><p><img src="https://pic.downk.cc/item/5fc752d5394ac523789ece3c.jpg" alt="react使用JSX原因"></p><p>==答题==： </p><blockquote><p>首先，JSX 是一个 JavaScript 的语法扩展，结构类似 XML。<br>（JSX 主要用于声明 React 元素，但 React 中并不强制使用 JSX。即使使用了 JSX，也会在构建过程中，通过 Babel 插件编译为 React.createElement。所以 JSX 更像是 React.createElement 的一种语法糖。<br>React团队并不想引入JavaScript本身以外的开发体系，而是希望通过合理的关注点分离保持组件开发的纯粹性。）</p></blockquote><blockquote><p>然后，是JSX与其他三种技术方案的对比：<br>1.模板。 React 团队认为模板不应该是开发过程中的关注点，因为引入了模板语法、模板指令等概念，是一种不佳的实现方案。<br>2.模板字符串。 模板字符串编写的结构会造成多次内部嵌套，使整个结构变得复杂，并且优化代码提示也会变得困难重重。<br>3.JXON。 同样因为代码提示困难的原因而被放弃</p></blockquote><p>✨所以，React选择了JSX，因为JSX与其设计思想最为吻合，不需要引入过多的新概念，对编辑器代码提示也很友好。</p>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>React03-React.cloneElement函数</title>
    <link href="/2020/12/01/React03-React-cloneElement%E5%87%BD%E6%95%B0/"/>
    <url>/2020/12/01/React03-React-cloneElement%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="React-cloneElement-element-props-…children"><a href="#React-cloneElement-element-props-…children" class="headerlink" title="React.cloneElement(element,[props],[…children])"></a>React.cloneElement(element,[props],[…children])</h4><p>&emsp;这个API以element元素为样板克隆并返回新的React元素。</p><ul><li>返回元素的props是将新的props与原始元素的props浅层合并后的结果。</li><li>新的子元素将取代现有的子元素，而来自原始元素的key和ref将被保留。</li></ul><p>React.cloneElement() 基本等同于：</p><pre><code class="hljs js">&lt;element.type &#123;...element.props&#125;&#123;...props&#125;&gt;&#123;children&#125;&lt;/element.type&gt;</code></pre><p>参考：<a href="https://zh-hans.reactjs.org/docs/react-api.html#cloneelement">React.cloneElement官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>React学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试01-你真的了解React吗？</title>
    <link href="/2020/11/30/%E9%9D%A2%E8%AF%9501-%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3React%E5%90%97%EF%BC%9F/"/>
    <url>/2020/11/30/%E9%9D%A2%E8%AF%9501-%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3React%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="面试场景1：谈谈你对React的理解？（概念题）"><a href="#面试场景1：谈谈你对React的理解？（概念题）" class="headerlink" title="面试场景1：谈谈你对React的理解？（概念题）"></a>面试场景1：谈谈你对React的理解？（概念题）</h4><p>针对这种概念题，一般采用四字口诀：“讲说理列”</p><ul><li>讲概念: 一句话讲清楚该技术是什么。  </li><li>说用途：描述该技术的用途（结合具体场景，拓展性的描述)</li><li>理思路：梳理该技术的核心思路或运作流程。</li><li>列优缺：对该技术的优点缺点进行列举（与其他技术方案进行横向对比，但切忌踩一捧一！）</li></ul><h5 id="1、讲React概念"><a href="#1、讲React概念" class="headerlink" title="1、讲React概念"></a>1、讲React概念</h5><p><strong>React是通过组件化的方式解决视图层开发复用的问题，本质是一个组件化框架。</strong></p><p>简单概括为： View = fn(props)， 给定相同的输入状态，函数总会生成一致的组件。如果变量多一些，也可以扩展为 View = fn(props,state,context)</p><h5 id="2、说React用途"><a href="#2、说React用途" class="headerlink" title="2、说React用途"></a>2、说React用途</h5><p><strong>React的用途就是：构建视图。</strong> React的生态丰富了它的使用场景：</p><ul><li>首先，PC网页和移动端网页，React都支持</li><li>其次，React Native 可用于开发ios与Android应用</li><li>React 360可以开发VR应用</li><li>冷门的ink,可以使用React开发命令行应用。</li></ul><h5 id="3、理React思路"><a href="#3、理React思路" class="headerlink" title="3、理React思路"></a>3、理React思路</h5><p><strong>React的核心思路：声明式、组件化、通用性</strong>（官方称，一次学习，随处编写）</p><ul><li><strong>声明式</strong>：优势在于直观，可以做到一目了然，也便于组合。</li></ul><p>命令式编程：</p><pre><code class="hljs js"><span class="hljs-comment">//HTML</span>&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&#x27;block&#x27;</span>&gt;&lt;/div&gt;<span class="hljs-comment">//JS</span><span class="hljs-keyword">const</span> block=$(<span class="hljs-string">&#x27;.block&#x27;</span>)block.css(<span class="hljs-string">&#x27;color&#x27;</span>,<span class="hljs-string">&#x27;red&#x27;</span>)</code></pre><p>声明式编程：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> Block=<span class="hljs-function">(<span class="hljs-params">props</span>)=&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;color:</span>&#x27;<span class="hljs-attr">red</span>&#x27;&#125;&#125;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre><p>可以发现，声明式编程更容易阅读，而且更容易与其他组件代码组合。</p><ul><li><p><strong>组件化</strong>：组件化优势在于可以降低系统间功能的耦合性，提高功能内部的聚合性。这样便于代码复用。</p></li><li><p><strong>通用性</strong>：React将DOM抽象为虚拟DOM，开发者并不是直接操作DOM。正因为这一层封装的存在，使得React不再局限于web开发，而是出现更繁荣的生态。不论VR，Native,还是shell命令，只有兼容虚拟DOM层，都可以直接运行React。</p></li></ul><h5 id="4、列React优缺"><a href="#4、列React优缺" class="headerlink" title="4、列React优缺"></a>4、列React优缺</h5><ul><li><p>优点：其实就是React的核心设计思路：声明式，组件化，通用性。</p></li><li><p>缺点：React不是一个一揽子框架，比如路由一类的功能，React团队希望交给社区解决。导致技术选型和学习使用上有较高的成本，在开发大型前端应用时需要向社区寻找并整合解决方案。（非官方的一揽子解决方案是有的，比如DvaJS、React-coat等）</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>React02-setState的使用</title>
    <link href="/2020/11/27/React02-setState%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/27/React02-setState%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="setState-updater-callback"><a href="#setState-updater-callback" class="headerlink" title="setState(updater, [callback])"></a>setState(updater, [callback])</h3><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>1、setState()将对组件state的更新排入队列，并通知React需要使用更新后的state重新渲染此组件及其子组件。这是用于更新用户界面以响应事件处理器和处理服务器数据的主要方式。</p><p>2、<strong>将setState()视为请求而不是立即更新组件的命令</strong>。为了更好的感知性能，React会延迟调用它，然后通过一次传递更新多个组件。React并不会保证state的变更会立即生效。</p><p>3、<strong>setState()并不总是立即更新组件，它会批量推迟更新</strong>。这使得在调用setState()后立即读取this.state成为了隐患。为了消除隐患，应当使用componentDidUpdate或者setState的回调函数，这两种方式都可以保证在应用更新后触发。如果需要基于之前的state来设置当前的state，查看关于updater部分的描述。</p><p>4、除非shouldComponentUpate()返回false,否则setState()将始终执行重新渲染操作。</p><h4 id="二、参数1：updater函数"><a href="#二、参数1：updater函数" class="headerlink" title="二、参数1：updater函数"></a>二、参数1：updater函数</h4><pre><code class="hljs js">(state,props) =&gt; stateChange</code></pre><p>其中，state是对应用变化时组件状态的引用，它不应该直接被修改。应当使用基于state和props构建的新对象来表示变化。例如，我们需要使用props.step来增加state：</p><pre><code class="hljs js"><span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state, props</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">counter</span>: state.counter + props.step&#125;&#125;)</code></pre><p>updater函数中接收的state和props都保证为最新。updater的返回值会与state进行浅合并。</p><p>🐖：setState()的第一个参数除了接受函数外，还接受对象类型：</p><pre><code class="hljs js">setState(stateChange[,callback])</code></pre><p>stateChange会将传入的对象浅合并到新的state中，例子：</p><pre><code class="hljs js"><span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">counter</span>: <span class="hljs-number">2</span>&#125;)</code></pre><p>这种形式的setState()也是异步的！并且在同一个周期内对多个setState进行批处理。例如，如果在同一个时期多次设置商品数量增加,则相当于：</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.assign(    previousState,    &#123;<span class="hljs-attr">quantiity</span>: state.quantity + <span class="hljs-number">1</span>&#125;,    &#123;<span class="hljs-attr">quantiity</span>: state.quantity + <span class="hljs-number">1</span>&#125;)</code></pre><p>此时，后调用的setState()将覆盖同一周期内先调用setState的值，因此商品数仅增加1次。如果后续状态取决于当前的状态，建议使用updater函数的形式代替：</p><pre><code class="hljs js"><span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">quantity</span>: state.quantity + <span class="hljs-number">1</span>&#125;;&#125;)</code></pre><h4 id="三、参数2：回调函数callback-（可选）"><a href="#三、参数2：回调函数callback-（可选）" class="headerlink" title="三、参数2：回调函数callback （可选）"></a>三、参数2：回调函数callback （可选）</h4><p>这个回调函数，<strong>将在setState完成合并并重新渲染组件后执行</strong>。通常，建议使用componentDidUpdate()方式来代替这个回调函数的使用。</p>]]></content>
    
    
    <categories>
      
      <category>React学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>React01--ref的使用</title>
    <link href="/2020/11/24/React01-ref%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/24/React01-ref%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="ref的详细用法"><a href="#ref的详细用法" class="headerlink" title="ref的详细用法"></a>ref的详细用法</h2><p>在react典型的数据流中，props传递时父子组件交互的唯一方式：通过传递一个新的props值来使子组件重新render，从而达到父子组件通信。但是，某些情况下，你需要在典型数据流之外强制修改子组件。比如：</p><ul><li>管理焦点，文本选择或者媒体播放</li><li>触发强制动画</li><li>集成第三方DOM库</li></ul><p>这些情况下，react提供了新的方案：ref</p><h4 id="一、ref简介"><a href="#一、ref简介" class="headerlink" title="一、ref简介"></a>一、ref简介</h4><p>React提供的ref属性，<strong>表示对组件真正实例的引用</strong>，其实就是ReactDOM.render()返回的组件实例。需要区分一下：ReactDOM.render()渲染组件时返回的是组件实例；而渲染dom元素时，返回的是具体的dom节点。</p><p>例如，下面的代码：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> domCom = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<span class="hljs-keyword">const</span> refDom = ReactDOM.render(domCom,container);<span class="hljs-keyword">const</span> refCom = ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">myComponent</span> /&gt;</span></span>,container);<span class="hljs-built_in">console</span>.log(refDom);<span class="hljs-built_in">console</span>.log(refCom);</code></pre><p>上述代码运行如下：<br><img src="https://pic.downk.cc/item/5fbcde31b18d6271133f9065.jpg"></p><p>ref可以挂在任何组件上，可以挂在组件上也可以是dom元素上：</p><ul><li><font face='黑体' size=4 color=red>挂在组件上（指有状态组件）的ref表示对组件实例的引用</li><li>挂载到dom元素上时表示具体的dom节点 </font></li></ul><h4 id="二、ref可以设置回调函数"><a href="#二、ref可以设置回调函数" class="headerlink" title="二、ref可以设置回调函数"></a>二、ref可以设置回调函数</h4><p>ref属性可以设置为一个回调函数，这也是官方推荐的做法。这个函数的执行时机为：</p><ul><li><font color=blue>组件被挂载后</font>，回调函数立即执行，回调函数的参数为该组件的具体实例。</li><li><font color=blue>组件被卸载或者原有的ref属性本身发生变化时</font>，回调也会被立即执行，此时回调函数参数为null，以避免内存泄漏。</li></ul><p>例子：</p><pre><code class="hljs js"><span class="hljs-comment">//使用ref存储DOM节点的引用：</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomTextInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">construtor</span>(<span class="hljs-params">props</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props);    <span class="hljs-comment">//创建一个ref来存储 textInput 的DOM元素</span>    <span class="hljs-built_in">this</span>.textInput = React.createRef();    <span class="hljs-built_in">this</span>.focusTextInput = <span class="hljs-built_in">this</span>.focusTextInput.bind(<span class="hljs-built_in">this</span>);  &#125;  <span class="hljs-function"><span class="hljs-title">focusTextInput</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-comment">//直接使用原生的API来使得 text输入框获得焦点</span>    <span class="hljs-comment">//注意：我们通过“current” 来访问DOM节点</span>    <span class="hljs-built_in">this</span>.textInput.current.focus();  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-comment">//告诉Reacts 我们想把&lt;input&gt; ref</span>    <span class="hljs-comment">//关联到constructor里面的&#x27;textInput&#x27;上</span>    <span class="hljs-keyword">return</span> (      &lt;div&gt;        &lt;input  type=<span class="hljs-string">&#x27;text&#x27;</span> ref=&#123;<span class="hljs-built_in">this</span>.textInput&#125;/&gt;        &lt;input type=<span class="hljs-string">&#x27;button&#x27;</span> value=<span class="hljs-string">&#x27;focus the text input&#x27;</span> onClick=&#123;<span class="hljs-built_in">this</span>.focusTextInput&#125; /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><p>上述代码中，React将在组件挂载时，会调用ref回调函数并传入DOM元素，当卸载时也调用它并传入null。在componentDidMount 或 componentDidUpdate触发前，React会保证refs一定是最新的。</p><h4 id="三、ref可以设置字符串-了解"><a href="#三、ref可以设置字符串-了解" class="headerlink" title="三、ref可以设置字符串 (了解)"></a>三、ref可以设置字符串 (了解)</h4><p>&emsp;ref还可以设置为字符串值，不过这种方式基本不再推荐使用。</p><pre><code class="hljs js">&lt;input ref=<span class="hljs-string">&#x27;title&#x27;</span> /&gt;</code></pre><p>&emsp;然后再其他地方如事件回调中通过<strong>this.refs</strong>可以访问该组件实例，其实就是dom节点</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> element = <span class="hljs-built_in">this</span>.refs.title;</code></pre><p>我的github里react-demos项目下，question分支模仿知乎问答的例子，就使用了ref的这个用法。<a href="https://github.com/DENGCPU/React-demos/blob/question/README.md">简单知乎问答demo</a></p><h4 id="四、创建与访问Refs"><a href="#四、创建与访问Refs" class="headerlink" title="四、创建与访问Refs"></a>四、创建与访问Refs</h4><p><strong>1.创建refs:</strong></p><p>&emsp;refs是使用<font color=green>React.createRef()</font>创建的，并通过ref属性附加到React元素。在构建组件时，通常将refs分配给组件实例属性，以便在整个组件中都引用它们。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props);    <span class="hljs-built_in">this</span>.myRef = React.createRef();  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.myRef&#125;</span> /&gt;</span></span>;  &#125;&#125;</code></pre><p><strong>2.访问refs:</strong></p><p>&emsp;当ref被传递给render中的元素时，对该节点的引用可以在ref的<font color=red>current</font>属性中被访问。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> node = <span class="hljs-built_in">this</span>.myRef.current;</code></pre><p>ref的值根据节点类型不同而有所不同：</p><ul><li>当ref属性用于HTML元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性。</li><li>当ref属性用于自定义class组件时，ref对象接收组件的挂载实例作为其current属性。</li></ul><p>🐖：不能在函数组件上使用ref属性，因为他们没有实例！</p><p>参考：<a href="https://juejin.cn/post/6844903749211652104">React ref的基本使用</a> 以及 <a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html">React官方文档–Refs and The Dom</a></p>]]></content>
    
    
    <categories>
      
      <category>React学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>28-时刻考虑性能问题</title>
    <link href="/2020/11/21/28-%E6%97%B6%E5%88%BB%E8%80%83%E8%99%91%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/21/28-%E6%97%B6%E5%88%BB%E8%80%83%E8%99%91%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="一、如何避免性能问题："><a href="#一、如何避免性能问题：" class="headerlink" title="一、如何避免性能问题："></a>一、如何避免性能问题：</h4><p>1、了解常见的性能问题场景（解决最可能产生性能问题的场景）</p><ul><li>  键盘输入过程卡顿</li><li>  鼠标的移动过程卡顿</li></ul><p>2、时刻注意代码的潜在性能问题</p><ul><li>什么时候拆分组件</li><li>组件粒度是否够细</li></ul><p>3、注意可重构的代码</p><ul><li>代码的耦合性必须低，功能模块非常独立</li></ul><p>4、了解如何使用工具定位性能问题：</p><ul><li>React-devTool</li><li>Chrome-devTool</li></ul><h4 id="二、网络性能优化：自动化按需加载"><a href="#二、网络性能优化：自动化按需加载" class="headerlink" title="二、网络性能优化：自动化按需加载"></a>二、网络性能优化：自动化按需加载</h4><p>如何在react中实现按需加载：<br>1、按需加载：用户当前需要用什么功能就只加载这个功能对应的代码。<br>2、使用Webpack的import API<br>3、使用react-loadable库实现React异步加载</p><p><img src="https://pic.downk.cc/item/5fb913a4b18d627113603f84.jpg" alt="按需加载"></p><h4 id="三、使用Reselect避免重复计算"><a href="#三、使用Reselect避免重复计算" class="headerlink" title="三、使用Reselect避免重复计算"></a>三、使用Reselect避免重复计算</h4><p>Reselect:创建自动缓存的数据处理流程（只有数据变化时才重新计算，否则使用缓存的结果）</p><p><strong>原则</strong>:所有能够计算得到的数据一定是通过计算拿到</p><p><img src="https://pic.downk.cc/item/5fb91595b18d62711360ba51.jpg" alt="自动缓存"></p><h4 id="四、React异步渲染"><a href="#四、React异步渲染" class="headerlink" title="四、React异步渲染"></a>四、React异步渲染</h4><p><img src="https://pic.downk.cc/item/5fb918ffb18d62711361b0b2.jpg"></p><p><strong>时间分片：</strong><br>1、虚拟DOM的diff操作可以分片进行<br>2、React新API：unstable_deferredUpdates<br>3、Chrome新API：requestIdleCallback 浏览器什么时候空闲</p><p><strong>渲染挂起：</strong></p><p>1、unstable_deferUpdate<br>2、React的新内置组件：Timeout组件</p><h4 id="五、使用工具发现性能问题"><a href="#五、使用工具发现性能问题" class="headerlink" title="五、使用工具发现性能问题"></a>五、使用工具发现性能问题</h4><p>1、使用React DevTool找到多余渲染<br>2、使用Chrome DevTool定位性能瓶颈</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>27-React中拖放的实现</title>
    <link href="/2020/11/21/27-React%E4%B8%AD%E6%8B%96%E6%94%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/11/21/27-React%E4%B8%AD%E6%8B%96%E6%94%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>第三方库实现拖放的缺陷：</strong></p><ul><li>第三方库实现拖放不够灵活，</li><li>很多场景比较简单，并不需要引入第三方库</li><li>增加额外的体积会影响性能。</li></ul><p><strong>实现拖放的技术要点：</strong></p><p>1、如何使用React的鼠标事件系统<br>2、如何判断拖放开始和结束<br>3、如何让实现拖放元素的位置移动<br>4、拖放状态在组件中如何维护</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>26-React集成第三方JS库（d3.js为例）</title>
    <link href="/2020/11/21/26-React%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9JS%E5%BA%93%EF%BC%88d3-js%E4%B8%BA%E4%BE%8B%EF%BC%89/"/>
    <url>/2020/11/21/26-React%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9JS%E5%BA%93%EF%BC%88d3-js%E4%B8%BA%E4%BE%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h4 id="集成第三方JS库的技术要点："><a href="#集成第三方JS库的技术要点：" class="headerlink" title="集成第三方JS库的技术要点："></a>集成第三方JS库的技术要点：</h4><p>1、使用ref获取原生DOM节点引用<br>2、手动将组件状态更新到DOM节点<br>3、组件销毁时移除原生节点DOM事件</p><p>d3.js用来画图形的第三方库，操作原生DOM节点，也是以数据驱动（与React非常吻合）。</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>25-使用React-Router实现分布操作</title>
    <link href="/2020/11/21/25-%E4%BD%BF%E7%94%A8React-Router%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/11/21/25-%E4%BD%BF%E7%94%A8React-Router%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="向导页面需要考虑的技术要点："><a href="#向导页面需要考虑的技术要点：" class="headerlink" title="向导页面需要考虑的技术要点："></a>向导页面需要考虑的技术要点：</h4><p>例子：一个向导页面<br><img src="https://pic.downk.cc/item/5fb8dbeab18d62711350c62f.jpg"></p><p>1、使用URL进行导航<br>2、表单数据如何管理<br>3.页面状态如何切换（根据数据的状态决定UI的状态）</p><h4 id="基于路由实现菜单导航："><a href="#基于路由实现菜单导航：" class="headerlink" title="基于路由实现菜单导航："></a>基于路由实现菜单导航：</h4><p>技术要点：<br>1.菜单导航只改变URL状态<br>2.根据当前URL显示菜单的当前状态。</p><p>可以使用react-router的NavLink,展示当前的选中状态 （NavLink的activeClassName属性）</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>24-页面数据来源于多个请求</title>
    <link href="/2020/11/21/24-%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90%E4%BA%8E%E5%A4%9A%E4%B8%AA%E8%AF%B7%E6%B1%82/"/>
    <url>/2020/11/21/24-%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90%E4%BA%8E%E5%A4%9A%E4%B8%AA%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h4 id="一、页面数据来自多个请求："><a href="#一、页面数据来自多个请求：" class="headerlink" title="一、页面数据来自多个请求："></a>一、页面数据来自多个请求：</h4><p>1、请求之间无依赖关系时，多个请求可以并发进行</p><p>2、请求之间有依赖关系时，需要依次进行</p><p>3、请求完成之前，页面显示Loding状态<br>（Loding可能并不需要特别设为一个状态值，可以根据数据的状态来判断是否显示’Loding..’)</p><h4 id="二、内容页的加载与缓存"><a href="#二、内容页的加载与缓存" class="headerlink" title="二、内容页的加载与缓存"></a>二、内容页的加载与缓存</h4><p><img src="https://pic.downk.cc/item/5fb8da68b18d627113503356.jpg"></p><p><strong>内容页和列表页的数据关系：</strong></p><ul><li>简单业务：列表页数据包含内容页的数据</li><li>复杂业务：内容页数据需要额外获取</li><li>内容页数据的缓存</li></ul><p>🐖：内容页不能只依靠列表页进行，用户可能刷新页面，所以它自己也需要定义一个访问接口的action。</p><p><img src="https://pic.downk.cc/item/5fb8d9d7b18d627113500886.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>23-在React中实现列表页</title>
    <link href="/2020/11/20/23-%E5%9C%A8React%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E9%A1%B5/"/>
    <url>/2020/11/20/23-%E5%9C%A8React%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E9%A1%B5/</url>
    
    <content type="html"><![CDATA[<h4 id="一、列表页：搜索、数据缓存和分页"><a href="#一、列表页：搜索、数据缓存和分页" class="headerlink" title="一、列表页：搜索、数据缓存和分页"></a>一、列表页：搜索、数据缓存和分页</h4><p>开发列表页需要考虑的技术要点：</p><ul><li>如何翻页</li><li>如何进行内容搜索</li><li>如何缓存数据</li><li>何时进行页面刷新</li></ul><p><img src="https://pic.downk.cc/item/5fb76b52b18d627113ee2145.jpg" alt="列表页的数据模型"></p><p><img src="https://pic.downk.cc/item/5fb76b8eb18d627113ee2fe8.jpg" alt="Store的设计"></p><p><img src="https://pic.downk.cc/item/5fb76ccbb18d627113ee8a4b.jpg" alt="URL设计和Store同步"></p><h4 id="二、列表页：缓存更新、加载状态以及错误处理"><a href="#二、列表页：缓存更新、加载状态以及错误处理" class="headerlink" title="二、列表页：缓存更新、加载状态以及错误处理"></a>二、列表页：缓存更新、加载状态以及错误处理</h4><p><img src="https://pic.downk.cc/item/5fb76f47b18d627113ef65f6.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>22-在React中实现表单</title>
    <link href="/2020/11/20/22-%E5%9C%A8React%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%A1%A8%E5%8D%95/"/>
    <url>/2020/11/20/22-%E5%9C%A8React%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%A1%A8%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h4 id="一、实现表单：初始数据、提交和跳转"><a href="#一、实现表单：初始数据、提交和跳转" class="headerlink" title="一、实现表单：初始数据、提交和跳转"></a>一、实现表单：初始数据、提交和跳转</h4><p>1、单纯使用React的方式实现表单</p><p><img src="https://pic.downk.cc/item/5fb76076b18d627113eb2a31.jpg"></p><p>🐖：是在form中编辑onSubmit，而不是在button的点击事件里提交，这样即使你点回车也会进行提交（给出错误提示）</p><p>可以发现这样实现表单是比较麻烦的！</p><p>2、使用UI library实现表单（比如Antd)</p><p>具体参照：<a href="https://ant.design/components/form-cn/#header">Antd-Form表单</a></p><p>3、可以对API进行封装</p><h4 id="二、实现表单：错误处理、动态操作表单元素，内容动态加载"><a href="#二、实现表单：错误处理、动态操作表单元素，内容动态加载" class="headerlink" title="二、实现表单：错误处理、动态操作表单元素，内容动态加载"></a>二、实现表单：错误处理、动态操作表单元素，内容动态加载</h4><p>以Antd为例：一个demo<br><a href="https://codesandbox.io/s/6n20nrzlxz?file=/src/c29/FormBuilder.js">https://codesandbox.io/s/6n20nrzlxz?file=/src/c29/FormBuilder.js</a></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>21-ReactRouter管理登录和授权</title>
    <link href="/2020/11/20/21-ReactRouter%E7%AE%A1%E7%90%86%E7%99%BB%E5%BD%95%E5%92%8C%E6%8E%88%E6%9D%83/"/>
    <url>/2020/11/20/21-ReactRouter%E7%AE%A1%E7%90%86%E7%99%BB%E5%BD%95%E5%92%8C%E6%8E%88%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<h3 id="使用React-Router-管理路由授权"><a href="#使用React-Router-管理路由授权" class="headerlink" title="使用React-Router 管理路由授权"></a>使用React-Router 管理路由授权</h3><p>1、实现基础：React Router的动态路由机制<br>2、区分受保护路由和公开路由<br>3、访问未授权路由时重定向到登录页面或显示禁止访问</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>20-使用Rekit开发可扩展的React应用</title>
    <link href="/2020/11/20/20-%E4%BD%BF%E7%94%A8Rekit%E5%BC%80%E5%8F%91%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84React%E5%BA%94%E7%94%A8/"/>
    <url>/2020/11/20/20-%E4%BD%BF%E7%94%A8Rekit%E5%BC%80%E5%8F%91%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84React%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="Rekit-React专属IDE和工具集"><a href="#Rekit-React专属IDE和工具集" class="headerlink" title="Rekit: React专属IDE和工具集"></a>Rekit: React专属IDE和工具集</h3><p><img src="https://pic.downk.cc/item/5fb7295cb18d627113dc80e8.jpg"></p><h4 id="一、使用Rekit创建项目，代码生成和重构"><a href="#一、使用Rekit创建项目，代码生成和重构" class="headerlink" title="一、使用Rekit创建项目，代码生成和重构"></a>一、使用Rekit创建项目，代码生成和重构</h4><p>只需要写功能部分的代码，不用再自己构建骨架。</p><p><img src="https://pic.downk.cc/item/5fb729deb18d627113dca15a.jpg"></p><p><img src="https://pic.downk.cc/item/5fb72aa5b18d627113dccff5.jpg"></p><p><img src="https://pic.downk.cc/item/5fb72b4cb18d627113dcfc0c.jpg"></p><p><img src="https://pic.downk.cc/item/5fb72c21b18d627113dd4456.jpg"></p><p><img src="https://pic.downk.cc/item/5fb72c51b18d627113dd4ee6.jpg"></p><p><img src="https://pic.downk.cc/item/5fb72ceeb18d627113dd7003.jpg"></p><h4 id="二、使用Rekit遵循最佳实践和保持代码一致性"><a href="#二、使用Rekit遵循最佳实践和保持代码一致性" class="headerlink" title="二、使用Rekit遵循最佳实践和保持代码一致性"></a>二、使用Rekit遵循最佳实践和保持代码一致性</h4><p>==最佳实践:==</p><ul><li>1.以feature方式组织代码</li><li>2.拆分组件component，action和reducer</li><li>3.拆分路由配置</li></ul><p>==通过代码自动生成保持一致性：==</p><ul><li>1.文件夹结构一致性</li><li>2.文件名一致性</li><li>3.变量名一致性</li><li>4.代码逻辑一致性</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>19-拆分大型项目的复杂度</title>
    <link href="/2020/11/20/19-%E6%8B%86%E5%88%86%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2020/11/20/19-%E6%8B%86%E5%88%86%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="拆分复杂度"><a href="#拆分复杂度" class="headerlink" title="拆分复杂度"></a>拆分复杂度</h3><h4 id="一、按领域模型（feature）组织代码，降低耦合度"><a href="#一、按领域模型（feature）组织代码，降低耦合度" class="headerlink" title="一、按领域模型（feature）组织代码，降低耦合度"></a>一、按领域模型（feature）组织代码，降低耦合度</h4><p><img src="https://pic.downk.cc/item/5fb71ee0b18d627113d9dabc.jpg"></p><p><img src="https://pic.downk.cc/item/5fb71f0ab18d627113d9e304.jpg"></p><p><img src="https://pic.downk.cc/item/5fb71f24b18d627113d9e849.jpg"></p><p><strong>解决：先以业务逻辑,以功能进行划分，然后每个功能(feature)内部有自己的reducer，component，action</strong></p><p><img src="https://pic.downk.cc/item/5fb71f7db18d627113d9fdb5.jpg"></p><p>使用React技术栈如何实现这种架构？</p><p><img src="https://pic.downk.cc/item/5fb71fe1b18d627113da1548.jpg"></p><p>以功能区分，路由配置也可以分散在每个feature中，这样可扩展性和可维护性更好！</p><h4 id="二、如何组织component，action-和-reducer"><a href="#二、如何组织component，action-和-reducer" class="headerlink" title="二、如何组织component，action 和 reducer"></a>二、如何组织component，action 和 reducer</h4><p><img src="https://pic.downk.cc/item/5fb720bab18d627113da4750.jpg"></p><p>单元测试文件夹tests是单独维护的，单独放在一个地方。</p><p>常量：通常在每个feature下面有个constant.js文件</p><p><img src="https://pic.downk.cc/item/5fb72191b18d627113da77a0.jpg"></p><p>rootReducer的写法：<br><img src="https://pic.downk.cc/item/5fb721e2b18d627113da87fe.jpg"></p><p><strong>总结</strong>：</p><ul><li>按照feature组织组件component，action和reducer</li><li>使用root loader加载feature下的各个资源</li><li>做到高内聚、松耦合</li></ul><h4 id="三、如何组织React-Route的路由配置"><a href="#三、如何组织React-Route的路由配置" class="headerlink" title="三、如何组织React Route的路由配置"></a>三、如何组织React Route的路由配置</h4><p><img src="https://pic.downk.cc/item/5fb72294b18d627113dabdf7.jpg"></p><p>推荐JSON方式的路由：</p><p><img src="https://pic.downk.cc/item/5fb722f6b18d627113dae650.jpg"></p><p>解析JSON路由：<br><img src="https://pic.downk.cc/item/5fb72375b18d627113db0340.jpg"></p><p><strong>总结</strong>：</p><ul><li>每个feature都有自己的专属路由配置</li><li>顶层路由使用JSON配置更容易维护</li><li>如何解析JSON配置到React Router语法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>18-前端项目的理想架构</title>
    <link href="/2020/11/20/18-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%90%86%E6%83%B3%E6%9E%B6%E6%9E%84/"/>
    <url>/2020/11/20/18-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%90%86%E6%83%B3%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="前端项目的理想架构"><a href="#前端项目的理想架构" class="headerlink" title="前端项目的理想架构"></a>前端项目的理想架构</h3><p><img src="https://pic.downk.cc/item/5fb71b94b18d627113d91010.jpg"></p><h4 id="1、-易于开发"><a href="#1、-易于开发" class="headerlink" title="1、 易于开发"></a>1、 易于开发</h4><ul><li>开发工具是否完善</li><li>生态圈是否繁荣</li><li>社区是否活跃</li></ul><h4 id="2、易于扩展"><a href="#2、易于扩展" class="headerlink" title="2、易于扩展"></a>2、易于扩展</h4><ul><li>增加新动能是否容易</li><li>新功能是否会显著增加系统复杂度</li></ul><h4 id="3、易于维护"><a href="#3、易于维护" class="headerlink" title="3、易于维护"></a>3、易于维护</h4><ul><li>代码是否容易理解</li><li>文档是否健全</li></ul><h4 id="4、易于测试"><a href="#4、易于测试" class="headerlink" title="4、易于测试"></a>4、易于测试</h4><p>（测试后于开发，所以必须在开发时就考虑清楚）</p><ul><li>功能的分层是否清晰（Jquery那种就很难进行单元测试）</li><li>副作用少</li><li>尽量使用纯函数</li></ul><h4 id="5、易于构建"><a href="#5、易于构建" class="headerlink" title="5、易于构建"></a>5、易于构建</h4><ul><li>使用通用技术和架构</li><li>构建工具的选择（webpack等，</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>17-常用开发调试工具</title>
    <link href="/2020/11/20/17-%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <url>/2020/11/20/17-%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="常用开发调试工具："><a href="#常用开发调试工具：" class="headerlink" title="常用开发调试工具："></a>常用开发调试工具：</h3><h4 id="1-ESLint"><a href="#1-ESLint" class="headerlink" title="1.ESLint"></a>1.ESLint</h4><ul><li>使用.eslintrc进行规则的配置</li><li>告诉你哪里不符合规则</li><li>可以使用airbnb的JavaScript代码风格</li></ul><h4 id="2-Prettier"><a href="#2-Prettier" class="headerlink" title="2.Prettier"></a>2.Prettier</h4><ul><li>代码格式化的神器（可以自动修改不符合规则的）</li><li>包装更容易写出风格一致的代码</li></ul><h4 id="3-React-Dev-Tools"><a href="#3-React-Dev-Tools" class="headerlink" title="3.React Dev Tools"></a>3.React Dev Tools</h4><p><img src="https://pic.downk.cc/item/5fb71930b18d627113d88a26.jpg"></p><ul><li>可以观察React组件树的DOM结构</li><li>可以看到哪些组件render</li></ul><h4 id="4-Redux-Dev-Tools"><a href="#4-Redux-Dev-Tools" class="headerlink" title="4.Redux Dev Tools"></a>4.Redux Dev Tools</h4><p><img src="https://pic.downk.cc/item/5fb7197bb18d627113d898dd.jpg"></p><ul><li>可以观察当前Store的状态</li><li>用户发出动作后，会看到action</li><li>时间线：可以恢复到action变化之前的时间线</li><li>可以自动生成一些测试的代码，直接copy到单元测试文件中</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>16-使用Jest和Enzyme等工具进行单元测试</title>
    <link href="/2020/11/18/16-%E4%BD%BF%E7%94%A8Jest%E5%92%8CEnzyme%E7%AD%89%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/11/18/16-%E4%BD%BF%E7%94%A8Jest%E5%92%8CEnzyme%E7%AD%89%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一、React让前端单元测试变得容易："><a href="#一、React让前端单元测试变得容易：" class="headerlink" title="一、React让前端单元测试变得容易："></a>一、React让前端单元测试变得容易：</h3><p>1、React应用很少需要访问浏览器API<br>2、虚拟DOM可以在NodeJS环境运行和测试<br>3、Redux隔离了状态管理，纯数据层单元测试</p><h3 id="二、单元测试涉及的工具"><a href="#二、单元测试涉及的工具" class="headerlink" title="二、单元测试涉及的工具"></a>二、单元测试涉及的工具</h3><p>1、Jest: FaceBook开源的JS单元测试框架<br>2、JS DOM： 浏览器环境的NodeJS模拟<br>3、Enzyme： react组件渲染和测试<br>4、nock： 模拟HTTP请求<br>5、sinon： 函数模拟和调用跟踪<br>6、istanbul: 单元测试覆盖率（对已有方法修改和埋点）</p><p><img src="https://pic.downk.cc/item/5fb4bc4cb18d62711351ecbc.jpg"></p><p><img src="https://pic.downk.cc/item/5fb4bc5fb18d62711351f09e.jpg"></p><p><img src="https://pic.downk.cc/item/5fb4bc9db18d62711351fc16.jpg"></p><p><img src="https://pic.downk.cc/item/5fb4bdf1b18d6271135241c2.jpg"></p><p><img src="https://pic.downk.cc/item/5fb4be5eb18d627113525540.jpg"></p><p><img src="https://pic.downk.cc/item/5fb4bef6b18d627113527125.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单元测试工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15-使用Next.js</title>
    <link href="/2020/11/18/15-%E4%BD%BF%E7%94%A8Next-js/"/>
    <url>/2020/11/18/15-%E4%BD%BF%E7%94%A8Next-js/</url>
    
    <content type="html"><![CDATA[<p>使用next.js开发React项目的同构应用。</p><h3 id="一、什么是同构应用？"><a href="#一、什么是同构应用？" class="headerlink" title="一、什么是同构应用？"></a>一、什么是同构应用？</h3><p><img src="https://pic.downk.cc/item/5fb4b6adb18d62711350daf9.jpg"></p><p>next.js可以自动配置好同构应用的webpack配置等细节。</p><h3 id="二、next的基本用法"><a href="#二、next的基本用法" class="headerlink" title="二、next的基本用法"></a>二、next的基本用法</h3><p><img src="https://pic.downk.cc/item/5fb4b787b18d62711350fce5.jpg"></p><p><strong>在页面中使用其他的React组件：</strong></p><p>1、页面也是标准的node模块，可使用其他的React组件 （放在components目录下面）<br>2、页面会针对性打包， 仅包含起引入的组件。</p><p><img src="https://pic.downk.cc/item/5fb4b95bb18d627113515a13.jpg"></p><p>🐖：prefetch并不会预加载服务器端的数据</p><p><strong>关于lazy load:</strong><br><img src="https://pic.downk.cc/item/5fb4ba11b18d627113517eef.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14-UI组件库的对比</title>
    <link href="/2020/11/18/14-UI%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <url>/2020/11/18/14-UI%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Ant-Design"><a href="#一、Ant-Design" class="headerlink" title="一、Ant Design"></a>一、Ant Design</h3><p>服务于企业级产品的设计体系，有完善的文档</p><h3 id="二、Marterial-UI"><a href="#二、Marterial-UI" class="headerlink" title="二、Marterial-UI"></a>二、Marterial-UI</h3><p>风格更时尚，更花哨，面向消费者</p><h3 id="三、Semantic-UI"><a href="#三、Semantic-UI" class="headerlink" title="三、Semantic UI"></a>三、Semantic UI</h3><p>把UI作为language描述，提供了不同library的实现。</p><p><strong>选择UI库的考虑因素：</strong></p><ul><li>1、组件库是否齐全</li><li>2、样式风格是否符合业务需求</li><li>3、API的设计是否便捷灵活</li><li>4、技术支持是否完善（文档，issue）</li><li>5、开发是否活跃（维护，迭代）</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>bug记录</title>
    <link href="/2020/11/18/bug%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/11/18/bug%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1、-Error-“Objects-are-not-valid-as-a-React-child”"><a href="#1、-Error-“Objects-are-not-valid-as-a-React-child”" class="headerlink" title="1、 Error: “Objects are not valid as a React child”"></a>1、 Error: “Objects are not valid as a React child”</h3><p>在redux的练习中，blog这个demo报了这个错：</p><p><img src="https://pic.downk.cc/item/5fb48937b18d62711347d6df.jpg"></p><p>原代码：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> jsonPlaceholder.get(<span class="hljs-string">`/users/<span class="hljs-subst">$&#123;id&#125;</span>`</span>);dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;FETCH_USER&quot;</span>, <span class="hljs-attr">payload</span>: response.data &#125;);</code></pre><p>打开访问的API后发现，response.data是个object类型，不能直接赋值给payload<br>应该先通过JSON.stringify()将其转换为JSON格式，再进行赋值。</p><p>修改后的代码如下：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> jsonPlaceholder.get(<span class="hljs-string">`/users/<span class="hljs-subst">$&#123;id&#125;</span>`</span>);<span class="hljs-keyword">const</span> data = <span class="hljs-built_in">JSON</span>.stringify(response.data);dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;FETCH_USER&quot;</span>, <span class="hljs-attr">payload</span>: data &#125;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>bug汇总</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13-React-Router:路由不只是页面切换，更是代码组织方式</title>
    <link href="/2020/11/17/13-React-Router-%E8%B7%AF%E7%94%B1%E4%B8%8D%E5%8F%AA%E6%98%AF%E9%A1%B5%E9%9D%A2%E5%88%87%E6%8D%A2%EF%BC%8C%E6%9B%B4%E6%98%AF%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/"/>
    <url>/2020/11/17/13-React-Router-%E8%B7%AF%E7%94%B1%E4%B8%8D%E5%8F%AA%E6%98%AF%E9%A1%B5%E9%9D%A2%E5%88%87%E6%8D%A2%EF%BC%8C%E6%9B%B4%E6%98%AF%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="一、为什么需要路由？"><a href="#一、为什么需要路由？" class="headerlink" title="一、为什么需要路由？"></a>一、为什么需要路由？</h3><ul><li>1.单页应用需要进行页面切换</li><li>2.通过URL可以定位到页面</li><li>3.更有语义的组织资源</li></ul><p><img src="https://pic.downk.cc/item/5fb37daab18d62711306e930.jpg"></p><p><img src="https://pic.downk.cc/item/5fb37e3cb18d6271130703a8.jpg"></p><h3 id="二、React-Router的特性："><a href="#二、React-Router的特性：" class="headerlink" title="二、React-Router的特性："></a>二、React-Router的特性：</h3><p>1、声明式路由定义<br>2、动态路由：页面render时，path才会被解析</p><h3 id="三、实现路由的三种方式"><a href="#三、实现路由的三种方式" class="headerlink" title="三、实现路由的三种方式"></a>三、实现路由的三种方式</h3><p>1、URL路由<br>2、Hash路由： #+ 路径，支持低版本<br>3、内存路由：MemoryRouter，服务器端渲染</p><h3 id="四、基于路由配置进行资源组织"><a href="#四、基于路由配置进行资源组织" class="headerlink" title="四、基于路由配置进行资源组织"></a>四、基于路由配置进行资源组织</h3><p>1、实现业务逻辑的松耦合<br>2、易于扩展，重构和维护<br>3、路由层面实现Lazy Load</p><h3 id="五、React-Router-的几个API"><a href="#五、React-Router-的几个API" class="headerlink" title="五、React-Router 的几个API"></a>五、React-Router 的几个API</h3><p><img src="https://pic.downk.cc/item/5fb37fdab18d627113075987.jpg"></p><p><img src="https://pic.downk.cc/item/5fb37feeb18d627113075f96.jpg"></p><p><img src="https://pic.downk.cc/item/5fb38003b18d627113076520.jpg"></p><p><img src="https://pic.downk.cc/item/5fb38032b18d627113076f40.jpg"></p><p><img src="https://pic.downk.cc/item/5fb38056b18d627113077657.jpg"></p><p><img src="https://pic.downk.cc/item/5fb380a8b18d627113078667.jpg"></p><h3 id="六、通过URL传递参数"><a href="#六、通过URL传递参数" class="headerlink" title="六、通过URL传递参数"></a>六、通过URL传递参数</h3><p><img src="https://pic.downk.cc/item/5fb3827bb18d62711307e56e.jpg"></p><p><img src="https://pic.downk.cc/item/5fb3834eb18d627113081472.jpg"></p><p><img src="https://pic.downk.cc/item/5fb3842ab18d627113084eaf.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12-Redux在Rect中的用法</title>
    <link href="/2020/11/17/12-Redux%E5%9C%A8Rect%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2020/11/17/12-Redux%E5%9C%A8Rect%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>&emsp;为了方便在react中使用redux, Redux的作者封装了一个React专用的库<strong>React-Redux</strong>.</p><p>&emsp;这个库是可选的，在实际项目中应该权衡下是直接使用redux还是使用React-Redux。后者虽然方便，但是要掌握额外的API，并且要遵守它的组件拆分规则。</p><h3 id="一、UI组件"><a href="#一、UI组件" class="headerlink" title="一、UI组件"></a>一、UI组件</h3><p>&emsp;React-Redux将所有组件分为两大类：</p><ul><li>UI组件（presentational component）</li><li>容器组件（container component）</li></ul><p>&emsp;UI组件有以下特征：</p><ul><li>1、只负责UI的呈现，不带任何业务逻辑</li><li>2、没有状态（即不适用this.state这个变量）</li><li>3、所有数据都由参数（this.props)提供</li><li>4、不使用任何Redux的API</li></ul><p>一个UI组件的例子：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> Title = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></code></pre><p>&emsp;因为不含有状态，UI组件又称为‘纯组件’，即它和纯函数一样，纯粹由参数决定它的值。</p><h3 id="二、容器组件"><a href="#二、容器组件" class="headerlink" title="二、容器组件"></a>二、容器组件</h3><p>&emsp; 容器组件的特征恰恰相反：</p><ul><li>负责管理数据和业务逻辑，不负责UI的呈现</li><li>带有内部状态</li><li>使用Redux的API</li></ul><p>&emsp;总之，UI组件负责UI的呈现，容器组件负责管理数据和逻辑。</p><p>&emsp;如果一个组件既有UI又有业务逻辑，那么应该将它拆分为下面的结构：外面是一个容器组件，里面包含一个UI组件。前者负责与外部的通信，将数据传给后者，由后者渲染出试图。</p><p>&emsp;React-Redux规定，所有的UI组件由用户提供，容器组件则由React-Redux自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。</p><h3 id="三、connect"><a href="#三、connect" class="headerlink" title="三、connect()"></a>三、connect()</h3><p>&emsp;React-Redux提供connect方法，用于从UI组件生成容器组件。（connect的意思就是将这两种组件连起来）</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;connect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span><span class="hljs-keyword">const</span> VisibleTodoList = connect()(TodoList);<span class="hljs-comment">//TodoList是UI组件，VisibleTodoList就是通过connect方法自动生成的容器组件</span></code></pre><p>&emsp;但是由于没有定义业务逻辑，上面这个容器组件没有任何意义，只是UI组件的一个单纯的包装层。为了定义业务逻辑，需要给出以下信息：</p><ul><li>（1）输入逻辑：外部的数据（即state对象）如何转换为UI组件的参数。</li><li>（2）输出逻辑：用户发出的动作如何变为Action对象，从UI组件传出去。</li></ul><p>&emsp;因此，connect方法的完整API如下：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;connect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<span class="hljs-keyword">const</span> VisibleTodoList = connect(    mapStateToProps,    mapDispatchToProps)(TodoList)</code></pre><p>&emsp;connect函数接受两个参数：mapStateToProps  和 mapDispatchToProps。它们定义了UI组件的业务逻辑：前者负责输入逻辑，即将state映射到UI组件的参数（props),后者负责输出逻辑，即将用户对UI组件的操作映射为Action对象。</p><h3 id="四、mapStateToProps"><a href="#四、mapStateToProps" class="headerlink" title="四、mapStateToProps()"></a>四、mapStateToProps()</h3><p>&emsp; mapStateToProps是一个函数，它的作用就是像它的名字那样，建立一个从（外部的）state对象到（UI组件的）props对象的映射关系。</p><p>&emsp;作为函数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。<br>例子：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> mapStateToProps=<span class="hljs-function">(<span class="hljs-params">state</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123;        <span class="hljs-comment">//todos属性，代表UI组件的同名属性</span>        <span class="hljs-comment">//getVisibleTodos可以从state算出todos的值</span>        todos: getVisibleTodos(state.todos,state.visibilityFilter)    &#125;&#125;<span class="hljs-comment">//getVisibleTodos可以从state算出todos的值</span><span class="hljs-keyword">const</span> getVisibleTodos=<span class="hljs-function">(<span class="hljs-params">todos,filter</span>)=&gt;</span>&#123;    <span class="hljs-function"><span class="hljs-title">switch</span>(<span class="hljs-params">filter</span>)</span>&#123;        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;SHOW_ALL&#x27;</span>:            <span class="hljs-keyword">return</span> todos;        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;SHOW_COMPLETED&#x27;</span>:            <span class="hljs-keyword">return</span> todos.filter(<span class="hljs-function"><span class="hljs-params">t</span>=&gt;</span>t.completed);        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;SHOW_ACTIVE&#x27;</span>:            <span class="hljs-keyword">return</span> todos.filter(<span class="hljs-function"><span class="hljs-params">t</span>=&gt;</span>!t.completed);        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Unknow filter:&#x27;</span>+filter)    &#125;&#125;</code></pre><p>&emsp;mapStateToProps 会订阅Store,每当state更新的时候，会自动执行，重新计算UI组件的参数，从而触发UI组件的重新渲染。</p><p>&emsp;mapStateToProps 的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象。</p><pre><code class="hljs js"><span class="hljs-comment">//容器组件的代码</span><span class="hljs-comment">// &lt;FilterLink filter=&#x27;SHOW_ALL&#x27;&gt;ALL&lt;/FilterLink&gt;</span><span class="hljs-keyword">const</span> mapStateToProps = <span class="hljs-function">(<span class="hljs-params">state,ownProps</span>) =&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123;        active:ownProps.filter === state.visibilityFilter    &#125;&#125;</code></pre><p> &emsp;使用ownProps作为参数后，如果容器组件的参数发生变化，也会引起UI组件重新渲染。</p><p> &emsp;connect方法可以省略mapStateToProps参数，那样的话UI组件就不会订阅Store, 也就是说Store的更新不会引起UI组件渲染。</p><h3 id="五、mapDispatchToProps"><a href="#五、mapDispatchToProps" class="headerlink" title="五、mapDispatchToProps()"></a>五、mapDispatchToProps()</h3><p> &emsp;mapDispatchToProps 是connect函数的第二个参数，用来建立UI组件的参数到Store.dispatch的映射，它定义了哪些用户的操作应该当作Action，传给Store。它可以是一个函数，也可以是一个对象。</p><p> &emsp;1、<strong>如果mapDispatchToProps是一个函数</strong>，会得到dispatch和ownProps(容器组件的props对象)两个参数。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> mapDispatchToProps = (    dispatch,    ownProps) =&gt; &#123;    <span class="hljs-keyword">return</span> &#123;        onClick:<span class="hljs-function">()=&gt;</span>&#123;            dispatch(&#123;                type:<span class="hljs-string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>,                filter:ownProps.filter            &#125;)        &#125;    &#125;&#125;</code></pre><p>&emsp;从上述代码中可以看出，mapispatchToProps作为函数，应该返回以一个对象，该对象的每个键值对都是一个映射，定义了UI组件的参数怎样发出action。</p><p>&emsp;2、<strong>如果mapDispatchToProps是一个对象</strong>，它的每个键名也是对应UI的同名参数，键值应该是一个函数，会被当作是Action Creator,返回的Action会由Redux自动发出。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> mapDispatchToProps=&#123;    onClick:<span class="hljs-function">(<span class="hljs-params">filter</span>)=&gt;</span>&#123;        type:<span class="hljs-string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>,        filter:filter    &#125;&#125;</code></pre><h3 id="六、Provider组件"><a href="#六、Provider组件" class="headerlink" title="六、Provider组件"></a>六、Provider组件</h3><p>&emsp;connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成UI组件的参数。一种解决方法是将state对象作为参数，传给容器组件。但是这样比较麻烦，尤其是容器组件在很深的层级时，一级级将state传下去就很麻烦。</p><p>&emsp;React-Redux提供Provider组件，可以让容器组件拿到state。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;Provider&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">import</span> todoApp <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducers&#x27;</span>;<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/App&#x27;</span>;<span class="hljs-keyword">let</span> store = createStore(todoApp);render(    &lt;Provider store=&#123;store&#125;&gt;        &lt;App /&gt;    &lt;/Provider&gt;,    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>))</code></pre><p>&emsp;Provider 在根组件外面包了一层，这样一来，App的所有子组件默认都可以拿到state了。Provider的原理时React组件的context属性。<br>源码：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Provider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">getChildContext</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> &#123;            store:<span class="hljs-built_in">this</span>.props.store        &#125;    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.props.children;    &#125;&#125;Provider.childContextTypes = &#123;    store:React.PropTypes.object&#125;</code></pre><p>&emsp;上面代码中，store放在了上下文对象context上面。然后，子组件就可以从context拿到store。代码如下：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VisibleTodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">const</span> &#123;store&#125; = <span class="hljs-built_in">this</span>.context;        <span class="hljs-built_in">this</span>.unsubscribe=store.subscribe(<span class="hljs-function">()=&gt;</span>            <span class="hljs-built_in">this</span>.forceUpdate()        );    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">const</span> props=<span class="hljs-built_in">this</span>.props;        <span class="hljs-keyword">const</span> &#123;store&#125;=<span class="hljs-built_in">this</span>.context;        <span class="hljs-keyword">const</span> state=store.getState();        <span class="hljs-comment">//...</span>    &#125;&#125;VisibleTodoList.contextTypes = &#123;    store:React.PropTypes.object&#125;</code></pre><p>React-Redux 自动生成的容器组件的代码就是类似于上面这样，拿到store。</p><h3 id="七、React-Router-路由库"><a href="#七、React-Router-路由库" class="headerlink" title="七、React-Router 路由库"></a>七、React-Router 路由库</h3><p>&emsp;使用React-Router的项目，与其他项目没有不同之处，也是使用Provider在Router外面包一层。毕竟Provider的唯一功能就是传入store对象。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> Root = <span class="hljs-function">(<span class="hljs-params">&#123;store&#125;</span>) =&gt;</span> (    &lt;Provider store=&#123;store&#125;&gt;        &lt;Router&gt;            &lt;Route path=<span class="hljs-string">&quot;/&quot;</span> component=&#123;App&#125; /&gt;        &lt;/Router&gt;    &lt;/Provider&gt;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11-redux之中间件与异步操作</title>
    <link href="/2020/11/16/11-redux%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/11/16/11-redux%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>第10篇文章里，介绍了redux的基本做法：用户发出Action, Reducer函数算出新的State，View重新渲染。<br><img src="https://pic.downk.cc/item/5fb26119b18d627113c52bcf.jpg"><br>但是异步操作应该怎么处理呢？Action发出以后，Reducer立即算出新的State, 这就叫做同步；Action发出后，过一段时间再执行Reducer,这就叫做异步。<br>怎么才能让reducer在异步操作结束后自动执行呢？这就要用到新的工具： <strong>中间件</strong>（middleware）<br><img src="https://pic.downk.cc/item/5fb27135b18d627113c87d35.jpg"></p><h3 id="一、中间件的概念"><a href="#一、中间件的概念" class="headerlink" title="一、中间件的概念"></a>一、中间件的概念</h3><p>为了让redux可以进行异步操作，势必要在redux工作流程中添加新的功能。那么在哪个环节添加合适呢？</p><p>（1）Reducer: 纯函数，只能承担计算State的功能，不适合承担其他功能，也承担不了。因为理论上，纯函数不能进行读写的操作。</p><p>（2）View: 与State一一对应，可以看作是State的视觉层，也不合适承担其他功能。</p><p>（3）Action: 存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。</p><p>想来想去，只有发送Action的这个步骤，即Store.dispatch()这个方法，可以添加功能。<br>中间件就是一个函数，对store.dispatch方法进行了改造，在发出Action和执行Reducer这两步之间，添加了其他功能。</p><h3 id="二、中间件的使用"><a href="#二、中间件的使用" class="headerlink" title="二、中间件的使用"></a>二、中间件的使用</h3><p>常用的中间件都是现成的，只有引用别人写好的模块就行。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; applyMiddleware,createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">import</span> createLogger <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-logger&#x27;</span>;<span class="hljs-keyword">const</span> logger = createLogger();<span class="hljs-keyword">const</span> store = createStore(    reducer,    initialState, <span class="hljs-comment">//整个应用的初始状态</span>    applyMiddleware(logger))</code></pre><p>🐖：中间件的次序有讲究。有的中间件有次序要求，比如logger就一定放在最后，否则输出结果会不正确。使用前要查阅相关文档</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = createStore(    reducer,    appltMiddleware(thunk,promise,logger)    <span class="hljs-comment">//这里是用了三个中间件</span>)</code></pre><p>==applyMiddlewares()：== applyMiddlewares是Redux的原生方法，作用是将所有中间件组成一个数组，依次执行。</p><h3 id="三、异步操作的基本思路"><a href="#三、异步操作的基本思路" class="headerlink" title="三、异步操作的基本思路"></a>三、异步操作的基本思路</h3><p>同步操作只要发出一种Action即可，异步操作的差别是它要发出三种Action:</p><ul><li>操作发起时的Action</li><li>操作成功时的Action</li><li>操作失败时的Action</li></ul><p>以服务器取出数据为例，三种Action可以有两种写法：</p><pre><code class="hljs js"><span class="hljs-comment">//写法一：名称相同，参数不同</span>&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;FETCH_POSTS&#x27;</span>&#125;&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;FETCH_POSTS&#x27;</span>,<span class="hljs-attr">status</span>:<span class="hljs-string">&#x27;error&#x27;</span>,<span class="hljs-attr">error</span>:<span class="hljs-string">&#x27;OoPS&#x27;</span>&#125;&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;FETCH_POSTS&#x27;</span>,<span class="hljs-attr">status</span>:<span class="hljs-string">&#x27;success&#x27;</span>,<span class="hljs-attr">response</span>:&#123;...&#125; &#125;<span class="hljs-comment">//写法二：名称不同</span>&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;FETCH_POSTS_REQUEST&#x27;</span>&#125;&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;FETCH_POSTS_FAILURE&#x27;</span>,<span class="hljs-attr">error</span>:<span class="hljs-string">&#x27;Oops&#x27;</span>&#125;&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;FETCH_POSTS_SUCCESS&#x27;</span>,<span class="hljs-attr">response</span>:&#123;...&#125;&#125;</code></pre><p>除了Action种类不同，异步操作的State也要进行改造，反映不同的操作状态。<br>例子：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> state=&#123;    <span class="hljs-comment">//...</span>    isFetching:<span class="hljs-literal">true</span>, <span class="hljs-comment">//是否正在抓取数据</span>    didInvalidate:<span class="hljs-literal">true</span>,<span class="hljs-comment">//是否超时</span>    lastUpdated:<span class="hljs-string">&#x27;xxxx&#x27;</span><span class="hljs-comment">//上一次更新时间</span>&#125;</code></pre><p>现在，整个异步操作的思路就比较清晰了</p><ul><li>1.操作开始时，发送一个Action,触发State 更新为“正在操作”状态，View重新渲染</li><li>2.操作结束后，再送出一个Action,触发State 更新为“操作结束”状态，View再次重新渲染。</li></ul><h3 id="四、redux-thunk中间件"><a href="#四、redux-thunk中间件" class="headerlink" title="四、redux-thunk中间件"></a>四、redux-thunk中间件</h3><p>异步操作至少要发两个Action：用户触发第一个Action,这个跟同步操作一样没有问题，但是，如何才能再操作结束时，系统自动送出第二个Action呢？</p><p>这个奥妙在于Action Creator之中。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;    <span class="hljs-comment">//加载成功后，</span>    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">const</span> &#123;dispatch,selectedPost&#125;=<span class="hljs-built_in">this</span>.props;        <span class="hljs-comment">//发送一个Action,向服务器要数据</span>        <span class="hljs-comment">//这里的fetchPosts()函数就是Action Creator</span>        dispatch(fetchPosts(selectedPost));    &#125;&#125;</code></pre><p>下面就是fetchPosts的代码</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> fetchPosts = <span class="hljs-function"><span class="hljs-params">postTitle</span> =&gt;</span><span class="hljs-function">(<span class="hljs-params">dispatch,getState</span>)=&gt;</span>&#123;    <span class="hljs-comment">//1.先发出一个Action</span>    dispatch(requestPosts(postTitle));    <span class="hljs-comment">//2.进行异步操作</span>    <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">&#x27;/some/API/$&#123;postTitle&#125;.json&#x27;</span>)        <span class="hljs-comment">//3.拿到结果，将结果转换为JSON格式</span>        .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())        <span class="hljs-comment">//4.再发出一个Action</span>        .then(<span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> dispatch(receivePosts(postTitle,json)))&#125;</code></pre><p>🐖：</p><ul><li>fetchPosts 返回了一个函数，而普通的Action Creator返回一个Action对象</li><li>fetchPosts 返回的函数入参时dispatch和getState这两个redux方法，普通的Action Creator的参数是Action的内容。</li><li>在返回的函数中，先发出一个Action（requestPosts(postTitle)），表示操作开始</li><li>异步操作结束之后，又发出一个Action（receivePosts(postTitle,json)），表示操作结束。</li></ul><p>这样的处理，解决了异步操作中需要自动发出第二个Action的问题，但是，Action是由store.dispatch方法发出的，而这个方法正常情况下，入参只能是对象而不能是函数。<br>====&gt; 这时，就需要中间件redux-think</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>;<span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducers&#x27;</span>;<span class="hljs-comment">// Note: this API requires redux@&gt;=3.1.0</span><span class="hljs-keyword">const</span> store = createStore(  reducer,  applyMiddleware(thunk));</code></pre><p>上面代码使用redux-thunk,改造store.dispatch,使得后者可以接受函数作为参数。</p><p>因此，异步操作的第一个解决方案：写一个返回函数的Action Creator,然后使用redux-thunk 中间件改造store.dispatch.</p><h3 id="五、redux-promise中间件"><a href="#五、redux-promise中间件" class="headerlink" title="五、redux-promise中间件"></a>五、redux-promise中间件</h3><p>&emsp;既然Action Creator 可以返回函数，当然也可返回其他值。所以另一种异步操作的解决方案就是，让Action Creator返回一个Promise对象.</p><p>&emsp;这就需要使用redux-promise中间件。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createStore,applyMiddleware&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">import</span> promiseMiddleware <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-promise&#x27;</span>;<span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducers&#x27;</span>;<span class="hljs-comment">//这时Action Creator有两种写法，</span><span class="hljs-comment">//1.返回值是一个对象</span><span class="hljs-keyword">const</span> fetchPosts=<span class="hljs-function">(<span class="hljs-params">dispatch,postTitle</span>)=&gt;</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;    dispatch(requestPosts(postTitle));    <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">&#x27;/some/API/$&#123;postTitle&#125;.json)</span><span class="hljs-string">        .then(response=&gt;&#123;</span><span class="hljs-string">            type:&#x27;</span>FETCH_POSTS<span class="hljs-string">&#x27;,</span><span class="hljs-string">            payload:response.json()</span><span class="hljs-string">        &#125;)</span><span class="hljs-string">&#125;)</span><span class="hljs-string"></span><span class="hljs-string">//2.Action对象的payload属性是一个Promise对象，</span><span class="hljs-string">// 这时需要从redux-actions模块引入createAction方法</span></code></pre><p>参考文章：<a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html">阮一峰redux教程</a></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>010-状态管理库Redux</title>
    <link href="/2020/11/16/010-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93Redux/"/>
    <url>/2020/11/16/010-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93Redux/</url>
    
    <content type="html"><![CDATA[<h3 id="一、React为何需要状态管理库"><a href="#一、React为何需要状态管理库" class="headerlink" title="一、React为何需要状态管理库"></a>一、React为何需要状态管理库</h3><p><img src="https://i.bmp.ovh/imgs/2020/11/26a4726bd6216f11.png"></p><p><img src="https://i.bmp.ovh/imgs/2020/11/8ed5fe88ed497e9c.png"><br>组件之间通信非常麻烦，有了redux把状态单独拧出来，组件通信就变得简单了。</p><p>Redux的特性：</p><ul><li><strong>1、Single Source of Truth</strong></li></ul><p>&emsp;传统的MVC架构：一个view可能对应多个model,一个model也可能对应多个view,关系错综复杂，这样一旦出现错误很难追踪。<br><img src="https://i.bmp.ovh/imgs/2020/11/5a9cb384b94cc272.png"></p><p>&emsp;Redux的结构：只有一个Store,出现错误容易追踪。</p><p><img src="https://i.bmp.ovh/imgs/2020/11/fbb96f01a9c20437.png"></p><ul><li><p><strong>2、可预测性</strong> （不可变性immutable）</p><p><img src="https://i.bmp.ovh/imgs/2020/11/4753506caf528c03.png"></p></li><li><p><strong>3、纯函数更新State</strong></p></li></ul><p>&emsp;&emsp;redux没有副作用.<br><img src="https://i.bmp.ovh/imgs/2020/11/17c05a6f634a7eaf.png"></p><h3 id="二、理解Redux的核心概念：Store-Action-Reducer"><a href="#二、理解Redux的核心概念：Store-Action-Reducer" class="headerlink" title="二、理解Redux的核心概念：Store, Action,Reducer"></a>二、理解Redux的核心概念：Store, Action,Reducer</h3><p><strong>1.理解Store:</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/bc6be7d1bc1deaf2.png"></p><p>Store就是保存数据的地方，可以把它看作是一个容器。整个应用只能有一个Store。<br>Redux提供<strong>createStore</strong>这个函数，用来生成Store。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-comment">//createStore接受一个函数，返回新生成的store对象。</span><span class="hljs-keyword">const</span> store = createStore(fn);</code></pre><p><strong>==State:==</strong> &emsp;Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照。这种时点的数据集合，就叫做State。<br>当前时刻的State,可以通过 store.getState() 拿到。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">const</span> store = createStore(fn);<span class="hljs-keyword">const</span> state = store.getState();</code></pre><p>redux规定，<strong>一个state对应一个view</strong>。只要state相同，view就相同。知道了State,就知道了View是什么样，反之亦然。</p><p><strong>2.理解Action:</strong></p><p>&emsp;State的变化，会导致view的变化。但是，用户接触不到State,只能接触到view。所以，State的变化必须是view导致的。Action就是view发出的通知，标识State应该要变化了。</p><p>&emsp;Action是一个对象，其中的type属性是必须的，标识Action的名称。其他属性可以自由设置。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> action = &#123;  type:<span class="hljs-string">&#x27;ADD_TODO&#x27;</span>,  payload:<span class="hljs-string">&#x27;learn redux&#x27;</span>&#125;</code></pre><p>上述代码中，Action的名称是ADD_TODO，它携带的信息是字符串 learn redux.</p><p>可以这么理解，Action描述当前发生的事情。改变State的唯一方法，就是使用Action。它会运送数据给Store。</p><p><strong>Action Creator:</strong><br>View要发生多少种消息，就会有多少种Action.如果都手写，会很麻烦。所以，可以定义一个函数用来生成Action,这个函数就叫 Action Creator</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> ADD_TODO = <span class="hljs-string">&#x27;添加TODO&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTodo</span>(<span class="hljs-params">text</span>)</span>&#123;  <span class="hljs-keyword">return</span> &#123;    type:ADD_TODO,    text  &#125;&#125;<span class="hljs-keyword">const</span> action=addTodo(<span class="hljs-string">&#x27;learn redux&#x27;</span>)<span class="hljs-string">``</span><span class="hljs-string">` </span><span class="hljs-string">上面代码中，addTodo函数就是一个Action Creator</span><span class="hljs-string"></span><span class="hljs-string">**store.dispatch():**</span><span class="hljs-string">store.dispatch()是View发出Action的唯一方法。</span><span class="hljs-string">`</span><span class="hljs-string">``</span>js<span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">const</span> store = createStore(fn);store.dispatch(&#123;  type:<span class="hljs-string">&#x27;ADD_TODO&#x27;</span>,  payload:<span class="hljs-string">&#x27;learn redux&#x27;</span>&#125;)</code></pre><p>结合 Action Crreator,这段代码可以改写如下：</p><pre><code class="hljs js">store.dispatch(addTodo(<span class="hljs-string">&#x27;learn redux&#x27;</span>));</code></pre><p><strong>3.理解Reducer：</strong></p><p>Store在收到Action之后，必须给出一个新的State,这样View才会发生变化。这种State的计算过程，就叫做 Reducer。</p><p>Reducer是一个函数，它接受Action和当前的State,返回一个新的State。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> reducer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">state,action</span>)</span>&#123;  <span class="hljs-comment">//...</span>  <span class="hljs-keyword">return</span> new_state;&#125;</code></pre><p>整个应用的初始状态，可以作为State的默认值，下面就是一个实际的例子。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> defaultState=<span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> reducer = <span class="hljs-function">(<span class="hljs-params">state=defaultState,action</span>)=&gt;</span>&#123;  <span class="hljs-function"><span class="hljs-title">switch</span>(<span class="hljs-params">action.type</span>)</span>&#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD&#x27;</span>:      <span class="hljs-keyword">return</span> state + action.payload;    <span class="hljs-keyword">default</span>:      <span class="hljs-keyword">return</span> state;  &#125;&#125;;<span class="hljs-keyword">const</span> state=reducer(<span class="hljs-number">1</span>,&#123;  type:<span class="hljs-string">&#x27;ADD&#x27;</span>,  payload:<span class="hljs-number">2</span>&#125;)</code></pre><p>上面代码中，reducer函数接收到一个名为ADD的action以后，就返回一个新的State。<br>实际应用中，Reducer不需要像上面这样手动调用，store.dispatch方法会触发reducer的自动执行。为此，Store需要知道reducer函数，做法就是在生成Store的时候，就将reducer传入给createStore方法。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">const</span> store = createStore(reducer);<span class="hljs-comment">//以后每当store.dispatch发送过来一个新的Action,</span><span class="hljs-comment">//就会自动调用Reducer，得到新的State</span></code></pre><p>🐖为什么这个函数被叫做Reducer呢？<br>✨因为它可以作为数组的reduce方法的参数，下面是一个例子，一系列的Action对象按照顺序作为一个数组。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> actions = [  &#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;ADD&#x27;</span>,<span class="hljs-attr">payload</span>:<span class="hljs-number">0</span>&#125;,  &#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;ADD&#x27;</span>,<span class="hljs-attr">payload</span>:<span class="hljs-number">1</span>&#125;,  &#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;ADD&#x27;</span>,<span class="hljs-attr">payload</span>:<span class="hljs-number">2</span>&#125;];<span class="hljs-keyword">const</span> total = actions.reduce(reducer,<span class="hljs-number">0</span>)<span class="hljs-comment">//3</span></code></pre><p>上面代码中，数组actions表示依次有三个 Action，分别是加0、加1和加2。数组的reduce方法接受 Reducer 函数作为参数，就可以直接得到最终的状态3。 </p><p><img src="https://i.bmp.ovh/imgs/2020/11/43ed9499a953d590.png"></p><p><strong>Reducer函数最重要的特征是:它是一个纯函数。</strong><br>==纯函数==： 纯函数是函数式编程的概念，必须遵守以下一些约束。</p><ul><li>不得改写参数</li><li>不能调用系统 I/O的API</li><li>不能调用Date.now()或者Math.random等不纯的方法，因为每次都会得到不一样的结果。</li></ul><p>由于Reducer是纯函数，就可以保证同样的State必定得到同样的View。但也正因为这一点，Reducer函数里面不能改变State，必须返回一个全新的对象。所以，一般常采用 拓展运算符…和Object.assign()对state进行更新。(最好把State对象设为只读)</p><pre><code class="hljs js"><span class="hljs-comment">//1.state是一个对象</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state,action</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign(&#123;&#125;,state,&#123;thingTochange&#125;);  <span class="hljs-comment">//或者</span>  <span class="hljs-keyword">return</span> &#123;...state,...newState&#125;;&#125;<span class="hljs-comment">//2.state是一个数组</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state,action</span>)</span>&#123;  <span class="hljs-keyword">return</span> [...state,newItem]&#125;</code></pre><p>下图综合理解这三个概念，可以看出redux的单向数据流动。<br><img src="https://i.bmp.ovh/imgs/2020/11/9fceb4adcb97b639.png"></p><h3 id="三、redux的几个工具函数"><a href="#三、redux的几个工具函数" class="headerlink" title="三、redux的几个工具函数"></a>三、redux的几个工具函数</h3><p><strong>1.combineReducers:</strong></p><p>将多个reducer结合起来形成新的reducer。</p><p><img src="https://pic.downk.cc/item/5fb1ddf2b18d627113a841a0.jpg"></p><p><strong>2.bindActionCreators:</strong></p><p><img src="https://pic.downk.cc/item/5fb1de1eb18d627113a848fb.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1de6fb18d627113a8563c.jpg"></p><h3 id="四、在React中使用Redux"><a href="#四、在React中使用Redux" class="headerlink" title="四、在React中使用Redux"></a>四、在React中使用Redux</h3><p>redux提供了一个<strong>react-redux</strong>的package，用connect把一个已有的组件连接到store上。</p><p><img src="https://pic.downk.cc/item/5fb1e29cb18d627113a9146f.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1e356b18d627113a93618.jpg"></p><h3 id="五、理解Redux的异步action以及中间件"><a href="#五、理解Redux的异步action以及中间件" class="headerlink" title="五、理解Redux的异步action以及中间件"></a>五、理解Redux的异步action以及中间件</h3><p>中间件截获后去访问一个API，根据访问的结果再dispatch.</p><p><img src="https://pic.downk.cc/item/5fb1eab2b18d627113aabab1.jpg"></p><p>异步的action并不是一个新的action类型, 而是几个同步action的组合使用.</p><p><img src="https://pic.downk.cc/item/5fb1eb4eb18d627113aae915.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1ecf0b18d627113ab5f8a.jpg"></p><h3 id="六、如何在redux中组织Action和Reducer"><a href="#六、如何在redux中组织Action和Reducer" class="headerlink" title="六、如何在redux中组织Action和Reducer"></a>六、如何在redux中组织Action和Reducer</h3><p><img src="https://pic.downk.cc/item/5fb1ede4b18d627113ab90f7.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1ee82b18d627113abad69.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1eec1b18d627113abb8da.jpg"></p><h3 id="七、-Redux的运行基础-不可变数据-immutability"><a href="#七、-Redux的运行基础-不可变数据-immutability" class="headerlink" title="七、 Redux的运行基础:不可变数据(immutability)"></a>七、 Redux的运行基础:不可变数据(immutability)</h3><p><img src="https://pic.downk.cc/item/5fb1efbcb18d627113abe8a3.jpg"></p><h5 id="1-为什么需要不可变数据"><a href="#1-为什么需要不可变数据" class="headerlink" title="1.为什么需要不可变数据?"></a>1.为什么需要不可变数据?</h5><ul><li><p><strong>1.性能优化:</strong><br> &emsp;store变化时会通知组件更新==&gt; store的变化都是由action触发==&gt;action触发在旧的state上形成新的state。不需要比较新旧state值是否变了,只需要判断<strong>前后状态的引用</strong>有没有变化</p></li><li><p><strong>2.易于调试和跟踪:</strong><br>任何时候，store变化时可以记录之前和之后的状态值。</p></li><li><p><strong>3.易于推测:</strong><br>任何时候，都可以找到是什么引起store的变化</p><h5 id="2-如何操作不可变数据"><a href="#2-如何操作不可变数据" class="headerlink" title="2.如何操作不可变数据?"></a>2.如何操作不可变数据?</h5></li></ul><p>==三种方式:==<br><img src="https://pic.downk.cc/item/5fb1f0f2b18d627113ac3540.jpg"></p><p>简单场景：使用原生写法就可以了。</p><p><img src="https://pic.downk.cc/item/5fb1f37cb18d627113acb0d5.jpg"></p><p>复杂场景：需要借助一些类库。</p><p><img src="https://pic.downk.cc/item/5fb1f414b18d627113accfd2.jpg"></p><p>immer: 性能差一点，适用应用程序小，场景简单的情况。<br><img src="https://pic.downk.cc/item/5fb1f44fb18d627113acdf4d.jpg"></p><h3 id="八、梳理Redux的工作流程"><a href="#八、梳理Redux的工作流程" class="headerlink" title="八、梳理Redux的工作流程"></a>八、梳理Redux的工作流程</h3><p><img src="https://pic.downk.cc/item/5fb26119b18d627113c52bcf.jpg"></p><p>1.首先，用户发出Action。</p><pre><code class="hljs js">store.dispatch(action)</code></pre><p>2.然后，Store自动调用Reducer,并且传入两个参数：当前State和收到的Action。Reducer会返回新的State</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> nextState = todoApp(previousState,action);</code></pre><p>State一旦有变化，Store就会调用监听函数</p><pre><code class="hljs js"><span class="hljs-comment">//设置监听函数</span>store.subscribe(listener);</code></pre><p>listener可以通过store.getState()得到当前状态，如果使用的是React,这时可以触发重新渲染View。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listener</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">let</span> newState = store.getState();  component.setState(newState);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09-打包和部署</title>
    <link href="/2020/11/12/09-%E6%89%93%E5%8C%85%E5%92%8C%E9%83%A8%E7%BD%B2/"/>
    <url>/2020/11/12/09-%E6%89%93%E5%8C%85%E5%92%8C%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h4 id="一-为什么需要打包"><a href="#一-为什么需要打包" class="headerlink" title="一.为什么需要打包?"></a>一.为什么需要打包?</h4><ul><li>1.编译ES6语法特性，编译JSX</li><li>2.整合资源，例如图片svg,Less/Sass</li><li>3.优化代码体积</li></ul><p><img src="https://i.bmp.ovh/imgs/2020/11/ef5409f73d9ca563.png"></p><h4 id="二-打包注意事项"><a href="#二-打包注意事项" class="headerlink" title="二.打包注意事项:"></a>二.打包注意事项:</h4><p>1.设置node.js环境为production<br>2.禁止开发时专用代码，比如logger<br>3.设置应用根路径</p><p>npm run build 执行的就是打包过程。</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-使用脚手架工具创建React项目</title>
    <link href="/2020/11/12/08-%E4%BD%BF%E7%94%A8%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E5%88%9B%E5%BB%BAReact%E9%A1%B9%E7%9B%AE/"/>
    <url>/2020/11/12/08-%E4%BD%BF%E7%94%A8%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E5%88%9B%E5%BB%BAReact%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="1-为什么需要脚手架？"><a href="#1-为什么需要脚手架？" class="headerlink" title="1.为什么需要脚手架？"></a>1.为什么需要脚手架？</h3><p><img src="https://i.bmp.ovh/imgs/2020/11/1df974a0ce1a7435.png"><br>项目越来越复杂，需要用：</p><ul><li><p>react: 做UI，</p></li><li><p>redux: 做状态管理，</p></li><li><p>react-router: 做路由管理</p></li><li><p>babel: 把js新特性翻译为浏览器可以识别的旧语法</p></li><li><p>webpack: 打包</p></li><li><p>eslint: 用于语法检查<br>…<br><img src="https://i.bmp.ovh/imgs/2020/11/611411d14c00f1a4.png"></p><p>&emsp;这些工具背后需要很多的package,我们需要了解每一个package的配置和使用，这使得创建项目非常繁琐。而创建一个项目的过程大致是差不多的，完全可以抽象出来做成一个工具<br>&emsp;===&gt;所以，脚手架应运而生。</p></li></ul><h3 id="2-常见的用于创建React应用的脚手架工具："><a href="#2-常见的用于创建React应用的脚手架工具：" class="headerlink" title="2.常见的用于创建React应用的脚手架工具："></a>2.常见的用于创建React应用的脚手架工具：</h3><ul><li><p><strong>Create React APP</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/6a1c377349d0f209.png"><br>&emsp; facebook 官方推出的，使用了最简策略，用于学习或创建简单的react项目</p></li><li><p><strong>Rekit</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/57aaa6b41498f44a.png"></p><p>&emsp;基于create-react-app,提供了更多的功能，可以开发大型的项目。</p></li><li><p><strong>Codesandbox</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/c18cd49b5e89621e.png"><br>&emsp; Online,在线的创建项目，webpack运行在浏览器端,大大提高打包速度。支持react,vue,angular</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-理解新的ContextAPI及其使用场景</title>
    <link href="/2020/11/11/07-%E7%90%86%E8%A7%A3%E6%96%B0%E7%9A%84ContextAPI%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2020/11/11/07-%E7%90%86%E8%A7%A3%E6%96%B0%E7%9A%84ContextAPI%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>Context解决的是：组件之间的通信问题</strong></p><p>Context提供了一个无需为每层组件手动添加props,就能在组件树间进行数据传递的方法。</p><p><img src="https://i.bmp.ovh/imgs/2020/11/c51c0b02a804b0fb.png"></p><h4 id="1-设计目的"><a href="#1-设计目的" class="headerlink" title="1.设计目的"></a>1.设计目的</h4><p>&emsp;Context设计的目的：为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或者首选语言。<br>&emsp;在一个典型的React应用中，数据是通过props属性自上而下（由父亲到儿子）进行传递的，但是这种做法对于某些属性是及其繁琐的（比如上文说的UI主题，），这些属性是应用程序中许多组件都需要的。</p><p><strong>==&gt;</strong> 所以，Context被设计出来，提供了一种在组件间共享“全局”数据的方式，从而不必显示地通过组件树逐层地传递props.</p><h4 id="2-使用Context前的考虑"><a href="#2-使用Context前的考虑" class="headerlink" title="2.使用Context前的考虑"></a>2.使用Context前的考虑</h4><p><strong>Context主要应用场景</strong>：很多不同层级之间的组件需要访问同样的一些数据。(但是需要谨慎使用，因为这会让组件的复用性变差。)<br>如果只是想避免层层传递一些属性，<a href="https://zh-hans.reactjs.org/docs/composition-vs-inheritance.html">组件组合（component composition）</a>有时是一个比Context更好的解决方案。</p><h4 id="3-相关的API"><a href="#3-相关的API" class="headerlink" title="3.相关的API"></a>3.相关的API</h4><p> <strong><em>(1) React.createContext</em></strong><br>  <pre><code class="hljs js"><span class="hljs-keyword">const</span> MyContext = React.createContext(defaultValue);</code></pre></p><ul><li>createContext函数创建一个Context对象，当React渲染一个订阅了这个Context对象的组件时，这个组件会从组件树中离自身最近的匹配到的Provider中读取当前的context值。<br>…</li><li><em>defaultValue</em>: 只有当组件所处的组件树中没有匹配到Provider时，其defaultValue参数才起作用。即使Provider中的value值是”undefined”，消费组件的defaultValue也不会生效。<br>（defaultValue有助于在不使用Provider包装组件的情况下，对组件进行测试）</li></ul><p><strong><em>(2)Context.Provider</em></strong></p><pre><code class="hljs js">&lt;MyContext.Provider value=&#123;<span class="hljs-comment">/*某个值*/</span>&#125;&gt;</code></pre><ul><li><p>每个Context对象都会返回一个Provider React组件，它允许消费组件订阅context的变化。</p></li><li><p>一个Provider可以和多个消费组件有对应关系。多个Provider也可以嵌套使用，里面的会覆盖外层的数据。</p></li><li><p>Provider有一个value属性，传递给消费组件。当value值发生变化时，Provider内部的所有消费组件都会重新渲染。<br>（Provider及其内部的消费组件都不受制于shouldComponentUpdate函数，所以当消费组件在其祖先组件推出更新的情况下也能更新）</p></li><li><p>通过新旧值检测确定变化，使用了和 Object.is相同的算法。</p></li></ul><p><strong><em>(3) Class.contextType</em></strong></p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">this</span>.context;    <span class="hljs-comment">/* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */</span>  &#125;  <span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">this</span>.context;    <span class="hljs-comment">/* ... */</span>  &#125;  <span class="hljs-function"><span class="hljs-title">componentWillUnmount</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">this</span>.context;    <span class="hljs-comment">/* ... */</span>  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">this</span>.context;    <span class="hljs-comment">/* 基于 MyContext 组件的值进行渲染 */</span>  &#125;&#125;MyClass.contextType = MyContext;</code></pre><ul><li>挂载在class上的contextType属性会被重新赋值为一个由React.createContext()创建的Context对象。所以使用this.context可以消费最近Context上的那个值，我们可以任何生命周期访问到this.context，包括render函数。</li><li>通过class.contextType只能订阅一个context</li></ul><p><strong><em>(4) Context.Consumer</em></strong></p><pre><code class="hljs js">&lt;MyContext.Consumer&gt;    &#123;<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span><span class="hljs-comment">/*基于context值进行渲染*/</span>&#125;&lt;/MyContext.Consumer&gt;</code></pre><ul><li><p>这是一个可以订阅context的变更的React组件，它在函数式组件中可以订阅一个context。</p></li><li><p>这种方法需要一个<a href="https://zh-hans.reactjs.org/docs/render-props.html#using-props-other-than-render">函数作为子元素（function as a child)</a>,这个函数接收当前的context值，并返回一个React节点。</p></li><li><p> 传递给Consumer的value值也就是组件树上方离context最近的Provider提供的value值，如果没有对应的Provider,就用createContext()中的defaultValue.</p></li></ul><p><strong><em>(5) Context.displayName</em></strong></p><p>示例，下述组件在DevTools中将是显示MyDisplayName:</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> MyContext = React.createContext(<span class="hljs-comment">/*some value*/</span>);MyContext.displayName = <span class="hljs-string">&#x27;MyDisplayName&#x27;</span>;&lt;MyContext.Provider&gt; <span class="hljs-comment">// &quot;MyDisplayName.Provider&quot; 在 DevTools 中</span>&lt;MyContext.Consumer&gt; <span class="hljs-comment">// &quot;MyDisplayName.Consumer&quot; 在 DevTools 中</span></code></pre><ul><li>context对象接受一个名为displayName的属性，类型为字符串。React DevTools使用该字符串来确定context要显示的内容。</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-两种组件设计模式</title>
    <link href="/2020/11/11/06-%E4%B8%A4%E7%A7%8D%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/11/11/06-%E4%B8%A4%E7%A7%8D%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="组件复用的另外两种形式："><a href="#组件复用的另外两种形式：" class="headerlink" title="组件复用的另外两种形式："></a>组件复用的另外两种形式：</h4><p>（除了常规的组件复用之外）</p><ul><li><strong>高阶组件</strong></li><li><strong>函数作为子组件</strong></li></ul><h4 id="一-高阶组件"><a href="#一-高阶组件" class="headerlink" title="一.高阶组件"></a>一.高阶组件</h4><p><img src="https://i.bmp.ovh/imgs/2020/11/f50691752374e779.png"></p><p><strong>高阶组件(HOC)</strong> 是React中复用组件逻辑的一种高级技巧，它本身不是React API的一部分，而是基于React的组合特性形成的一种设计模式。高阶组件以组件为参数，并返回一个新组件。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponenent)</code></pre><p>==区分:== &emsp;组件是将props转换为UI，高阶组件是将组件转换为另一个组件。</p><p>具体参见：<a href="https://zh-hans.reactjs.org/docs/higher-order-components.html">React官方文档–高阶组件</a></p><h4 id="二-函数作为子组件"><a href="#二-函数作为子组件" class="headerlink" title="二.函数作为子组件"></a>二.函数作为子组件</h4><p><img src="https://i.bmp.ovh/imgs/2020/11/17246cbcf6e05f4d.png"></p><p><strong>总结：</strong></p><p>1、高阶组件和函数作为子组件都是设计模式（并不是新的组件类型）</p><p>2、可以实现更多场景的组件复用</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-理解VirtualDOM及key属性的作用</title>
    <link href="/2020/11/11/05-%E7%90%86%E8%A7%A3VirtualDOM%E5%8F%8Akey%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2020/11/11/05-%E7%90%86%E8%A7%A3VirtualDOM%E5%8F%8Akey%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>JSX的基础：虚拟DOM</p><p><img src="https://i.bmp.ovh/imgs/2020/11/6244a9607b4da0d0.png"></p><p><img src="https://i.bmp.ovh/imgs/2020/11/314414dd61ae46e0.png"></p><p>从根节点开始比较，针对不同情况，diff算法有不同的处理方式：</p><p><strong>1. 属性变化及顺序：</strong><br>   <img src="https://i.bmp.ovh/imgs/2020/11/231a0e379e4ef3a4.png"></p><p>==处理方式==：根据key属性，交换A与B的位置</p><p><strong>2. 节点类型发生变化：</strong><br>   <img src="https://i.bmp.ovh/imgs/2020/11/c65c14d031817b7e.png"></p><p>==处理方式==：暴力删除F节点（不管他是否在其他地方用到），创建一个新的G节点，append到A节点上。</p><p><strong>3. 节点跨层级移动：</strong><br>    <img src="https://i.bmp.ovh/imgs/2020/11/06f09ef16c9da001.png"></p><p>==处理方式==：diff算法直接删除左边B下面的D节点（以及其子树），到了右边，React直接创建一个新的D节点。</p><h4 id="虚拟DOM的两个假设："><a href="#虚拟DOM的两个假设：" class="headerlink" title="虚拟DOM的两个假设："></a>虚拟DOM的两个假设：</h4><p><strong>1、组件的DOM结构是相对稳定的（一般很少出现跨层级移动的情况）</strong></p><p>&emsp;&emsp;跨层级的节点移动，react的diff算法是直接删除。</p><p><strong>2、类型相同的兄弟节点可以被唯一标识（key属性）。</strong></p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>算法复杂度为O(n)</li><li>虚拟DOM如何计算diff</li><li>key属性的作用</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-react的生命周期</title>
    <link href="/2020/11/10/04-react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2020/11/10/04-react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="React的生命周期图"><a href="#React的生命周期图" class="headerlink" title="React的生命周期图"></a>React的生命周期图</h3><p><img src="https://i.bmp.ovh/imgs/2020/11/32b8163f9eadfd47.png"></p><p>🐖：mounting到底意味着什么？<br>答： When we talk about mounting， we’re talking about the process of converting the virtual components into actual DOM elements that are placed in the DOM by React.（其实就是React将虚拟DOM转化为真实DOM的过程)</p><p><strong>1.constructor:</strong></p><ul><li>用于初始化内部状态，很少使用</li><li>唯一可以直接修改state的地方</li></ul><p><strong>2.getDerivedStateFromProps:</strong></p><ul><li>当state需要从props初始化时使用。</li><li>尽量不要使用：维护两者状态一致性会增加复杂度。</li><li>每次render都会调用。</li><li>典型场景：表单控件获取默认值。</li></ul><p><strong>3.componentDidMount:</strong></p><ul><li>UI渲染完成后调用</li><li>只执行一次</li><li>典型场景：获取外部资源</li></ul><p><strong>4.componeWillUnmout:</strong></p><ul><li>组件移除时被调用</li><li>典型场景：资源释放</li></ul><p><strong>5.getSnapshotBeforeUpdate:</strong></p><ul><li>在页面render之前调用，state已经更新</li><li>典型场景：获取render之前的DOM状态</li></ul><p><strong>6.componentDidUpdate:</strong></p><ul><li>每次UI更新时被调用</li><li>典型场景：页面需要根据props变化重新获取数据</li></ul><p><strong>7.shouldComponentUpdate:</strong></p><ul><li>决定Vitual DOM是否重绘</li><li>一般由PureComponent自动实现</li><li>典型场景：性能优化</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-JSX的本质是语法糖</title>
    <link href="/2020/11/10/03-JSX%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <url>/2020/11/10/03-JSX%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    
    <content type="html"><![CDATA[<p>###理解JSX</p><p><em>JSX：在javaScript代码中直接写HTML标记。</em></p><pre><code class="hljs js"><span class="hljs-keyword">const</span> name=<span class="hljs-string">&#x27;jane&#x27;</span><span class="hljs-keyword">const</span> element=<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello,&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></code></pre><p><strong>1.JSX的本质</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/5e744edbbade47d2.png"></p><p><strong>2.在JSX中使用表达式</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/87d92de0fdbd6f36.png"></p><p><strong>3.JSX的优点</strong></p><ul><li>声明创建界面的直观</li><li>代码动态创建界面的灵活</li><li>无需学习新的模板语言</li></ul><p><strong>约定：自定义组件首字母大写</strong><br>1.react认为小写的tag是原生DOM节点，如div<br>2.大写字母开头的组件是自定义节点<br>3.JSX标记可以直接使用属性语法，如&lt;menu.Item /&gt;</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-react以组件方式考虑UI的构建</title>
    <link href="/2020/11/10/02-react%E4%BB%A5%E7%BB%84%E4%BB%B6%E6%96%B9%E5%BC%8F%E8%80%83%E8%99%91UI%E7%9A%84%E6%9E%84%E5%BB%BA/"/>
    <url>/2020/11/10/02-react%E4%BB%A5%E7%BB%84%E4%BB%B6%E6%96%B9%E5%BC%8F%E8%80%83%E8%99%91UI%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.bmp.ovh/imgs/2020/11/b28d10e0a2054aec.png"></p><p><strong>一、构建一个组件需要考虑的三件事情：</strong></p><p>1、组件的UI( 一些外在的表现形式 )<br>2、组件的状态管理（放在哪？）<br>3、组件的交互</p><p><img src="https://i.bmp.ovh/imgs/2020/11/f878479d2f41ffb4.png"></p><p><strong>二、何时创建组件：单一职责原则</strong></p><p>1、一个组件只负责一个功能<br>2、复杂的组件应该进行拆分</p><p><strong>三、数据状态管理原则：DRY原则</strong></p><p>1.能计算得到的状态不应该单独存储<br>2.组件尽量无状态，尽量通过props获取.</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-React的历史背景及特点</title>
    <link href="/2020/11/10/01-React%E7%9A%84%E5%8E%86%E5%8F%B2%E8%83%8C%E6%99%AF/"/>
    <url>/2020/11/10/01-React%E7%9A%84%E5%8E%86%E5%8F%B2%E8%83%8C%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="1-React-出现的历史背景"><a href="#1-React-出现的历史背景" class="headerlink" title="1. React 出现的历史背景"></a>1. React 出现的历史背景</h3><h4 id="A-UI方面的——"><a href="#A-UI方面的——" class="headerlink" title="A.UI方面的——"></a>A.UI方面的——</h4><p>传统WebUI存在的问题：</p><ul><li>传统UI关注太多的细节</li><li>应用程序的状态分散在各处，难以追踪和维护</li></ul><p><strong>=&gt;</strong> <strong>React的解决方案</strong>：react 始终整体”刷新”页面，无需关心细节。它只判断前后两个状态是否变化，并不关注背后的哪个细节发生了变化。<br><img src="https://i.bmp.ovh/imgs/2020/11/981310a92f37e99e.png"></p><h4 id="B-数据方面的——"><a href="#B-数据方面的——" class="headerlink" title="B.数据方面的——"></a>B.数据方面的——</h4><p>传统的MVC难以扩展和维护，太多的model和view，关系错综复杂且双向绑定，当出现了问题，很难追踪是model还是view层出现了问题。<br><img src="https://i.bmp.ovh/imgs/2020/11/0520d5fd55b9ac16.png"> </p><p><strong>=&gt;</strong> <strong>React的解决方案</strong>，提出了单向数据流架构flux.(后面衍生出redux和mobx)<br><img src="https://i.bmp.ovh/imgs/2020/11/1d93a50d7d4e112b.png"></p><h3 id="2-React-的特点："><a href="#2-React-的特点：" class="headerlink" title="2. React 的特点："></a>2. React 的特点：</h3><p>1个新概念<br>4个必须的API<br>单向数据流<br>完善的错误提示</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>my-first-blog</title>
    <link href="/2020/11/09/%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/"/>
    <url>/2020/11/09/%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="前端学习路线及资源"><a href="#前端学习路线及资源" class="headerlink" title=" 前端学习路线及资源"></a><center> 前端学习路线及资源</h2><p align='right'>——————左耳听风<p>&nbsp;&emsp;对于前端的学习和提高，我的基本思路是这样的。首先，前端的三个最基本的东西 HTML 5、CSS 3 和 JavaScript（ES6）是必须要学好的。这其中有很多很多的技术，比如，CSS 3 引申出来的 Canvas（位图）、SVG（矢量图） 和 WebGL（3D 图），以及 CSS 的各种图形变换可以让你做出非常丰富的渲染效果和动画效果。<br>&nbsp;&emsp; ES6 简直就是把 JavaScript 带到了一个新的台阶，JavaScript 语言的强大，大大释放了前端开发人员的生产力，让前端得以开发更为复杂的代码和程序，于是像 React 和 Vue 这样的框架开始成为前端编程的不二之选。<br>&nbsp;&nbsp; 我一直认为学习任何知识都要从基础出发，所以这篇文章我会着重介绍基础知识和基本原理，尤其是如下的这些知识，都是前端程序员需要花力气啃下来的硬骨头。JavaScript 的核心原理。这里我会给出好些网上很不错的讲 JavaScript </p><ul><li><p><strong>JavaScript 的核心原理</strong>。这里我会给出好些网上很不错的讲 JavaScript 的原理的文章或图书，你一定要学好语言的特性，并且详细了解其中的各种坑。</p></li><li><p><strong>浏览器的工作原理</strong>。这也是一块硬骨头，我觉得这是前端程序员需要了解和明白的关键知识点，不然，你将无法深入下去。</p></li><li><p><strong>网络协议 HTTP</strong>。也是要着重了解的，尤其是 HTTP/2，还有 HTTP 的几种请求方式：短连接、长连接、Stream 连接、WebSocket 连接。</p></li><li><p><strong>前端性能调优</strong>。有了以上的这些基础后，你就可以进入前端性能调优的主题了，我相信你可以很容易上手各种性能调优技术的。</p></li><li><p><strong>框架学习</strong>。我只给了 React 和 Vue 两个框架。就这两个框架来说，Virtual DOM 技术是其底层技术，组件化是其思想，管理组件的状态是其重点。而对于 React 来说，函数式编程又是其编程思想，所以，这些基础技术都是你需要好好研究和学习的。</p></li><li><p><strong>UI 设计</strong>。设计也是前端需要做的一个事，比如像 Google 的 Material UI，或是比较流行的 Atomic Design 等应该是前端工程师需要学习的。</p><p>&nbsp;而对于工具类的东西，这里我基本没怎么涉及，因为本文主要还是从原理和基础入手。那些工具我觉得都很简单，就像学习 Java 我没有让你去学习 Maven 一样，因为只要你去动手了，这种知识你自然就会获得，我们还是把精力重点放在更重要的地方。  </p><p>下面我们从前端基础和底层原理开始讲起。先来讲讲 HTML5 相关的内容。</p><h3 id="HTML-5"><a href="#HTML-5" class="headerlink" title="HTML 5"></a>HTML 5</h3><p>HTML 5 主要有以下几本书推荐。</p><ul><li><a href="https://book.douban.com/subject/25786074/">HTML 5 权威指南</a>，本书面向初学者和中等水平 Web 开发人员，是牢固掌握 HTML 5、CSS 3 和 JavaScript 的必读之作。书看起来比较厚，是因为里面的代码很多。</li><li><a href="https://book.douban.com/subject/24533314/">HTML 5 Canvas 核心技术 </a>，如果你要做 HTML 5 游戏的话，这本书必读。</li><li>对于 SVG、Canvas 和 WebGL 这三个对应于矢量图、位图和 3D 图的渲染来说，给前端开发带来了重武器，很多 HTML5 小游戏也因此蓬勃发展。所以，你可以学习一下。学习这三个技术，我个人觉得最好的地方是 MDN。</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/SVG">SVG: Scalable Vector Graphics</a></li><li><a href="https://developer.mozilla.org/kab/docs/Web/API/Canvas_API">Canvas API</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">The WebGL API: 2D and 3D graphics for the web</a></li></ul></li></ul><p>  最后是几个资源列表。</p><ul><li><a href="https://github.com/diegocard/awesome-html5">Awesome HTML5</a> 。GitHub 上的 Awesome HTML5，其中有大量的资源和技术文章。</li><li><a href="https://github.com/willianjusten/awesome-svg">Awesome SVG</a></li><li><a href="https://github.com/raphamorim/awesome-canvas">Awesome Canvas</a></li><li><a href="https://github.com/sjfricke/awesome-webgl">Awesome WebGL</a></li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>在《程序员练级攻略》系列文章最开始，我们就推荐过 CSS 的在线学习文档，这里再推荐一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">MDN Web Doc - CSS </a>。我个人觉得只要你仔细读一下文档，CSS 并不难学。绝大多数觉得难的，一方面是文档没读透，另一方面是浏览器支持的标准不一致。所以，学好 CSS 最关键的还是要仔细地读文档。之后，在写 CSS 的时候，你会发现，你的 CSS 中有很多看起来相似的东西。你的 DRY - Don’t Repeat Yourself 洁癖告诉你，这是不对的。所以，你需要学会使用 <a href="http://lesscss.org/">LESS</a> 和 <a href="http://sass-lang.com/">SaSS</a> 这两个 CSS 预处理工具，其可以帮你提高很多效率。然后，你需要学习一下 CSS 的书写规范，前面的《程序员修养》一文中提到过一些，这里再补充几个:</p><ul><li><p><a href="https://github.com/necolas/idiomatic-css">Principles of writing consistent, idiomatic CSS</a></p></li><li><p><a href="https://github.com/grvcoelho/css-styleguide">Opinionated CSS styleguide for scalable applications</a></p></li><li><p><a href="https://google.github.io/styleguide/htmlcssguide.html">Google HTML/CSS Style Guide</a></p><p>&emsp;如果你需要更有效率，那么你还需要使用一些 CSS Framework，其中最著名的就是 Twitter 公司的 Bootstrap，其有很多不错的 UI 组件，页面布局方案，可以让你非常方便也非常快速地开发页面。除此之外，还有，主打清新 UI 的 Semantic UI 、主打响应式界面的 Foundation 和基于 Flexbox 的 Bulma。<br>&emsp;当然，在使用 CSS 之前，你需要把你浏览器中的一些 HTML 标签给标准化掉。所以，推荐几个 Reset 或标准化的 CSS 库：Normalize、MiniRest.css、sanitize.css 和 unstyle.css。关于更多的 CSS 框架，你可以参看<a href="https://github.com/troxler/awesome-css-frameworks">Awesome CSS Frameworks</a> 上的列表。接下来，是几个公司的 CSS 相关实践，供你参考:</p></li><li><p><a href="https://codepen.io/chriscoyier/post/codepens-css"> CodePen’s CSS</a></p></li><li><p><a href="https://markdotto.com/2014/07/23/githubs-css/">Github 的 CSS</a></p></li><li><p>Medium’s CSS is actually pretty f***ing good()</p></li><li><p>CSS at BBC Sport</p></li><li><p><a href="https://blog.trello.com/refining-the-way-we-structure-our-css-at-trello">Refining The Way We Structure Our CSS At Trello</a></p><p>&emsp; 最后是一个可以写出可扩展的 CSS 的阅读列表 <a href="https://github.com/davidtheclark/scalable-css-readin">A Scalable CSS Reading List</a> 。</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>下面是学习 JavaScript 的一些图书和文章。</p></li><li><p><a href="">JavaScript: The Good Parts</a> ，中文翻译版为《JavaScript 语言精粹》。这是一本介绍 JavaScript 语言本质的权威图书，值得任何正在或准备从事 JavaScript 开发的人阅读，并且需要反复阅读。学习、理解、实践大师的思想，我们才可能站在巨人的肩上，才有机会超越大师，这本书就是开始。</p></li><li><p><a href="">Secrets of the JavaScript Ninja</a> ，中文翻译版为《JavaScript 忍者秘籍》，本书是 jQuery 库创始人编写的一本深入剖析 JavaScript 语言的书。适合具备一定 JavaScript 基础知识的读者阅读，</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
