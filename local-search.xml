<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面试03-如何避免生命周期中的坑？</title>
    <link href="/2020/12/07/%E9%9D%A2%E8%AF%9503-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E7%9A%84%E5%9D%91%EF%BC%9F/"/>
    <url>/2020/12/07/%E9%9D%A2%E8%AF%9503-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E7%9A%84%E5%9D%91%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="面试场景3：如何避免生命周期中的坑？（经验题）"><a href="#面试场景3：如何避免生命周期中的坑？（经验题）" class="headerlink" title="面试场景3：如何避免生命周期中的坑？（经验题）"></a>面试场景3：如何避免生命周期中的坑？（经验题）</h4><p>如何避免坑？换种思维也就是”为什么会有坑?”,在代码编写中，遇到的坑通常有两种：</p><ul><li>1.在不恰当的时机调用了不合适的代码</li><li>2.在需要调用时，却忘了调用</li></ul><p>那么针对生命周期的坑，可以通过梳理生命周期，明确周期函数职责，确认什么时候该做什么事，依次来避免坑。因此现在主要思考两个问题：</p><ul><li>1.基于周期类型的梳理，确认生命周期函数的<strong>使用方式</strong></li><li>2.基于职责的梳理，确认生命周期函数的<strong>适用范围</strong></li></ul><p><img src="https://pic.downk.cc/item/5fcdeaf03ffa7d37b3c10890.jpg" alt="生命周期的梳理"></p><h5 id="一、生命周期的概念"><a href="#一、生命周期的概念" class="headerlink" title="一、生命周期的概念"></a>一、生命周期的概念</h5><p>当我们在讨论React组件生命周期的时候，一定是在讨论类组件（Class Component)。函数式组件并没有生命周期的概念，它本身就是一个函数，只会从头执行到尾。</p><p>生命周期其实是一个抽象的概念，提到生命周期我们第一时间想到的是componentDidMount, componenetWillMount等函数。然而这些函数并不等同于组件的生命周期，只是在生命周期中按顺序被调用的函数。<strong>挂载 -&gt; 更新 -&gt;卸载</strong>，这一完整的流程，才是React组件的生命周期。</p><h5 id="二、生命周期流程梳理"><a href="#二、生命周期流程梳理" class="headerlink" title="二、生命周期流程梳理"></a>二、生命周期流程梳理</h5><p><strong>1.挂载阶段</strong><br>&emsp;挂载阶段是指组件从初始化到完成加载的过程。</p><ul><li>✨<strong>constructor函数</strong>：constructor是类通用的构造函数，常用于初始化（通常是初始化state,以及绑定函数）<pre><code class="hljs js"><span class="hljs-comment">//过去的写法</span><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;        <span class="hljs-built_in">super</span>(props);        <span class="hljs-built_in">this</span>.state=&#123;            count:<span class="hljs-number">0</span>        &#125;        <span class="hljs-built_in">this</span>.handleClick=<span class="hljs-built_in">this</span>.handleClick.bind(<span class="hljs-built_in">this</span>);    &#125;    <span class="hljs-function"><span class="hljs-title">handleClick</span>(<span class="hljs-params"></span>)</span>&#123;        ...    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;&#125;<span class="hljs-string">``</span><span class="hljs-string">` </span><span class="hljs-string">当类属性开始流行后，现在React社区的写法发生了变化，去除了constructor。</span><span class="hljs-string"></span><span class="hljs-string">`</span><span class="hljs-string">``</span>js<span class="hljs-comment">//现在的写法</span><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    state=&#123;        count:<span class="hljs-number">0</span>,    &#125;    <span class="hljs-comment">//类属性第三阶段提案，这种不再需要额外绑定</span>    handleClick=<span class="hljs-function">()=&gt;</span>&#123;        ...    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;&#125;</code></pre>React社区去除constructor的原因：</li></ul><ol><li>constructor本身并不属于React的生命周期，它只是Class组件的初始化函数</li><li>constructor中并不推荐去处理初始化以外的逻辑</li><li>通过去除constructor，代码变得更加简洁</li></ol><ul><li>✨<strong>getDerivedStateFromProps函数</strong>： 使组件在props变化时更新state</li></ul><p>它的触发时机是：</p><ol><li>当props被传入时</li><li>state发送变化时</li><li>forceUpdate被调用时</li></ol><p>🐖：一个常见错误是认为只有props发送变化时，getDerivedStateFromProps才会被调用，实际上只要父组件重新渲染时，getDerivedStateFromProps就会被调用，外部参数props传入时就会发生变化。以下是官方文档给出的例子：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-comment">// 在构造函数中初始化 state，</span>  <span class="hljs-comment">// 或者使用属性初始化器。</span>  state = &#123;    isScrollingDown: <span class="hljs-literal">false</span>,    lastRow: <span class="hljs-literal">null</span>,  &#125;;  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getDerivedStateFromProps</span>(<span class="hljs-params">props, state</span>)</span> &#123;    <span class="hljs-keyword">if</span> (props.currentRow !== state.lastRow) &#123;      <span class="hljs-keyword">return</span> &#123;        isScrollingDown: props.currentRow &gt; state.lastRow,        lastRow: props.currentRow,      &#125;;    &#125;    <span class="hljs-comment">// 返回 null 表示无需更新 state。</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  &#125;&#125;</code></pre><p>按照官方的说话，它的使用场景是非常有限的。由于太多使用错误的案例，React团队还因此写了<a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html">你可能不需要使用派生state</a>，文中列举了错误使用getDerivedStateFromProps的两个典型反面案例：</p><ol><li>直接复制prop到state</li><li>在props变化后修改state</li></ol><p>这两种写法除了增加代码的维护成本外，没有带来任何好处。</p><ul><li>✨<strong>UNSAFE_componentWillMount函数</strong>： 也就是componentWillMount，用于组件加载前做某些操作。在React的异步渲染机制下，该方法可能会被多次调用，所以目前被标记为弃用。</li></ul><p>一个常见的错误是componentWillMount跟服务器端同构渲染时，如果在该函数里面发起网络请求，拉取数据，那么会在服务器端和客户端分别执行一次。所以更推荐使用componentDidMount中完成拉取数据的操作。</p><ul><li><p>✨<strong>render函数</strong>： render函数返回的JSX结构，用于描述具体的渲染内容。但是，render函数并没有真正的去渲染组件，渲染是依靠React操作JSX结构完成的。<br>🐖：render函数应该是一个纯函数，不能在里面产生副作用，比如调用setState或者绑定事件。① 不能setState是因为render函数在每次渲染时都会被调用，而setState会触发渲染，就会造成死循环。② 不能绑定事件是因为容易被频繁调用注册。</p></li><li><p>✨<strong>componentDidMount函数</strong>： 主要用于组件加载完成后进行某些操作，比如发起网络请求或者绑定事件，该函数是接着render之后调用的。但是componentDidMount一定是在真实DOM绘制完成之后调用吗？在浏览器端可以这么认为。但是在其他场景下，尤其是React Native场景下，componentDidMount并不意味着真实的界面已经绘制完毕。（由于机器的性能限制，视图可能还在绘制中）</p></li></ul><p><strong>2.更新阶段</strong><br>&emsp;更新阶段是指外部props传入，或者state发生变化时的阶段。这个阶段主要有以下6个函数：</p><ul><li>💖<strong>UNSAFE_componentWillReceiveProps函数</strong>： 该函数已经被标记弃用，因为其功能可被getDerivedStateFromProps所替代。当getDerivedStateFromProps存在时，UNSAFE_componentWillReceiveProps不会被调用。</li><li>💖<strong>getDerivedStateFromProps函数</strong>: 同挂载阶段的变现一致。</li><li>💖<strong>shouldComponentUpdate函数</strong>: 该方法通过返回true或者false来确定是否需要触发新的渲染，因为渲染触发最后一道关卡，所以也是性能优化的必争之地。通过添加判断条件来阻止不必要的渲染。</li></ul><p>React官方提供了一个通用的优化方案，也就是PureComponent。PureComponent的核心原理是默认实现了shouldComponentUpdate函数，在这个函数中对props和state进行浅比较，用来判断是否触发更新。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">shouldComponentUpdate</span>(<span class="hljs-params">nextProps, nextState</span>)</span> &#123;  <span class="hljs-comment">// 浅比较仅比较值与引用，并不会对 Object 中的每一项值进行比较</span>  <span class="hljs-keyword">if</span> (shadowEqual(nextProps, <span class="hljs-built_in">this</span>.props) || shadowEqual(nextState, <span class="hljs-built_in">this</span>.state) ) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre><ul><li><p>💖<strong>UNSAFE_componentWillUpdate函数</strong>: 同样已废弃，因为在后续的React异步渲染设计中，可能会出现组件暂停更新渲染的情况。</p></li><li><p>💖<strong>render函数</strong>: 跟挂载阶段的表现一致</p></li><li><p>💖<strong>getSnapshotBeforeUpdate函数</strong>: getSnapshotBeforeUpdate是配合React新的异步渲染机制，在DOM更新发生之前被调用，返回值作为对componentDidUpdate的第三个参数。官方示例如下：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScrollingList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props);    <span class="hljs-built_in">this</span>.listRef = React.createRef();  &#125;  <span class="hljs-function"><span class="hljs-title">getSnapshotBeforeUpdate</span>(<span class="hljs-params">prevProps, prevState</span>)</span> &#123;    <span class="hljs-comment">// Are we adding new items to the list?</span>    <span class="hljs-comment">// Capture the scroll position so we can adjust scroll later.</span>    <span class="hljs-keyword">if</span> (prevProps.list.length &lt; <span class="hljs-built_in">this</span>.props.list.length) &#123;      <span class="hljs-keyword">const</span> list = <span class="hljs-built_in">this</span>.listRef.current;      <span class="hljs-keyword">return</span> list.scrollHeight - list.scrollTop;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  &#125;  <span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState, snapshot</span>)</span> &#123;    <span class="hljs-comment">// If we have a snapshot value, we&#x27;ve just added new items.</span>    <span class="hljs-comment">// Adjust scroll so these new items don&#x27;t push the old ones out of view.</span>    <span class="hljs-comment">// (snapshot here is the value returned from getSnapshotBeforeUpdate)</span>    <span class="hljs-keyword">if</span> (snapshot !== <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">const</span> list = <span class="hljs-built_in">this</span>.listRef.current;      list.scrollTop = list.scrollHeight - snapshot;    &#125;  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> (      &lt;div ref=&#123;<span class="hljs-built_in">this</span>.listRef&#125;&gt;&#123;<span class="hljs-comment">/* ...contents... */</span>&#125;&lt;/div&gt;    );  &#125;</code></pre></li><li><p>💖<strong>componentDidUpdate函数</strong>: 正如上面的案例，getSnapshotBeforeUpdate的返回值会作为componentDidUpdate的第三个参数使用。componentDidUpdate函数中可以使用setState来触发重新渲染，但是一定要小心，避免死循环！</p></li></ul><p><strong>3.挂载阶段</strong><br>&emsp;挂载阶段，只有一个回调函数。</p><ul><li>✌<strong>componentWillUnmount函数</strong>：该函数主要用于清理工作，一个比较常见的bug是忘记在componentWillUnmount中取消定时器，导致定时操作依然在组件销毁后不停地执行。所以在该阶段一定要完成事件解绑，取消定时器。</li></ul><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p> 根据上面的内容，可以做一个思维导图：<br> <img src="https://pic.downk.cc/item/5fce2a393ffa7d37b3f47cbd.jpg" alt="React生命周期思维导图"></p><h5 id="二、生命周期职责梳理"><a href="#二、生命周期职责梳理" class="headerlink" title="二、生命周期职责梳理"></a>二、生命周期职责梳理</h5><p> 职责梳理主要是搞清楚两个事情：<br> 1、什么情况下会触发重新渲染？<br> 2、渲染中发生报错后会怎样？</p><p> <strong>1.触发重新渲染的三种情况</strong>：</p><ul><li><p>😊<strong>函数组件</strong>： 函数组件在任何情况下都有可能重新渲染。它没有生命周期，但是官方提供了一个优化手段，那就是React.memo:</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> MyComponent = React.memo(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params">props</span>)</span>&#123;    <span class="hljs-comment">/*使用props渲染*/</span>&#125;)</code></pre><p>React.memo并不阻断渲染，而是跳过渲染组件的操作并直接复用最新一次渲染的结果，这与shouldComponentUpdate是完全不同的。</p></li><li><p>😊<strong>React.Component</strong>：如果不实现shouldComponentUpdate函数，那么有两种情况触发渲染：<br>1、当state发生变化时。（最常见的情况）<br>2、当父组件的Props传入时。（无论Props有没有发生变化，只有传入就会引发重新渲染）</p></li><li><p>😊<strong>React.PureComponent</strong>: PureComponent默认实现了shouldComponentUpdate函数，所以仅在props与state进行浅比较后，确认有变更时才会触发重新渲染。</p></li><li><p>*2.错误边界**： </p></li></ul><p>&emsp;错误边界是一种React组件，这种组件可以捕获并打印发生在其子组件树上任何位置的JavaScript错误，并且，它会渲染出备用UI，如下官方示例：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props);    <span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> &#125;;  &#125;  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getDerivedStateFromError</span>(<span class="hljs-params">error</span>)</span> &#123;    <span class="hljs-comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> &#125;;  &#125;  <span class="hljs-function"><span class="hljs-title">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>)</span> &#123;    <span class="hljs-comment">// 你同样可以将错误日志上报给服务器</span>    logErrorToMyService(error, errorInfo);  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state.hasError) &#123;      <span class="hljs-comment">// 你可以自定义降级后的 UI 并渲染</span>      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Something went wrong.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.props.children;   &#125;&#125;</code></pre><p>无论是React,还是React Native,如果没有错误边界，在用户侧看到的现象是：在执行某个错误操作时，触发了bug, 引发了崩溃，页面会突然白屏。</p><p>🐖：在渲染时的报错，只能通过componentDidCatch捕获。这是在做线上页面报错监控时，及其容易忽略的点。</p><h5 id="三、答题："><a href="#三、答题：" class="headerlink" title="三、答题："></a>三、答题：</h5><p>经过上面的梳理,现在可以回答开头的问题了。</p><blockquote><p>避免生命周期中的坑需要做好两件事：</p><p>1.不在恰当的时候调用了不该调用的代码；<br>2.在需要调用时，不要忘了调用。</p></blockquote><p>那么，有7种情况容易造成React生命周期的坑：</p><blockquote><p>1.getDerivedStateFromProps 容易编写反模式代码，使受控组件与非受控组件区分模糊。</p></blockquote><blockquote><p>2.componentWillMount 在 React 中已被标记弃用，不推荐使用，主要原因是新的异步渲染架构会导致它被多次调用。所以网络请求及事件绑定代码应移至 componentDidMount中。</p></blockquote><blockquote><p>3.componentWillReceiveProps 同样被标记弃用，被 getDerivedStateFromProps 所取代，主要原因是性能问题。</p></blockquote><blockquote><p>4.shouldComponentUpdate 通过返回 true 或者 false 来确定是否需要触发新的渲染。主要用于性能优化。</p></blockquote><blockquote><p>5.componentWillUpdate 同样是由于新的异步渲染机制，而被标记废弃，不推荐使用，原先的逻辑可结合 getSnapshotBeforeUpdate 与 componentDidUpdate 改造使用。</p></blockquote><blockquote><p>6.如果在 componentWillUnmount 函数中忘记解除事件绑定，取消定时器等清理操作，容易引发 bug。</p></blockquote><blockquote><p>7.如果没有添加错误边界处理，当渲染发生异常时，用户将会看到一个无法操作的白屏，所以一定要添加。</p></blockquote><h5 id="四、进阶提问：React-的请求应该放在哪里，为什么"><a href="#四、进阶提问：React-的请求应该放在哪里，为什么" class="headerlink" title="四、进阶提问：React 的请求应该放在哪里，为什么?"></a>四、进阶提问：React 的请求应该放在哪里，为什么?</h5><p> 对于异步请求，应该放在componentDidUpdate中操作。从时间顺序上看，似乎还有两个选择，但是它们都有各自的弊端：</p><ul><li><p>constructor：可以放，但是从设计上看不推荐，constructor主要用于初始化state和函数绑定，并不应该承载业务逻辑。而且随着类属性的流行，constructor已经很少使用了。</p></li><li><p>componentWillMout: 已经被标废弃，在新的异步渲染机制下回触发多次渲染，容易引发bug,不利于React升级后的代码维护。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>npm01--dependencies与devDependencies的区别</title>
    <link href="/2020/12/06/npm01-dependencies%E4%B8%8EdevDependencies%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/12/06/npm01-dependencies%E4%B8%8EdevDependencies%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="dependencies-与-devDependencies"><a href="#dependencies-与-devDependencies" class="headerlink" title="dependencies 与 devDependencies"></a>dependencies 与 devDependencies</h4><p>&emsp;当我们在使用npm install 安装node模块时，有两种命令参数将这些node模块的信息写入到package.json文件中：</p><ul><li>npm install *** –save，这个命令是将依赖包的信息添加到package.json文件的dependencies键下。</li><li>npm install *** –save-dev，这个命令是将依赖包的信息添加到devDependencies键下。</li></ul><h4 id="1-不同点："><a href="#1-不同点：" class="headerlink" title="1.不同点："></a>1.不同点：</h4><p><strong>devDependencies是开发环境</strong>，我们使用的一些构建工具如webpack、glup等只是在开发过程中用的包，上线后就和它们没有关系了，所以这种都写入devDependencies（还有一些单元测试工具也卸载这里）</p><p><strong>dependencies是生产环境</strong>，比如我们写一个项目需要依赖React/Vue/jQuery才能执行，没有这个包的依赖运行就会出错，这时候就必须把依赖写入dependencies里。</p><h4 id="2-相同点："><a href="#2-相同点：" class="headerlink" title="2.相同点："></a>2.相同点：</h4><p>dependencies和 devDependencies相同的地方在于：就是当我们clone别人的库进行开发测试的时候，可以通过npm install 一键安装这两个目录下的所有依赖，而不需要一行行地查找别人到底在文件中引用了哪些依赖。</p><p>参考：<a href="https://docs.npmjs.com/cli/v6/configuring-npm/package-json#dependencies">npm官方文档–dependencies</a></p>]]></content>
    
    
    <categories>
      
      <category>npm学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试02-为什么React要用JSX？</title>
    <link href="/2020/12/02/%E9%9D%A2%E8%AF%9502-%E4%B8%BA%E4%BB%80%E4%B9%88React%E8%A6%81%E7%94%A8JSX%EF%BC%9F/"/>
    <url>/2020/12/02/%E9%9D%A2%E8%AF%9502-%E4%B8%BA%E4%BB%80%E4%B9%88React%E8%A6%81%E7%94%A8JSX%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="面试场景2：为什么React要用JSX？（论证题）"><a href="#面试场景2：为什么React要用JSX？（论证题）" class="headerlink" title="面试场景2：为什么React要用JSX？（论证题）"></a>面试场景2：为什么React要用JSX？（论证题）</h4><p>&emsp;针对”为什么采用改技术方案？”类型的题，其实主要在考察两个方面：</p><ul><li>技术广度，深挖知识面涉猎广度，对流行框架的模板方案是否知悉了解。</li><li>技术方案调研能力</li></ul><p>所以，针对这类问题，可以采用 “一句话解释，核心概念，方案对比” 三步走的技巧来作答：</p><p>1、一句话解析JSX。用一句话说清楚JSX到底是什么。<br>2、核心概念。JSX用于解决什么问题？如何使用？<br>3、方案对比。与其他方案进行对比，说明React选用JSX的必要性。</p><h5 id="一、一句话解释"><a href="#一、一句话解释" class="headerlink" title="一、一句话解释"></a>一、一句话解释</h5><p>&emsp;按照React官方解释，<strong>JSX是一个JavaScript的语法扩展，或者说是一个类似于XML的ECMAScript语法扩展</strong>，它本身没有太多的语法定义，也不期望引入更多的标准。</p><h5 id="二、核心概念"><a href="#二、核心概念" class="headerlink" title="二、核心概念"></a>二、核心概念</h5><p>&emsp;其实React本身并不强制使用JSX，在没有JSX的时候，React实现一个组件依赖于使用React.createElement函数。代码如下：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> React.createElment(            <span class="hljs-string">&#x27;div&#x27;</span>,            <span class="hljs-literal">null</span>,            <span class="hljs-string">`Hello <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.props.toWhat&#125;</span>`</span>        );    &#125;&#125;ReactDOM.render(    React.createElement(<span class="hljs-string">&#x27;Hello,&#123;toWhat:&#x27;</span>World<span class="hljs-string">&#x27;&#125;),</span><span class="hljs-string">    document.getElementById(&#x27;</span>root<span class="hljs-string">&#x27;)</span><span class="hljs-string">)</span></code></pre><p>而JSX更像是语法糖，通过类似XML的描述方式，描写函数对象。采用JSX之后，上述代码会变成如下：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello,&#123;this.props.toWhat&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    &#125;&#125;ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Hello</span> <span class="hljs-attr">toWhat</span>=<span class="hljs-string">&#x27;world&#x27;</span>/&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>))</code></pre><p>通过这样对比，显然可以看出，<strong>JSX使得代码变得更为简洁，而且代码结构层次更为清晰。</strong></p><p>因为React需要将组件转化为虚拟DOM树，所以我们手写代码时，其实是在手写一颗结构树。而XML在树结构的描述上天然具有可读性强优势。<br>🐖：实际在运行的时候，会使用Babel插件将JSX语法的代码还原为React.createElement的代码。</p><h5 id="三、方案对比"><a href="#三、方案对比" class="headerlink" title="三、方案对比"></a>三、方案对比</h5><p><strong>1.React设计初衷</strong></p><p>React的设计初衷是：关注点分离（Separation of concerns)。在React种，关注点的基本单位是组件。React单个组件时高内聚的，而组件与组件之间时低耦合的。</p><blockquote><p>关注点分离：是计算机科学里面的一个重要概念。主要思想是将代码分隔为不同部分，每一部分都有各自的关注点。优点： 当关注点分开时，各部分可以重复使用，独立开发和更新。具有特殊价值的部分能够稍后改进或修改一段代码，而无须知道其他部分的细节做出的相应更改。</p></blockquote><p><strong>2.React为什么不使用模板呢？</strong></p><p>React团队认为引入模板是一种不佳的实现。因为模板分离了技术栈，而非关注点的模板同时又引入了很多的概念，比如新的模板语法、模板指令等。以AngularJS为例，可以看下有多少新概念：</p><pre><code class="hljs js">&lt;!doctype html&gt;&lt;html ng-app=<span class="hljs-string">&quot;docsBindExample&quot;</span>&gt;  &lt;head&gt;    &lt;script src=<span class="hljs-string">&quot;http://code.angularjs.org/1.2.25/angular.min.js&quot;</span>&gt;&lt;/script&gt;    &lt;script src=<span class="hljs-string">&quot;script.js&quot;</span>&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div ng-controller=<span class="hljs-string">&quot;Ctrl1&quot;</span>&gt;      Hello &lt;input ng-model=<span class="hljs-string">&#x27;name&#x27;</span>&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span></span>      &lt;span ng-bind=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;<span class="hljs-regexp">/span&gt; &lt;br/</span>&gt;      &lt;span ng:bind=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;<span class="hljs-regexp">/span&gt; &lt;br/</span>&gt;      &lt;span ng_bind=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;<span class="hljs-regexp">/span&gt; &lt;br/</span>&gt;      &lt;span data-ng-bind=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;<span class="hljs-regexp">/span&gt; &lt;br/</span>&gt;      &lt;span x-ng-bind=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;<span class="hljs-regexp">/span&gt; &lt;br/</span>&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;angular.module(<span class="hljs-string">&#x27;docsBindExample&#x27;</span>, [])  .controller(<span class="hljs-string">&#x27;Ctrl1&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Ctrl1</span>(<span class="hljs-params">$scope</span>) </span>&#123;    $scope.name = <span class="hljs-string">&#x27;Max Karl Ernst Ludwig Planck (April 23, 1858 – October 4, 1947)&#x27;</span>;  &#125;);</code></pre><p>看完会发现这段代码很难懂，因为它引入了非常多的AngularJS独有的概念，但是JSX却不会有很多新概念，它依然是JavaScript，就连条件表达式和循环都仍然是JavaScript的方式。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> App=<span class="hljs-function">(<span class="hljs-params">props</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span>(        &lt;div&gt;            &#123;props.isShow?<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>show<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>:<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>hidden<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>&#125;            &#123;props.names.map(<span class="hljs-function"><span class="hljs-params">name</span>=&gt;</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>)&#125;        &lt;/div&gt;    )&#125;</code></pre><p>这样比较下来，可以看出React代码更简洁，更具有可读性，更贴近HTML。</p><p>那模板字符串也可以套用HTML，为什么不用模板字符串呢？</p><p><strong>3.React为什么不使用模板字符串呢？</strong></p><p>来看一个模板字符串的例子：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> box = jsx<span class="hljs-string">`</span><span class="hljs-string"></span><span class="hljs-string">  &lt;<span class="hljs-subst">$&#123;Box&#125;</span>&gt;</span><span class="hljs-string"></span><span class="hljs-string">    <span class="hljs-subst">$&#123;</span></span><span class="hljs-string"><span class="hljs-subst"></span></span><span class="hljs-string"><span class="hljs-subst">      shouldShowAnswer(user) ?</span></span><span class="hljs-string"><span class="hljs-subst"></span></span><span class="hljs-string"><span class="hljs-subst">      jsx<span class="hljs-string">`&lt;<span class="hljs-subst">$&#123;Answer&#125;</span> value=<span class="hljs-subst">$&#123;<span class="hljs-literal">false</span>&#125;</span>&gt;no&lt;/<span class="hljs-subst">$&#123;Answer&#125;</span>&gt;`</span> :</span></span><span class="hljs-string"><span class="hljs-subst"></span></span><span class="hljs-string"><span class="hljs-subst">      jsx<span class="hljs-string">`</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">        &lt;<span class="hljs-subst">$&#123;Box.Comment&#125;</span>&gt;</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">         Text Content</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">        &lt;/<span class="hljs-subst">$&#123;Box.Comment&#125;</span>&gt;</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">      `</span></span></span><span class="hljs-string"><span class="hljs-subst"></span></span><span class="hljs-string"><span class="hljs-subst">    &#125;</span></span><span class="hljs-string"></span><span class="hljs-string">  &lt;/<span class="hljs-subst">$&#123;Box&#125;</span>&gt;</span><span class="hljs-string"></span><span class="hljs-string">`</span>;</code></pre><p>显然代码结构还是非常复杂（存在多次内部嵌套），也不利于开发工具的代码提示。</p><p><strong>4.React为什么不使用JXON呢？</strong></p><p>JXON很像目前使用的JSX，它的结构如下：</p><pre><code class="hljs js">&lt;catalog&gt;  &lt;product description=<span class="hljs-string">&quot;Cardigan Sweater&quot;</span>&gt;   &lt;catalog_item gender=<span class="hljs-string">&quot;Men&#x27;s&quot;</span>&gt;     &lt;item_number&gt;QWZ5671&lt;/item_number&gt;     &lt;price&gt;<span class="hljs-number">39.95</span>&lt;/price&gt;     &lt;size description=<span class="hljs-string">&quot;Medium&quot;</span>&gt;       &lt;color_swatch image=<span class="hljs-string">&quot;red_cardigan.jpg&quot;</span>&gt;Red&lt;/color_swatch&gt;       &lt;color_swatch image=<span class="hljs-string">&quot;burgundy_cardigan.jpg&quot;</span>&gt;Burgundy&lt;/color_swatch&gt;     &lt;/size&gt;     &lt;size description=<span class="hljs-string">&quot;Large&quot;</span>&gt;       &lt;color_swatch image=<span class="hljs-string">&quot;red_cardigan.jpg&quot;</span>&gt;Red&lt;/color_swatch&gt;       &lt;color_swatch image=<span class="hljs-string">&quot;burgundy_cardigan.jpg&quot;</span>&gt;Burgundy&lt;/color_swatch&gt;     &lt;/size&gt;   &lt;/catalog_item&gt;   &lt;catalog_item gender=<span class="hljs-string">&quot;Women&#x27;s&quot;</span>&gt;     &lt;item_number&gt;RRX9856&lt;/item_number&gt;     &lt;discount_until&gt;Dec <span class="hljs-number">25</span>, <span class="hljs-number">1995</span>&lt;/discount_until&gt;     &lt;price&gt;<span class="hljs-number">42.50</span>&lt;/price&gt;     &lt;size description=<span class="hljs-string">&quot;Medium&quot;</span>&gt;       &lt;color_swatch image=<span class="hljs-string">&quot;black_cardigan.jpg&quot;</span>&gt;Black&lt;/color_swatch&gt;     &lt;/size&gt;   &lt;/catalog_item&gt;  &lt;/product&gt;  &lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;&lt;![CDATA[<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchwo</span>(<span class="hljs-params">a,b</span>) </span>&#123;    <span class="hljs-keyword">if</span> (a &lt; b &amp;&amp; a &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;    <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;&#125;]]&gt;&lt;/script&gt;&lt;/catalog&gt;</code></pre><p>最后放弃JXON这一方案的原因是，大括号不能作为元素在树种开始和结束的位置，无法提供很好的语法提示。</p><p>最后总结下，React为什么使用JSX?</p><p><img src="https://pic.downk.cc/item/5fc752d5394ac523789ece3c.jpg" alt="react使用JSX原因"></p><p>==答题==： </p><blockquote><p>首先，JSX 是一个 JavaScript 的语法扩展，结构类似 XML。<br>（JSX 主要用于声明 React 元素，但 React 中并不强制使用 JSX。即使使用了 JSX，也会在构建过程中，通过 Babel 插件编译为 React.createElement。所以 JSX 更像是 React.createElement 的一种语法糖。<br>React团队并不想引入JavaScript本身以外的开发体系，而是希望通过合理的关注点分离保持组件开发的纯粹性。）</p></blockquote><blockquote><p>然后，是JSX与其他三种技术方案的对比：<br>1.模板。 React 团队认为模板不应该是开发过程中的关注点，因为引入了模板语法、模板指令等概念，是一种不佳的实现方案。<br>2.模板字符串。 模板字符串编写的结构会造成多次内部嵌套，使整个结构变得复杂，并且优化代码提示也会变得困难重重。<br>3.JXON。 同样因为代码提示困难的原因而被放弃</p></blockquote><p>✨所以，React选择了JSX，因为JSX与其设计思想最为吻合，不需要引入过多的新概念，对编辑器代码提示也很友好。</p>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>React03-React.cloneElement函数</title>
    <link href="/2020/12/01/React03-React-cloneElement%E5%87%BD%E6%95%B0/"/>
    <url>/2020/12/01/React03-React-cloneElement%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="React-cloneElement-element-props-…children"><a href="#React-cloneElement-element-props-…children" class="headerlink" title="React.cloneElement(element,[props],[…children])"></a>React.cloneElement(element,[props],[…children])</h4><p>&emsp;这个API以element元素为样板克隆并返回新的React元素。</p><ul><li>返回元素的props是将新的props与原始元素的props浅层合并后的结果。</li><li>新的子元素将取代现有的子元素，而来自原始元素的key和ref将被保留。</li></ul><p>React.cloneElement() 基本等同于：</p><pre><code class="hljs js">&lt;element.type &#123;...element.props&#125;&#123;...props&#125;&gt;&#123;children&#125;&lt;/element.type&gt;</code></pre><p>参考：<a href="https://zh-hans.reactjs.org/docs/react-api.html#cloneelement">React.cloneElement官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>React学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试01-你真的了解React吗？</title>
    <link href="/2020/11/30/%E9%9D%A2%E8%AF%9501-%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3React%E5%90%97%EF%BC%9F/"/>
    <url>/2020/11/30/%E9%9D%A2%E8%AF%9501-%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3React%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="面试场景1：谈谈你对React的理解？（概念题）"><a href="#面试场景1：谈谈你对React的理解？（概念题）" class="headerlink" title="面试场景1：谈谈你对React的理解？（概念题）"></a>面试场景1：谈谈你对React的理解？（概念题）</h4><p>针对这种概念题，一般采用四字口诀：“讲说理列”</p><ul><li>讲概念: 一句话讲清楚该技术是什么。  </li><li>说用途：描述该技术的用途（结合具体场景，拓展性的描述)</li><li>理思路：梳理该技术的核心思路或运作流程。</li><li>列优缺：对该技术的优点缺点进行列举（与其他技术方案进行横向对比，但切忌踩一捧一！）</li></ul><h5 id="1、讲React概念"><a href="#1、讲React概念" class="headerlink" title="1、讲React概念"></a>1、讲React概念</h5><p><strong>React是通过组件化的方式解决视图层开发复用的问题，本质是一个组件化框架。</strong></p><p>简单概括为： View = fn(props)， 给定相同的输入状态，函数总会生成一致的组件。如果变量多一些，也可以扩展为 View = fn(props,state,context)</p><h5 id="2、说React用途"><a href="#2、说React用途" class="headerlink" title="2、说React用途"></a>2、说React用途</h5><p><strong>React的用途就是：构建视图。</strong> React的生态丰富了它的使用场景：</p><ul><li>首先，PC网页和移动端网页，React都支持</li><li>其次，React Native 可用于开发ios与Android应用</li><li>React 360可以开发VR应用</li><li>冷门的ink,可以使用React开发命令行应用。</li></ul><h5 id="3、理React思路"><a href="#3、理React思路" class="headerlink" title="3、理React思路"></a>3、理React思路</h5><p><strong>React的核心思路：声明式、组件化、通用性</strong>（官方称，一次学习，随处编写）</p><ul><li><strong>声明式</strong>：优势在于直观，可以做到一目了然，也便于组合。</li></ul><p>命令式编程：</p><pre><code class="hljs js"><span class="hljs-comment">//HTML</span>&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&#x27;block&#x27;</span>&gt;&lt;/div&gt;<span class="hljs-comment">//JS</span><span class="hljs-keyword">const</span> block=$(<span class="hljs-string">&#x27;.block&#x27;</span>)block.css(<span class="hljs-string">&#x27;color&#x27;</span>,<span class="hljs-string">&#x27;red&#x27;</span>)</code></pre><p>声明式编程：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> Block=<span class="hljs-function">(<span class="hljs-params">props</span>)=&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;color:</span>&#x27;<span class="hljs-attr">red</span>&#x27;&#125;&#125;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre><p>可以发现，声明式编程更容易阅读，而且更容易与其他组件代码组合。</p><ul><li><p><strong>组件化</strong>：组件化优势在于可以降低系统间功能的耦合性，提高功能内部的聚合性。这样便于代码复用。</p></li><li><p><strong>通用性</strong>：React将DOM抽象为虚拟DOM，开发者并不是直接操作DOM。正因为这一层封装的存在，使得React不再局限于web开发，而是出现更繁荣的生态。不论VR，Native,还是shell命令，只有兼容虚拟DOM层，都可以直接运行React。</p></li></ul><h5 id="4、列React优缺"><a href="#4、列React优缺" class="headerlink" title="4、列React优缺"></a>4、列React优缺</h5><ul><li><p>优点：其实就是React的核心设计思路：声明式，组件化，通用性。</p></li><li><p>缺点：React不是一个一揽子框架，比如路由一类的功能，React团队希望交给社区解决。导致技术选型和学习使用上有较高的成本，在开发大型前端应用时需要向社区寻找并整合解决方案。（非官方的一揽子解决方案是有的，比如DvaJS、React-coat等）</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试宝典之React篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>React02-setState的使用</title>
    <link href="/2020/11/27/React02-setState%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/27/React02-setState%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="setState-updater-callback"><a href="#setState-updater-callback" class="headerlink" title="setState(updater, [callback])"></a>setState(updater, [callback])</h3><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>1、setState()将对组件state的更新排入队列，并通知React需要使用更新后的state重新渲染此组件及其子组件。这是用于更新用户界面以响应事件处理器和处理服务器数据的主要方式。</p><p>2、<strong>将setState()视为请求而不是立即更新组件的命令</strong>。为了更好的感知性能，React会延迟调用它，然后通过一次传递更新多个组件。React并不会保证state的变更会立即生效。</p><p>3、<strong>setState()并不总是立即更新组件，它会批量推迟更新</strong>。这使得在调用setState()后立即读取this.state成为了隐患。为了消除隐患，应当使用componentDidUpdate或者setState的回调函数，这两种方式都可以保证在应用更新后触发。如果需要基于之前的state来设置当前的state，查看关于updater部分的描述。</p><p>4、除非shouldComponentUpate()返回false,否则setState()将始终执行重新渲染操作。</p><h4 id="二、参数1：updater函数"><a href="#二、参数1：updater函数" class="headerlink" title="二、参数1：updater函数"></a>二、参数1：updater函数</h4><pre><code class="hljs js">(state,props) =&gt; stateChange</code></pre><p>其中，state是对应用变化时组件状态的引用，它不应该直接被修改。应当使用基于state和props构建的新对象来表示变化。例如，我们需要使用props.step来增加state：</p><pre><code class="hljs js"><span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state, props</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">counter</span>: state.counter + props.step&#125;&#125;)</code></pre><p>updater函数中接收的state和props都保证为最新。updater的返回值会与state进行浅合并。</p><p>🐖：setState()的第一个参数除了接受函数外，还接受对象类型：</p><pre><code class="hljs js">setState(stateChange[,callback])</code></pre><p>stateChange会将传入的对象浅合并到新的state中，例子：</p><pre><code class="hljs js"><span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">counter</span>: <span class="hljs-number">2</span>&#125;)</code></pre><p>这种形式的setState()也是异步的！并且在同一个周期内对多个setState进行批处理。例如，如果在同一个时期多次设置商品数量增加,则相当于：</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.assign(    previousState,    &#123;<span class="hljs-attr">quantiity</span>: state.quantity + <span class="hljs-number">1</span>&#125;,    &#123;<span class="hljs-attr">quantiity</span>: state.quantity + <span class="hljs-number">1</span>&#125;)</code></pre><p>此时，后调用的setState()将覆盖同一周期内先调用setState的值，因此商品数仅增加1次。如果后续状态取决于当前的状态，建议使用updater函数的形式代替：</p><pre><code class="hljs js"><span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">quantity</span>: state.quantity + <span class="hljs-number">1</span>&#125;;&#125;)</code></pre><h4 id="三、参数2：回调函数callback-（可选）"><a href="#三、参数2：回调函数callback-（可选）" class="headerlink" title="三、参数2：回调函数callback （可选）"></a>三、参数2：回调函数callback （可选）</h4><p>这个回调函数，<strong>将在setState完成合并并重新渲染组件后执行</strong>。通常，建议使用componentDidUpdate()方式来代替这个回调函数的使用。</p>]]></content>
    
    
    <categories>
      
      <category>React学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>React01--ref的使用</title>
    <link href="/2020/11/24/React01-ref%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/24/React01-ref%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="ref的详细用法"><a href="#ref的详细用法" class="headerlink" title="ref的详细用法"></a>ref的详细用法</h2><p>在react典型的数据流中，props传递时父子组件交互的唯一方式：通过传递一个新的props值来使子组件重新render，从而达到父子组件通信。但是，某些情况下，你需要在典型数据流之外强制修改子组件。比如：</p><ul><li>管理焦点，文本选择或者媒体播放</li><li>触发强制动画</li><li>集成第三方DOM库</li></ul><p>这些情况下，react提供了新的方案：ref</p><h4 id="一、ref简介"><a href="#一、ref简介" class="headerlink" title="一、ref简介"></a>一、ref简介</h4><p>React提供的ref属性，<strong>表示对组件真正实例的引用</strong>，其实就是ReactDOM.render()返回的组件实例；需要区分一下：ReactDOM.render()渲染组件时返回的是组件实例；而渲染dom元素时，返回的是具体的dom节点。</p><p>例如，下面的代码：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> domCom=<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<span class="hljs-keyword">const</span> refDom=ReactDOM.render(domCom,container);<span class="hljs-keyword">const</span> refCom=ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">myComponent</span> /&gt;</span></span>,container);<span class="hljs-built_in">console</span>.log(refDom);<span class="hljs-built_in">console</span>.log(refCom);</code></pre><p>上述代码运行如下：<br><img src="https://pic.downk.cc/item/5fbcde31b18d6271133f9065.jpg"></p><p>ref可以挂在任何组件上，可以挂在组件上也可以是dom元素上：</p><ul><li>挂在组件上（指有状态组件）的ref表示对组件实例的引用</li><li>挂载到dom元素上时表示具体的dom节点</li></ul><h4 id="二、ref可以设置回调函数"><a href="#二、ref可以设置回调函数" class="headerlink" title="二、ref可以设置回调函数"></a>二、ref可以设置回调函数</h4><p>ref属性可以设置为一个回调函数，这也是官方推荐的做法。这个函数的执行时机为：</p><ul><li>==组件被挂载后==，回调函数立即执行，回调函数的参数为该组件的具体实例。</li><li>==组件被卸载或者原有的ref属性本身发生变化时==，回调也会被立即执行，此时回调函数参数为null,以避免内存泄漏。</li></ul><p>例子：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomTextInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;        <span class="hljs-built_in">super</span>(props);        <span class="hljs-built_in">this</span>.textInput=<span class="hljs-literal">null</span>;        <span class="hljs-built_in">this</span>.setTextInputRef=<span class="hljs-function"><span class="hljs-params">element</span>=&gt;</span>&#123;            <span class="hljs-built_in">this</span>.textInput=element;        &#125;        <span class="hljs-built_in">this</span>.focusTextInput=<span class="hljs-function">()=&gt;</span>&#123;        <span class="hljs-comment">//使用原生DOM API使得text输入框获得焦点</span>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.textInput) <span class="hljs-built_in">this</span>.textInput.focus();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-comment">//组件挂载后，让文本自动获得焦点</span>        <span class="hljs-built_in">this</span>.focusTextInput();    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        &lt;div&gt;            &lt;input              type=<span class="hljs-string">&#x27;text&#x27;</span>              ref=&#123;<span class="hljs-built_in">this</span>.setTextInputRef&#125;            /&gt;            &lt;input             type=<span class="hljs-string">&quot;button&quot;</span>             value=<span class="hljs-string">&quot;Focus the text input&quot;</span>             onClick=&#123;<span class="hljs-built_in">this</span>.focusTextInput&#125;            /&gt;        &lt;/div&gt;    &#125;  &#125;</code></pre><p>上述代码中，React将在组件挂载时，会调用ref回调函数并传入DOM元素，当卸载时调用它并传入null。在componentDidMount或componentDidUpdate触发前，React会保证refs一定是最新的。</p><h4 id="三、ref可以设置字符串-了解"><a href="#三、ref可以设置字符串-了解" class="headerlink" title="三、ref可以设置字符串 (了解)"></a>三、ref可以设置字符串 (了解)</h4><p>&emsp;ref还可以设置为字符串值，不过这种方式基本不再推荐使用。</p><pre><code class="hljs js">&lt;input ref=<span class="hljs-string">&#x27;input&#x27;</span>&gt;</code></pre><p>&emsp;然后再其他地方如事件回调中通过this.refs.input可以访问该组件实例，其实就是dom节点</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> element=<span class="hljs-built_in">this</span>.refs.input</code></pre><h4 id="四、创建与访问Refs"><a href="#四、创建与访问Refs" class="headerlink" title="四、创建与访问Refs"></a>四、创建与访问Refs</h4><p><strong>1.创建refs:</strong></p><p>&emsp;refs是使用React.createRef()创建的，并通过ref属性附加到React元素。在构建组件时，通常将refs分配给组件实例属性，以便在整个组件中都引用它们。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props);    <span class="hljs-built_in">this</span>.myRef = React.createRef();  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.myRef&#125;</span> /&gt;</span></span>;  &#125;&#125;</code></pre><p><strong>2.访问refs:</strong></p><p>&emsp;当ref被传递给render中的元素时，对该节点的引用可以哎ref的current属性中被访问。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> node = <span class="hljs-built_in">this</span>.myRef.current;</code></pre><p>ref的值根据节点类型不同而有所不同：</p><ul><li>当ref属性用于HTML元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性。</li><li>当ref属性用于自定义class组件时，ref对象接收组件的挂载实例作为其current属性。</li></ul><p>🐖：不能在函数组件上使用ref属性，因为他们没有实例！</p>]]></content>
    
    
    <categories>
      
      <category>React学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>28-时刻考虑性能问题</title>
    <link href="/2020/11/21/28-%E6%97%B6%E5%88%BB%E8%80%83%E8%99%91%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/21/28-%E6%97%B6%E5%88%BB%E8%80%83%E8%99%91%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="一、如何避免性能问题："><a href="#一、如何避免性能问题：" class="headerlink" title="一、如何避免性能问题："></a>一、如何避免性能问题：</h4><p>1、了解常见的性能问题场景（解决最可能产生性能问题的场景）</p><ul><li>  键盘输入过程卡顿</li><li>  鼠标的移动过程卡顿</li></ul><p>2、时刻注意代码的潜在性能问题</p><ul><li>什么时候拆分组件</li><li>组件粒度是否够细</li></ul><p>3、注意可重构的代码</p><ul><li>代码的耦合性必须低，功能模块非常独立</li></ul><p>4、了解如何使用工具定位性能问题：</p><ul><li>React-devTool</li><li>Chrome-devTool</li></ul><h4 id="二、网络性能优化：自动化按需加载"><a href="#二、网络性能优化：自动化按需加载" class="headerlink" title="二、网络性能优化：自动化按需加载"></a>二、网络性能优化：自动化按需加载</h4><p>如何在react中实现按需加载：<br>1、按需加载：用户当前需要用什么功能就只加载这个功能对应的代码。<br>2、使用Webpack的import API<br>3、使用react-loadable库实现React异步加载</p><p><img src="https://pic.downk.cc/item/5fb913a4b18d627113603f84.jpg" alt="按需加载"></p><h4 id="三、使用Reselect避免重复计算"><a href="#三、使用Reselect避免重复计算" class="headerlink" title="三、使用Reselect避免重复计算"></a>三、使用Reselect避免重复计算</h4><p>Reselect:创建自动缓存的数据处理流程（只有数据变化时才重新计算，否则使用缓存的结果）</p><p><strong>原则</strong>:所有能够计算得到的数据一定是通过计算拿到</p><p><img src="https://pic.downk.cc/item/5fb91595b18d62711360ba51.jpg" alt="自动缓存"></p><h4 id="四、React异步渲染"><a href="#四、React异步渲染" class="headerlink" title="四、React异步渲染"></a>四、React异步渲染</h4><p><img src="https://pic.downk.cc/item/5fb918ffb18d62711361b0b2.jpg"></p><p><strong>时间分片：</strong><br>1、虚拟DOM的diff操作可以分片进行<br>2、React新API：unstable_deferredUpdates<br>3、Chrome新API：requestIdleCallback 浏览器什么时候空闲</p><p><strong>渲染挂起：</strong></p><p>1、unstable_deferUpdate<br>2、React的新内置组件：Timeout组件</p><h4 id="五、使用工具发现性能问题"><a href="#五、使用工具发现性能问题" class="headerlink" title="五、使用工具发现性能问题"></a>五、使用工具发现性能问题</h4><p>1、使用React DevTool找到多余渲染<br>2、使用Chrome DevTool定位性能瓶颈</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>27-React中拖放的实现</title>
    <link href="/2020/11/21/27-React%E4%B8%AD%E6%8B%96%E6%94%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/11/21/27-React%E4%B8%AD%E6%8B%96%E6%94%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>第三方库实现拖放的缺陷：</strong></p><ul><li>第三方库实现拖放不够灵活，</li><li>很多场景比较简单，并不需要引入第三方库</li><li>增加额外的体积会影响性能。</li></ul><p><strong>实现拖放的技术要点：</strong></p><p>1、如何使用React的鼠标事件系统<br>2、如何判断拖放开始和结束<br>3、如何让实现拖放元素的位置移动<br>4、拖放状态在组件中如何维护</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>26-React集成第三方JS库（d3.js为例）</title>
    <link href="/2020/11/21/26-React%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9JS%E5%BA%93%EF%BC%88d3-js%E4%B8%BA%E4%BE%8B%EF%BC%89/"/>
    <url>/2020/11/21/26-React%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9JS%E5%BA%93%EF%BC%88d3-js%E4%B8%BA%E4%BE%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h4 id="集成第三方JS库的技术要点："><a href="#集成第三方JS库的技术要点：" class="headerlink" title="集成第三方JS库的技术要点："></a>集成第三方JS库的技术要点：</h4><p>1、使用ref获取原生DOM节点引用<br>2、手动将组件状态更新到DOM节点<br>3、组件销毁时移除原生节点DOM事件</p><p>d3.js用来画图形的第三方库，操作原生DOM节点，也是以数据驱动（与React非常吻合）。</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>25-使用React-Router实现分布操作</title>
    <link href="/2020/11/21/25-%E4%BD%BF%E7%94%A8React-Router%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/11/21/25-%E4%BD%BF%E7%94%A8React-Router%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="向导页面需要考虑的技术要点："><a href="#向导页面需要考虑的技术要点：" class="headerlink" title="向导页面需要考虑的技术要点："></a>向导页面需要考虑的技术要点：</h4><p>例子：一个向导页面<br><img src="https://pic.downk.cc/item/5fb8dbeab18d62711350c62f.jpg"></p><p>1、使用URL进行导航<br>2、表单数据如何管理<br>3.页面状态如何切换（根据数据的状态决定UI的状态）</p><h4 id="基于路由实现菜单导航："><a href="#基于路由实现菜单导航：" class="headerlink" title="基于路由实现菜单导航："></a>基于路由实现菜单导航：</h4><p>技术要点：<br>1.菜单导航只改变URL状态<br>2.根据当前URL显示菜单的当前状态。</p><p>可以使用react-router的NavLink,展示当前的选中状态 （NavLink的activeClassName属性）</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>24-页面数据来源于多个请求</title>
    <link href="/2020/11/21/24-%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90%E4%BA%8E%E5%A4%9A%E4%B8%AA%E8%AF%B7%E6%B1%82/"/>
    <url>/2020/11/21/24-%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90%E4%BA%8E%E5%A4%9A%E4%B8%AA%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h4 id="一、页面数据来自多个请求："><a href="#一、页面数据来自多个请求：" class="headerlink" title="一、页面数据来自多个请求："></a>一、页面数据来自多个请求：</h4><p>1、请求之间无依赖关系时，多个请求可以并发进行</p><p>2、请求之间有依赖关系时，需要依次进行</p><p>3、请求完成之前，页面显示Loding状态<br>（Loding可能并不需要特别设为一个状态值，可以根据数据的状态来判断是否显示’Loding..’)</p><h4 id="二、内容页的加载与缓存"><a href="#二、内容页的加载与缓存" class="headerlink" title="二、内容页的加载与缓存"></a>二、内容页的加载与缓存</h4><p><img src="https://pic.downk.cc/item/5fb8da68b18d627113503356.jpg"></p><p><strong>内容页和列表页的数据关系：</strong></p><ul><li>简单业务：列表页数据包含内容页的数据</li><li>复杂业务：内容页数据需要额外获取</li><li>内容页数据的缓存</li></ul><p>🐖：内容页不能只依靠列表页进行，用户可能刷新页面，所以它自己也需要定义一个访问接口的action。</p><p><img src="https://pic.downk.cc/item/5fb8d9d7b18d627113500886.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>23-在React中实现列表页</title>
    <link href="/2020/11/20/23-%E5%9C%A8React%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E9%A1%B5/"/>
    <url>/2020/11/20/23-%E5%9C%A8React%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E9%A1%B5/</url>
    
    <content type="html"><![CDATA[<h4 id="一、列表页：搜索、数据缓存和分页"><a href="#一、列表页：搜索、数据缓存和分页" class="headerlink" title="一、列表页：搜索、数据缓存和分页"></a>一、列表页：搜索、数据缓存和分页</h4><p>开发列表页需要考虑的技术要点：</p><ul><li>如何翻页</li><li>如何进行内容搜索</li><li>如何缓存数据</li><li>何时进行页面刷新</li></ul><p><img src="https://pic.downk.cc/item/5fb76b52b18d627113ee2145.jpg" alt="列表页的数据模型"></p><p><img src="https://pic.downk.cc/item/5fb76b8eb18d627113ee2fe8.jpg" alt="Store的设计"></p><p><img src="https://pic.downk.cc/item/5fb76ccbb18d627113ee8a4b.jpg" alt="URL设计和Store同步"></p><h4 id="二、列表页：缓存更新、加载状态以及错误处理"><a href="#二、列表页：缓存更新、加载状态以及错误处理" class="headerlink" title="二、列表页：缓存更新、加载状态以及错误处理"></a>二、列表页：缓存更新、加载状态以及错误处理</h4><p><img src="https://pic.downk.cc/item/5fb76f47b18d627113ef65f6.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>22-在React中实现表单</title>
    <link href="/2020/11/20/22-%E5%9C%A8React%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%A1%A8%E5%8D%95/"/>
    <url>/2020/11/20/22-%E5%9C%A8React%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%A1%A8%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h4 id="一、实现表单：初始数据、提交和跳转"><a href="#一、实现表单：初始数据、提交和跳转" class="headerlink" title="一、实现表单：初始数据、提交和跳转"></a>一、实现表单：初始数据、提交和跳转</h4><p>1、单纯使用React的方式实现表单</p><p><img src="https://pic.downk.cc/item/5fb76076b18d627113eb2a31.jpg"></p><p>🐖：是在form中编辑onSubmit，而不是在button的点击事件里提交，这样即使你点回车也会进行提交（给出错误提示）</p><p>可以发现这样实现表单是比较麻烦的！</p><p>2、使用UI library实现表单（比如Antd)</p><p>具体参照：<a href="https://ant.design/components/form-cn/#header">Antd-Form表单</a></p><p>3、可以对API进行封装</p><h4 id="二、实现表单：错误处理、动态操作表单元素，内容动态加载"><a href="#二、实现表单：错误处理、动态操作表单元素，内容动态加载" class="headerlink" title="二、实现表单：错误处理、动态操作表单元素，内容动态加载"></a>二、实现表单：错误处理、动态操作表单元素，内容动态加载</h4><p>以Antd为例：一个demo<br><a href="https://codesandbox.io/s/6n20nrzlxz?file=/src/c29/FormBuilder.js">https://codesandbox.io/s/6n20nrzlxz?file=/src/c29/FormBuilder.js</a></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>21-ReactRouter管理登录和授权</title>
    <link href="/2020/11/20/21-ReactRouter%E7%AE%A1%E7%90%86%E7%99%BB%E5%BD%95%E5%92%8C%E6%8E%88%E6%9D%83/"/>
    <url>/2020/11/20/21-ReactRouter%E7%AE%A1%E7%90%86%E7%99%BB%E5%BD%95%E5%92%8C%E6%8E%88%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<h3 id="使用React-Router-管理路由授权"><a href="#使用React-Router-管理路由授权" class="headerlink" title="使用React-Router 管理路由授权"></a>使用React-Router 管理路由授权</h3><p>1、实现基础：React Router的动态路由机制<br>2、区分受保护路由和公开路由<br>3、访问未授权路由时重定向到登录页面或显示禁止访问</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>20-使用Rekit开发可扩展的React应用</title>
    <link href="/2020/11/20/20-%E4%BD%BF%E7%94%A8Rekit%E5%BC%80%E5%8F%91%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84React%E5%BA%94%E7%94%A8/"/>
    <url>/2020/11/20/20-%E4%BD%BF%E7%94%A8Rekit%E5%BC%80%E5%8F%91%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84React%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="Rekit-React专属IDE和工具集"><a href="#Rekit-React专属IDE和工具集" class="headerlink" title="Rekit: React专属IDE和工具集"></a>Rekit: React专属IDE和工具集</h3><p><img src="https://pic.downk.cc/item/5fb7295cb18d627113dc80e8.jpg"></p><h4 id="一、使用Rekit创建项目，代码生成和重构"><a href="#一、使用Rekit创建项目，代码生成和重构" class="headerlink" title="一、使用Rekit创建项目，代码生成和重构"></a>一、使用Rekit创建项目，代码生成和重构</h4><p>只需要写功能部分的代码，不用再自己构建骨架。</p><p><img src="https://pic.downk.cc/item/5fb729deb18d627113dca15a.jpg"></p><p><img src="https://pic.downk.cc/item/5fb72aa5b18d627113dccff5.jpg"></p><p><img src="https://pic.downk.cc/item/5fb72b4cb18d627113dcfc0c.jpg"></p><p><img src="https://pic.downk.cc/item/5fb72c21b18d627113dd4456.jpg"></p><p><img src="https://pic.downk.cc/item/5fb72c51b18d627113dd4ee6.jpg"></p><p><img src="https://pic.downk.cc/item/5fb72ceeb18d627113dd7003.jpg"></p><h4 id="二、使用Rekit遵循最佳实践和保持代码一致性"><a href="#二、使用Rekit遵循最佳实践和保持代码一致性" class="headerlink" title="二、使用Rekit遵循最佳实践和保持代码一致性"></a>二、使用Rekit遵循最佳实践和保持代码一致性</h4><p>==最佳实践:==</p><ul><li>1.以feature方式组织代码</li><li>2.拆分组件component，action和reducer</li><li>3.拆分路由配置</li></ul><p>==通过代码自动生成保持一致性：==</p><ul><li>1.文件夹结构一致性</li><li>2.文件名一致性</li><li>3.变量名一致性</li><li>4.代码逻辑一致性</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>19-拆分大型项目的复杂度</title>
    <link href="/2020/11/20/19-%E6%8B%86%E5%88%86%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2020/11/20/19-%E6%8B%86%E5%88%86%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="拆分复杂度"><a href="#拆分复杂度" class="headerlink" title="拆分复杂度"></a>拆分复杂度</h3><h4 id="一、按领域模型（feature）组织代码，降低耦合度"><a href="#一、按领域模型（feature）组织代码，降低耦合度" class="headerlink" title="一、按领域模型（feature）组织代码，降低耦合度"></a>一、按领域模型（feature）组织代码，降低耦合度</h4><p><img src="https://pic.downk.cc/item/5fb71ee0b18d627113d9dabc.jpg"></p><p><img src="https://pic.downk.cc/item/5fb71f0ab18d627113d9e304.jpg"></p><p><img src="https://pic.downk.cc/item/5fb71f24b18d627113d9e849.jpg"></p><p><strong>解决：先以业务逻辑,以功能进行划分，然后每个功能(feature)内部有自己的reducer，component，action</strong></p><p><img src="https://pic.downk.cc/item/5fb71f7db18d627113d9fdb5.jpg"></p><p>使用React技术栈如何实现这种架构？</p><p><img src="https://pic.downk.cc/item/5fb71fe1b18d627113da1548.jpg"></p><p>以功能区分，路由配置也可以分散在每个feature中，这样可扩展性和可维护性更好！</p><h4 id="二、如何组织component，action-和-reducer"><a href="#二、如何组织component，action-和-reducer" class="headerlink" title="二、如何组织component，action 和 reducer"></a>二、如何组织component，action 和 reducer</h4><p><img src="https://pic.downk.cc/item/5fb720bab18d627113da4750.jpg"></p><p>单元测试文件夹tests是单独维护的，单独放在一个地方。</p><p>常量：通常在每个feature下面有个constant.js文件</p><p><img src="https://pic.downk.cc/item/5fb72191b18d627113da77a0.jpg"></p><p>rootReducer的写法：<br><img src="https://pic.downk.cc/item/5fb721e2b18d627113da87fe.jpg"></p><p><strong>总结</strong>：</p><ul><li>按照feature组织组件component，action和reducer</li><li>使用root loader加载feature下的各个资源</li><li>做到高内聚、松耦合</li></ul><h4 id="三、如何组织React-Route的路由配置"><a href="#三、如何组织React-Route的路由配置" class="headerlink" title="三、如何组织React Route的路由配置"></a>三、如何组织React Route的路由配置</h4><p><img src="https://pic.downk.cc/item/5fb72294b18d627113dabdf7.jpg"></p><p>推荐JSON方式的路由：</p><p><img src="https://pic.downk.cc/item/5fb722f6b18d627113dae650.jpg"></p><p>解析JSON路由：<br><img src="https://pic.downk.cc/item/5fb72375b18d627113db0340.jpg"></p><p><strong>总结</strong>：</p><ul><li>每个feature都有自己的专属路由配置</li><li>顶层路由使用JSON配置更容易维护</li><li>如何解析JSON配置到React Router语法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>18-前端项目的理想架构</title>
    <link href="/2020/11/20/18-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%90%86%E6%83%B3%E6%9E%B6%E6%9E%84/"/>
    <url>/2020/11/20/18-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%90%86%E6%83%B3%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="前端项目的理想架构"><a href="#前端项目的理想架构" class="headerlink" title="前端项目的理想架构"></a>前端项目的理想架构</h3><p><img src="https://pic.downk.cc/item/5fb71b94b18d627113d91010.jpg"></p><h4 id="1、-易于开发"><a href="#1、-易于开发" class="headerlink" title="1、 易于开发"></a>1、 易于开发</h4><ul><li>开发工具是否完善</li><li>生态圈是否繁荣</li><li>社区是否活跃</li></ul><h4 id="2、易于扩展"><a href="#2、易于扩展" class="headerlink" title="2、易于扩展"></a>2、易于扩展</h4><ul><li>增加新动能是否容易</li><li>新功能是否会显著增加系统复杂度</li></ul><h4 id="3、易于维护"><a href="#3、易于维护" class="headerlink" title="3、易于维护"></a>3、易于维护</h4><ul><li>代码是否容易理解</li><li>文档是否健全</li></ul><h4 id="4、易于测试"><a href="#4、易于测试" class="headerlink" title="4、易于测试"></a>4、易于测试</h4><p>（测试后于开发，所以必须在开发时就考虑清楚）</p><ul><li>功能的分层是否清晰（Jquery那种就很难进行单元测试）</li><li>副作用少</li><li>尽量使用纯函数</li></ul><h4 id="5、易于构建"><a href="#5、易于构建" class="headerlink" title="5、易于构建"></a>5、易于构建</h4><ul><li>使用通用技术和架构</li><li>构建工具的选择（webpack等，</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>17-常用开发调试工具</title>
    <link href="/2020/11/20/17-%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <url>/2020/11/20/17-%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="常用开发调试工具："><a href="#常用开发调试工具：" class="headerlink" title="常用开发调试工具："></a>常用开发调试工具：</h3><h4 id="1-ESLint"><a href="#1-ESLint" class="headerlink" title="1.ESLint"></a>1.ESLint</h4><ul><li>使用.eslintrc进行规则的配置</li><li>告诉你哪里不符合规则</li><li>可以使用airbnb的JavaScript代码风格</li></ul><h4 id="2-Prettier"><a href="#2-Prettier" class="headerlink" title="2.Prettier"></a>2.Prettier</h4><ul><li>代码格式化的神器（可以自动修改不符合规则的）</li><li>包装更容易写出风格一致的代码</li></ul><h4 id="3-React-Dev-Tools"><a href="#3-React-Dev-Tools" class="headerlink" title="3.React Dev Tools"></a>3.React Dev Tools</h4><p><img src="https://pic.downk.cc/item/5fb71930b18d627113d88a26.jpg"></p><ul><li>可以观察React组件树的DOM结构</li><li>可以看到哪些组件render</li></ul><h4 id="4-Redux-Dev-Tools"><a href="#4-Redux-Dev-Tools" class="headerlink" title="4.Redux Dev Tools"></a>4.Redux Dev Tools</h4><p><img src="https://pic.downk.cc/item/5fb7197bb18d627113d898dd.jpg"></p><ul><li>可以观察当前Store的状态</li><li>用户发出动作后，会看到action</li><li>时间线：可以恢复到action变化之前的时间线</li><li>可以自动生成一些测试的代码，直接copy到单元测试文件中</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>16-使用Jest和Enzyme等工具进行单元测试</title>
    <link href="/2020/11/18/16-%E4%BD%BF%E7%94%A8Jest%E5%92%8CEnzyme%E7%AD%89%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/11/18/16-%E4%BD%BF%E7%94%A8Jest%E5%92%8CEnzyme%E7%AD%89%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一、React让前端单元测试变得容易："><a href="#一、React让前端单元测试变得容易：" class="headerlink" title="一、React让前端单元测试变得容易："></a>一、React让前端单元测试变得容易：</h3><p>1、React应用很少需要访问浏览器API<br>2、虚拟DOM可以在NodeJS环境运行和测试<br>3、Redux隔离了状态管理，纯数据层单元测试</p><h3 id="二、单元测试涉及的工具"><a href="#二、单元测试涉及的工具" class="headerlink" title="二、单元测试涉及的工具"></a>二、单元测试涉及的工具</h3><p>1、Jest: FaceBook开源的JS单元测试框架<br>2、JS DOM： 浏览器环境的NodeJS模拟<br>3、Enzyme： react组件渲染和测试<br>4、nock： 模拟HTTP请求<br>5、sinon： 函数模拟和调用跟踪<br>6、istanbul: 单元测试覆盖率（对已有方法修改和埋点）</p><p><img src="https://pic.downk.cc/item/5fb4bc4cb18d62711351ecbc.jpg"></p><p><img src="https://pic.downk.cc/item/5fb4bc5fb18d62711351f09e.jpg"></p><p><img src="https://pic.downk.cc/item/5fb4bc9db18d62711351fc16.jpg"></p><p><img src="https://pic.downk.cc/item/5fb4bdf1b18d6271135241c2.jpg"></p><p><img src="https://pic.downk.cc/item/5fb4be5eb18d627113525540.jpg"></p><p><img src="https://pic.downk.cc/item/5fb4bef6b18d627113527125.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单元测试工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15-使用Next.js</title>
    <link href="/2020/11/18/15-%E4%BD%BF%E7%94%A8Next-js/"/>
    <url>/2020/11/18/15-%E4%BD%BF%E7%94%A8Next-js/</url>
    
    <content type="html"><![CDATA[<p>使用next.js开发React项目的同构应用。</p><h3 id="一、什么是同构应用？"><a href="#一、什么是同构应用？" class="headerlink" title="一、什么是同构应用？"></a>一、什么是同构应用？</h3><p><img src="https://pic.downk.cc/item/5fb4b6adb18d62711350daf9.jpg"></p><p>next.js可以自动配置好同构应用的webpack配置等细节。</p><h3 id="二、next的基本用法"><a href="#二、next的基本用法" class="headerlink" title="二、next的基本用法"></a>二、next的基本用法</h3><p><img src="https://pic.downk.cc/item/5fb4b787b18d62711350fce5.jpg"></p><p><strong>在页面中使用其他的React组件：</strong></p><p>1、页面也是标准的node模块，可使用其他的React组件 （放在components目录下面）<br>2、页面会针对性打包， 仅包含起引入的组件。</p><p><img src="https://pic.downk.cc/item/5fb4b95bb18d627113515a13.jpg"></p><p>🐖：prefetch并不会预加载服务器端的数据</p><p><strong>关于lazy load:</strong><br><img src="https://pic.downk.cc/item/5fb4ba11b18d627113517eef.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14-UI组件库的对比</title>
    <link href="/2020/11/18/14-UI%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <url>/2020/11/18/14-UI%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Ant-Design"><a href="#一、Ant-Design" class="headerlink" title="一、Ant Design"></a>一、Ant Design</h3><p>服务于企业级产品的设计体系，有完善的文档</p><h3 id="二、Marterial-UI"><a href="#二、Marterial-UI" class="headerlink" title="二、Marterial-UI"></a>二、Marterial-UI</h3><p>风格更时尚，更花哨，面向消费者</p><h3 id="三、Semantic-UI"><a href="#三、Semantic-UI" class="headerlink" title="三、Semantic UI"></a>三、Semantic UI</h3><p>把UI作为language描述，提供了不同library的实现。</p><p><strong>选择UI库的考虑因素：</strong></p><ul><li>1、组件库是否齐全</li><li>2、样式风格是否符合业务需求</li><li>3、API的设计是否便捷灵活</li><li>4、技术支持是否完善（文档，issue）</li><li>5、开发是否活跃（维护，迭代）</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>bug记录</title>
    <link href="/2020/11/18/bug%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/11/18/bug%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1、-Error-“Objects-are-not-valid-as-a-React-child”"><a href="#1、-Error-“Objects-are-not-valid-as-a-React-child”" class="headerlink" title="1、 Error: “Objects are not valid as a React child”"></a>1、 Error: “Objects are not valid as a React child”</h3><p>在redux的练习中，blog这个demo报了这个错：</p><p><img src="https://pic.downk.cc/item/5fb48937b18d62711347d6df.jpg"></p><p>原代码：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> jsonPlaceholder.get(<span class="hljs-string">`/users/<span class="hljs-subst">$&#123;id&#125;</span>`</span>);dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;FETCH_USER&quot;</span>, <span class="hljs-attr">payload</span>: response.data &#125;);</code></pre><p>打开访问的API后发现，response.data是个object类型，不能直接赋值给payload<br>应该先通过JSON.stringify()将其转换为JSON格式，再进行赋值。</p><p>修改后的代码如下：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> jsonPlaceholder.get(<span class="hljs-string">`/users/<span class="hljs-subst">$&#123;id&#125;</span>`</span>);<span class="hljs-keyword">const</span> data = <span class="hljs-built_in">JSON</span>.stringify(response.data);dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;FETCH_USER&quot;</span>, <span class="hljs-attr">payload</span>: data &#125;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>bug汇总</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13-React-Router:路由不只是页面切换，更是代码组织方式</title>
    <link href="/2020/11/17/13-React-Router-%E8%B7%AF%E7%94%B1%E4%B8%8D%E5%8F%AA%E6%98%AF%E9%A1%B5%E9%9D%A2%E5%88%87%E6%8D%A2%EF%BC%8C%E6%9B%B4%E6%98%AF%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/"/>
    <url>/2020/11/17/13-React-Router-%E8%B7%AF%E7%94%B1%E4%B8%8D%E5%8F%AA%E6%98%AF%E9%A1%B5%E9%9D%A2%E5%88%87%E6%8D%A2%EF%BC%8C%E6%9B%B4%E6%98%AF%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="一、为什么需要路由？"><a href="#一、为什么需要路由？" class="headerlink" title="一、为什么需要路由？"></a>一、为什么需要路由？</h3><ul><li>1.单页应用需要进行页面切换</li><li>2.通过URL可以定位到页面</li><li>3.更有语义的组织资源</li></ul><p><img src="https://pic.downk.cc/item/5fb37daab18d62711306e930.jpg"></p><p><img src="https://pic.downk.cc/item/5fb37e3cb18d6271130703a8.jpg"></p><h3 id="二、React-Router的特性："><a href="#二、React-Router的特性：" class="headerlink" title="二、React-Router的特性："></a>二、React-Router的特性：</h3><p>1、声明式路由定义<br>2、动态路由：页面render时，path才会被解析</p><h3 id="三、实现路由的三种方式"><a href="#三、实现路由的三种方式" class="headerlink" title="三、实现路由的三种方式"></a>三、实现路由的三种方式</h3><p>1、URL路由<br>2、Hash路由： #+ 路径，支持低版本<br>3、内存路由：MemoryRouter，服务器端渲染</p><h3 id="四、基于路由配置进行资源组织"><a href="#四、基于路由配置进行资源组织" class="headerlink" title="四、基于路由配置进行资源组织"></a>四、基于路由配置进行资源组织</h3><p>1、实现业务逻辑的松耦合<br>2、易于扩展，重构和维护<br>3、路由层面实现Lazy Load</p><h3 id="五、React-Router-的几个API"><a href="#五、React-Router-的几个API" class="headerlink" title="五、React-Router 的几个API"></a>五、React-Router 的几个API</h3><p><img src="https://pic.downk.cc/item/5fb37fdab18d627113075987.jpg"></p><p><img src="https://pic.downk.cc/item/5fb37feeb18d627113075f96.jpg"></p><p><img src="https://pic.downk.cc/item/5fb38003b18d627113076520.jpg"></p><p><img src="https://pic.downk.cc/item/5fb38032b18d627113076f40.jpg"></p><p><img src="https://pic.downk.cc/item/5fb38056b18d627113077657.jpg"></p><p><img src="https://pic.downk.cc/item/5fb380a8b18d627113078667.jpg"></p><h3 id="六、通过URL传递参数"><a href="#六、通过URL传递参数" class="headerlink" title="六、通过URL传递参数"></a>六、通过URL传递参数</h3><p><img src="https://pic.downk.cc/item/5fb3827bb18d62711307e56e.jpg"></p><p><img src="https://pic.downk.cc/item/5fb3834eb18d627113081472.jpg"></p><p><img src="https://pic.downk.cc/item/5fb3842ab18d627113084eaf.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12-Redux在Rect中的用法</title>
    <link href="/2020/11/17/12-Redux%E5%9C%A8Rect%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2020/11/17/12-Redux%E5%9C%A8Rect%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>&emsp;为了方便在react中使用redux, Redux的作者封装了一个React专用的库<strong>React-Redux</strong>.</p><p>&emsp;这个库是可选的，在实际项目中应该权衡下是直接使用redux还是使用React-Redux。后者虽然方便，但是要掌握额外的API，并且要遵守它的组件拆分规则。</p><h3 id="一、UI组件"><a href="#一、UI组件" class="headerlink" title="一、UI组件"></a>一、UI组件</h3><p>&emsp;React-Redux将所有组件分为两大类：</p><ul><li>UI组件（presentational component）</li><li>容器组件（container component）</li></ul><p>&emsp;UI组件有以下特征：</p><ul><li>1、只负责UI的呈现，不带任何业务逻辑</li><li>2、没有状态（即不适用this.state这个变量）</li><li>3、所有数据都由参数（this.props)提供</li><li>4、不使用任何Redux的API</li></ul><p>一个UI组件的例子：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> Title = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></code></pre><p>&emsp;因为不含有状态，UI组件又称为‘纯组件’，即它和纯函数一样，纯粹由参数决定它的值。</p><h3 id="二、容器组件"><a href="#二、容器组件" class="headerlink" title="二、容器组件"></a>二、容器组件</h3><p>&emsp; 容器组件的特征恰恰相反：</p><ul><li>负责管理数据和业务逻辑，不负责UI的呈现</li><li>带有内部状态</li><li>使用Redux的API</li></ul><p>&emsp;总之，UI组件负责UI的呈现，容器组件负责管理数据和逻辑。</p><p>&emsp;如果一个组件既有UI又有业务逻辑，那么应该将它拆分为下面的结构：外面是一个容器组件，里面包含一个UI组件。前者负责与外部的通信，将数据传给后者，由后者渲染出试图。</p><p>&emsp;React-Redux规定，所有的UI组件由用户提供，容器组件则由React-Redux自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。</p><h3 id="三、connect"><a href="#三、connect" class="headerlink" title="三、connect()"></a>三、connect()</h3><p>&emsp;React-Redux提供connect方法，用于从UI组件生成容器组件。（connect的意思就是将这两种组件连起来）</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;connect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span><span class="hljs-keyword">const</span> VisibleTodoList = connect()(TodoList);<span class="hljs-comment">//TodoList是UI组件，VisibleTodoList就是通过connect方法自动生成的容器组件</span></code></pre><p>&emsp;但是由于没有定义业务逻辑，上面这个容器组件没有任何意义，只是UI组件的一个单纯的包装层。为了定义业务逻辑，需要给出以下信息：</p><ul><li>（1）输入逻辑：外部的数据（即state对象）如何转换为UI组件的参数。</li><li>（2）输出逻辑：用户发出的动作如何变为Action对象，从UI组件传出去。</li></ul><p>&emsp;因此，connect方法的完整API如下：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;connect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<span class="hljs-keyword">const</span> VisibleTodoList = connect(    mapStateToProps,    mapDispatchToProps)(TodoList)</code></pre><p>&emsp;connect函数接受两个参数：mapStateToProps  和 mapDispatchToProps。它们定义了UI组件的业务逻辑：前者负责输入逻辑，即将state映射到UI组件的参数（props),后者负责输出逻辑，即将用户对UI组件的操作映射为Action对象。</p><h3 id="四、mapStateToProps"><a href="#四、mapStateToProps" class="headerlink" title="四、mapStateToProps()"></a>四、mapStateToProps()</h3><p>&emsp; mapStateToProps是一个函数，它的作用就是像它的名字那样，建立一个从（外部的）state对象到（UI组件的）props对象的映射关系。</p><p>&emsp;作为函数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。<br>例子：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> mapStateToProps=<span class="hljs-function">(<span class="hljs-params">state</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123;        <span class="hljs-comment">//todos属性，代表UI组件的同名属性</span>        <span class="hljs-comment">//getVisibleTodos可以从state算出todos的值</span>        todos: getVisibleTodos(state.todos,state.visibilityFilter)    &#125;&#125;<span class="hljs-comment">//getVisibleTodos可以从state算出todos的值</span><span class="hljs-keyword">const</span> getVisibleTodos=<span class="hljs-function">(<span class="hljs-params">todos,filter</span>)=&gt;</span>&#123;    <span class="hljs-function"><span class="hljs-title">switch</span>(<span class="hljs-params">filter</span>)</span>&#123;        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;SHOW_ALL&#x27;</span>:            <span class="hljs-keyword">return</span> todos;        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;SHOW_COMPLETED&#x27;</span>:            <span class="hljs-keyword">return</span> todos.filter(<span class="hljs-function"><span class="hljs-params">t</span>=&gt;</span>t.completed);        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;SHOW_ACTIVE&#x27;</span>:            <span class="hljs-keyword">return</span> todos.filter(<span class="hljs-function"><span class="hljs-params">t</span>=&gt;</span>!t.completed);        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Unknow filter:&#x27;</span>+filter)    &#125;&#125;</code></pre><p>&emsp;mapStateToProps 会订阅Store,每当state更新的时候，会自动执行，重新计算UI组件的参数，从而触发UI组件的重新渲染。</p><p>&emsp;mapStateToProps 的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象。</p><pre><code class="hljs js"><span class="hljs-comment">//容器组件的代码</span><span class="hljs-comment">// &lt;FilterLink filter=&#x27;SHOW_ALL&#x27;&gt;ALL&lt;/FilterLink&gt;</span><span class="hljs-keyword">const</span> mapStateToProps = <span class="hljs-function">(<span class="hljs-params">state,ownProps</span>) =&gt;</span>&#123;    <span class="hljs-keyword">return</span> &#123;        active:ownProps.filter === state.visibilityFilter    &#125;&#125;</code></pre><p> &emsp;使用ownProps作为参数后，如果容器组件的参数发生变化，也会引起UI组件重新渲染。</p><p> &emsp;connect方法可以省略mapStateToProps参数，那样的话UI组件就不会订阅Store, 也就是说Store的更新不会引起UI组件渲染。</p><h3 id="五、mapDispatchToProps"><a href="#五、mapDispatchToProps" class="headerlink" title="五、mapDispatchToProps()"></a>五、mapDispatchToProps()</h3><p> &emsp;mapDispatchToProps 是connect函数的第二个参数，用来建立UI组件的参数到Store.dispatch的映射，它定义了哪些用户的操作应该当作Action，传给Store。它可以是一个函数，也可以是一个对象。</p><p> &emsp;1、<strong>如果mapDispatchToProps是一个函数</strong>，会得到dispatch和ownProps(容器组件的props对象)两个参数。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> mapDispatchToProps = (    dispatch,    ownProps) =&gt; &#123;    <span class="hljs-keyword">return</span> &#123;        onClick:<span class="hljs-function">()=&gt;</span>&#123;            dispatch(&#123;                type:<span class="hljs-string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>,                filter:ownProps.filter            &#125;)        &#125;    &#125;&#125;</code></pre><p>&emsp;从上述代码中可以看出，mapispatchToProps作为函数，应该返回以一个对象，该对象的每个键值对都是一个映射，定义了UI组件的参数怎样发出action。</p><p>&emsp;2、<strong>如果mapDispatchToProps是一个对象</strong>，它的每个键名也是对应UI的同名参数，键值应该是一个函数，会被当作是Action Creator,返回的Action会由Redux自动发出。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> mapDispatchToProps=&#123;    onClick:<span class="hljs-function">(<span class="hljs-params">filter</span>)=&gt;</span>&#123;        type:<span class="hljs-string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>,        filter:filter    &#125;&#125;</code></pre><h3 id="六、Provider组件"><a href="#六、Provider组件" class="headerlink" title="六、Provider组件"></a>六、Provider组件</h3><p>&emsp;connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成UI组件的参数。一种解决方法是将state对象作为参数，传给容器组件。但是这样比较麻烦，尤其是容器组件在很深的层级时，一级级将state传下去就很麻烦。</p><p>&emsp;React-Redux提供Provider组件，可以让容器组件拿到state。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;Provider&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">import</span> todoApp <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducers&#x27;</span>;<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/App&#x27;</span>;<span class="hljs-keyword">let</span> store = createStore(todoApp);render(    &lt;Provider store=&#123;store&#125;&gt;        &lt;App /&gt;    &lt;/Provider&gt;,    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>))</code></pre><p>&emsp;Provider 在根组件外面包了一层，这样一来，App的所有子组件默认都可以拿到state了。Provider的原理时React组件的context属性。<br>源码：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Provider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">getChildContext</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> &#123;            store:<span class="hljs-built_in">this</span>.props.store        &#125;    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.props.children;    &#125;&#125;Provider.childContextTypes = &#123;    store:React.PropTypes.object&#125;</code></pre><p>&emsp;上面代码中，store放在了上下文对象context上面。然后，子组件就可以从context拿到store。代码如下：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VisibleTodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">const</span> &#123;store&#125; = <span class="hljs-built_in">this</span>.context;        <span class="hljs-built_in">this</span>.unsubscribe=store.subscribe(<span class="hljs-function">()=&gt;</span>            <span class="hljs-built_in">this</span>.forceUpdate()        );    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">const</span> props=<span class="hljs-built_in">this</span>.props;        <span class="hljs-keyword">const</span> &#123;store&#125;=<span class="hljs-built_in">this</span>.context;        <span class="hljs-keyword">const</span> state=store.getState();        <span class="hljs-comment">//...</span>    &#125;&#125;VisibleTodoList.contextTypes = &#123;    store:React.PropTypes.object&#125;</code></pre><p>React-Redux 自动生成的容器组件的代码就是类似于上面这样，拿到store。</p><h3 id="七、React-Router-路由库"><a href="#七、React-Router-路由库" class="headerlink" title="七、React-Router 路由库"></a>七、React-Router 路由库</h3><p>&emsp;使用React-Router的项目，与其他项目没有不同之处，也是使用Provider在Router外面包一层。毕竟Provider的唯一功能就是传入store对象。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> Root = <span class="hljs-function">(<span class="hljs-params">&#123;store&#125;</span>) =&gt;</span> (    &lt;Provider store=&#123;store&#125;&gt;        &lt;Router&gt;            &lt;Route path=<span class="hljs-string">&quot;/&quot;</span> component=&#123;App&#125; /&gt;        &lt;/Router&gt;    &lt;/Provider&gt;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11-redux之中间件与异步操作</title>
    <link href="/2020/11/16/11-redux%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/11/16/11-redux%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>第10篇文章里，介绍了redux的基本做法：用户发出Action, Reducer函数算出新的State，View重新渲染。<br><img src="https://pic.downk.cc/item/5fb26119b18d627113c52bcf.jpg"><br>但是异步操作应该怎么处理呢？Action发出以后，Reducer立即算出新的State, 这就叫做同步；Action发出后，过一段时间再执行Reducer,这就叫做异步。<br>怎么才能让reducer在异步操作结束后自动执行呢？这就要用到新的工具： <strong>中间件</strong>（middleware）<br><img src="https://pic.downk.cc/item/5fb27135b18d627113c87d35.jpg"></p><h3 id="一、中间件的概念"><a href="#一、中间件的概念" class="headerlink" title="一、中间件的概念"></a>一、中间件的概念</h3><p>为了让redux可以进行异步操作，势必要在redux工作流程中添加新的功能。那么在哪个环节添加合适呢？</p><p>（1）Reducer: 纯函数，只能承担计算State的功能，不适合承担其他功能，也承担不了。因为理论上，纯函数不能进行读写的操作。</p><p>（2）View: 与State一一对应，可以看作是State的视觉层，也不合适承担其他功能。</p><p>（3）Action: 存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。</p><p>想来想去，只有发送Action的这个步骤，即Store.dispatch()这个方法，可以添加功能。<br>中间件就是一个函数，对store.dispatch方法进行了改造，在发出Action和执行Reducer这两步之间，添加了其他功能。</p><h3 id="二、中间件的使用"><a href="#二、中间件的使用" class="headerlink" title="二、中间件的使用"></a>二、中间件的使用</h3><p>常用的中间件都是现成的，只有引用别人写好的模块就行。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; applyMiddleware,createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">import</span> createLogger <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-logger&#x27;</span>;<span class="hljs-keyword">const</span> logger = createLogger();<span class="hljs-keyword">const</span> store = createStore(    reducer,    initialState, <span class="hljs-comment">//整个应用的初始状态</span>    applyMiddleware(logger))</code></pre><p>🐖：中间件的次序有讲究。有的中间件有次序要求，比如logger就一定放在最后，否则输出结果会不正确。使用前要查阅相关文档</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = createStore(    reducer,    appltMiddleware(thunk,promise,logger)    <span class="hljs-comment">//这里是用了三个中间件</span>)</code></pre><p>==applyMiddlewares()：== applyMiddlewares是Redux的原生方法，作用是将所有中间件组成一个数组，依次执行。</p><h3 id="三、异步操作的基本思路"><a href="#三、异步操作的基本思路" class="headerlink" title="三、异步操作的基本思路"></a>三、异步操作的基本思路</h3><p>同步操作只要发出一种Action即可，异步操作的差别是它要发出三种Action:</p><ul><li>操作发起时的Action</li><li>操作成功时的Action</li><li>操作失败时的Action</li></ul><p>以服务器取出数据为例，三种Action可以有两种写法：</p><pre><code class="hljs js"><span class="hljs-comment">//写法一：名称相同，参数不同</span>&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;FETCH_POSTS&#x27;</span>&#125;&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;FETCH_POSTS&#x27;</span>,<span class="hljs-attr">status</span>:<span class="hljs-string">&#x27;error&#x27;</span>,<span class="hljs-attr">error</span>:<span class="hljs-string">&#x27;OoPS&#x27;</span>&#125;&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;FETCH_POSTS&#x27;</span>,<span class="hljs-attr">status</span>:<span class="hljs-string">&#x27;success&#x27;</span>,<span class="hljs-attr">response</span>:&#123;...&#125; &#125;<span class="hljs-comment">//写法二：名称不同</span>&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;FETCH_POSTS_REQUEST&#x27;</span>&#125;&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;FETCH_POSTS_FAILURE&#x27;</span>,<span class="hljs-attr">error</span>:<span class="hljs-string">&#x27;Oops&#x27;</span>&#125;&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;FETCH_POSTS_SUCCESS&#x27;</span>,<span class="hljs-attr">response</span>:&#123;...&#125;&#125;</code></pre><p>除了Action种类不同，异步操作的State也要进行改造，反映不同的操作状态。<br>例子：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> state=&#123;    <span class="hljs-comment">//...</span>    isFetching:<span class="hljs-literal">true</span>, <span class="hljs-comment">//是否正在抓取数据</span>    didInvalidate:<span class="hljs-literal">true</span>,<span class="hljs-comment">//是否超时</span>    lastUpdated:<span class="hljs-string">&#x27;xxxx&#x27;</span><span class="hljs-comment">//上一次更新时间</span>&#125;</code></pre><p>现在，整个异步操作的思路就比较清晰了</p><ul><li>1.操作开始时，发送一个Action,触发State 更新为“正在操作”状态，View重新渲染</li><li>2.操作结束后，再送出一个Action,触发State 更新为“操作结束”状态，View再次重新渲染。</li></ul><h3 id="四、redux-thunk中间件"><a href="#四、redux-thunk中间件" class="headerlink" title="四、redux-thunk中间件"></a>四、redux-thunk中间件</h3><p>异步操作至少要发两个Action：用户触发第一个Action,这个跟同步操作一样没有问题，但是，如何才能再操作结束时，系统自动送出第二个Action呢？</p><p>这个奥妙在于Action Creator之中。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;    <span class="hljs-comment">//加载成功后，</span>    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">const</span> &#123;dispatch,selectedPost&#125;=<span class="hljs-built_in">this</span>.props;        <span class="hljs-comment">//发送一个Action,向服务器要数据</span>        <span class="hljs-comment">//这里的fetchPosts()函数就是Action Creator</span>        dispatch(fetchPosts(selectedPost));    &#125;&#125;</code></pre><p>下面就是fetchPosts的代码</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> fetchPosts = <span class="hljs-function"><span class="hljs-params">postTitle</span> =&gt;</span><span class="hljs-function">(<span class="hljs-params">dispatch,getState</span>)=&gt;</span>&#123;    <span class="hljs-comment">//1.先发出一个Action</span>    dispatch(requestPosts(postTitle));    <span class="hljs-comment">//2.进行异步操作</span>    <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">&#x27;/some/API/$&#123;postTitle&#125;.json&#x27;</span>)        <span class="hljs-comment">//3.拿到结果，将结果转换为JSON格式</span>        .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())        <span class="hljs-comment">//4.再发出一个Action</span>        .then(<span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> dispatch(receivePosts(postTitle,json)))&#125;</code></pre><p>🐖：</p><ul><li>fetchPosts 返回了一个函数，而普通的Action Creator返回一个Action对象</li><li>fetchPosts 返回的函数入参时dispatch和getState这两个redux方法，普通的Action Creator的参数是Action的内容。</li><li>在返回的函数中，先发出一个Action（requestPosts(postTitle)），表示操作开始</li><li>异步操作结束之后，又发出一个Action（receivePosts(postTitle,json)），表示操作结束。</li></ul><p>这样的处理，解决了异步操作中需要自动发出第二个Action的问题，但是，Action是由store.dispatch方法发出的，而这个方法正常情况下，入参只能是对象而不能是函数。<br>====&gt; 这时，就需要中间件redux-think</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>;<span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducers&#x27;</span>;<span class="hljs-comment">// Note: this API requires redux@&gt;=3.1.0</span><span class="hljs-keyword">const</span> store = createStore(  reducer,  applyMiddleware(thunk));</code></pre><p>上面代码使用redux-thunk,改造store.dispatch,使得后者可以接受函数作为参数。</p><p>因此，异步操作的第一个解决方案：写一个返回函数的Action Creator,然后使用redux-thunk 中间件改造store.dispatch.</p><h3 id="五、redux-promise中间件"><a href="#五、redux-promise中间件" class="headerlink" title="五、redux-promise中间件"></a>五、redux-promise中间件</h3><p>&emsp;既然Action Creator 可以返回函数，当然也可返回其他值。所以另一种异步操作的解决方案就是，让Action Creator返回一个Promise对象.</p><p>&emsp;这就需要使用redux-promise中间件。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createStore,applyMiddleware&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">import</span> promiseMiddleware <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-promise&#x27;</span>;<span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducers&#x27;</span>;<span class="hljs-comment">//这时Action Creator有两种写法，</span><span class="hljs-comment">//1.返回值是一个对象</span><span class="hljs-keyword">const</span> fetchPosts=<span class="hljs-function">(<span class="hljs-params">dispatch,postTitle</span>)=&gt;</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;    dispatch(requestPosts(postTitle));    <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">&#x27;/some/API/$&#123;postTitle&#125;.json)</span><span class="hljs-string">        .then(response=&gt;&#123;</span><span class="hljs-string">            type:&#x27;</span>FETCH_POSTS<span class="hljs-string">&#x27;,</span><span class="hljs-string">            payload:response.json()</span><span class="hljs-string">        &#125;)</span><span class="hljs-string">&#125;)</span><span class="hljs-string"></span><span class="hljs-string">//2.Action对象的payload属性是一个Promise对象，</span><span class="hljs-string">// 这时需要从redux-actions模块引入createAction方法</span></code></pre><p>参考文章：<a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html">阮一峰redux教程</a></p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>010-状态管理库Redux</title>
    <link href="/2020/11/16/010-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93Redux/"/>
    <url>/2020/11/16/010-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93Redux/</url>
    
    <content type="html"><![CDATA[<h3 id="一、React为何需要状态管理库"><a href="#一、React为何需要状态管理库" class="headerlink" title="一、React为何需要状态管理库"></a>一、React为何需要状态管理库</h3><p><img src="https://i.bmp.ovh/imgs/2020/11/26a4726bd6216f11.png"></p><p><img src="https://i.bmp.ovh/imgs/2020/11/8ed5fe88ed497e9c.png"><br>组件之间通信非常麻烦，有了redux把状态单独拧出来，组件通信就变得简单了。</p><p>Redux的特性：</p><ul><li><strong>1、Single Source of Truth</strong></li></ul><p>&emsp;传统的MVC架构：一个view可能对应多个model,一个model也可能对应多个view,关系错综复杂，这样一旦出现错误很难追踪。<br><img src="https://i.bmp.ovh/imgs/2020/11/5a9cb384b94cc272.png"></p><p>&emsp;Redux的结构：只有一个Store,出现错误容易追踪。</p><p><img src="https://i.bmp.ovh/imgs/2020/11/fbb96f01a9c20437.png"></p><ul><li><p><strong>2、可预测性</strong> （不可变性immutable）</p><p><img src="https://i.bmp.ovh/imgs/2020/11/4753506caf528c03.png"></p></li><li><p><strong>3、纯函数更新State</strong></p></li></ul><p>&emsp;&emsp;redux没有副作用.<br><img src="https://i.bmp.ovh/imgs/2020/11/17c05a6f634a7eaf.png"></p><h3 id="二、理解Redux的核心概念：Store-Action-Reducer"><a href="#二、理解Redux的核心概念：Store-Action-Reducer" class="headerlink" title="二、理解Redux的核心概念：Store, Action,Reducer"></a>二、理解Redux的核心概念：Store, Action,Reducer</h3><p><strong>1.理解Store:</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/bc6be7d1bc1deaf2.png"></p><p>Store就是保存数据的地方，可以把它看作是一个容器。整个应用只能有一个Store。<br>Redux提供<strong>createStore</strong>这个函数，用来生成Store。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-comment">//createStore接受一个函数，返回新生成的store对象。</span><span class="hljs-keyword">const</span> store = createStore(fn);</code></pre><p><strong>==State:==</strong> &emsp;Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照。这种时点的数据集合，就叫做State。<br>当前时刻的State,可以通过 store.getState() 拿到。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">const</span> store = createStore(fn);<span class="hljs-keyword">const</span> state = store.getState();</code></pre><p>redux规定，<strong>一个state对应一个view</strong>。只要state相同，view就相同。知道了State,就知道了View是什么样，反之亦然。</p><p><strong>2.理解Action:</strong></p><p>&emsp;State的变化，会导致view的变化。但是，用户接触不到State,只能接触到view。所以，State的变化必须是view导致的。Action就是view发出的通知，标识State应该要变化了。</p><p>&emsp;Action是一个对象，其中的type属性是必须的，标识Action的名称。其他属性可以自由设置。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> action = &#123;  type:<span class="hljs-string">&#x27;ADD_TODO&#x27;</span>,  payload:<span class="hljs-string">&#x27;learn redux&#x27;</span>&#125;</code></pre><p>上述代码中，Action的名称是ADD_TODO，它携带的信息是字符串 learn redux.</p><p>可以这么理解，Action描述当前发生的事情。改变State的唯一方法，就是使用Action。它会运送数据给Store。</p><p><strong>Action Creator:</strong><br>View要发生多少种消息，就会有多少种Action.如果都手写，会很麻烦。所以，可以定义一个函数用来生成Action,这个函数就叫 Action Creator</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> ADD_TODO = <span class="hljs-string">&#x27;添加TODO&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTodo</span>(<span class="hljs-params">text</span>)</span>&#123;  <span class="hljs-keyword">return</span> &#123;    type:ADD_TODO,    text  &#125;&#125;<span class="hljs-keyword">const</span> action=addTodo(<span class="hljs-string">&#x27;learn redux&#x27;</span>)<span class="hljs-string">``</span><span class="hljs-string">` </span><span class="hljs-string">上面代码中，addTodo函数就是一个Action Creator</span><span class="hljs-string"></span><span class="hljs-string">**store.dispatch():**</span><span class="hljs-string">store.dispatch()是View发出Action的唯一方法。</span><span class="hljs-string">`</span><span class="hljs-string">``</span>js<span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">const</span> store = createStore(fn);store.dispatch(&#123;  type:<span class="hljs-string">&#x27;ADD_TODO&#x27;</span>,  payload:<span class="hljs-string">&#x27;learn redux&#x27;</span>&#125;)</code></pre><p>结合 Action Crreator,这段代码可以改写如下：</p><pre><code class="hljs js">store.dispatch(addTodo(<span class="hljs-string">&#x27;learn redux&#x27;</span>));</code></pre><p><strong>3.理解Reducer：</strong></p><p>Store在收到Action之后，必须给出一个新的State,这样View才会发生变化。这种State的计算过程，就叫做 Reducer。</p><p>Reducer是一个函数，它接受Action和当前的State,返回一个新的State。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> reducer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">state,action</span>)</span>&#123;  <span class="hljs-comment">//...</span>  <span class="hljs-keyword">return</span> new_state;&#125;</code></pre><p>整个应用的初始状态，可以作为State的默认值，下面就是一个实际的例子。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> defaultState=<span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> reducer = <span class="hljs-function">(<span class="hljs-params">state=defaultState,action</span>)=&gt;</span>&#123;  <span class="hljs-function"><span class="hljs-title">switch</span>(<span class="hljs-params">action.type</span>)</span>&#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD&#x27;</span>:      <span class="hljs-keyword">return</span> state + action.payload;    <span class="hljs-keyword">default</span>:      <span class="hljs-keyword">return</span> state;  &#125;&#125;;<span class="hljs-keyword">const</span> state=reducer(<span class="hljs-number">1</span>,&#123;  type:<span class="hljs-string">&#x27;ADD&#x27;</span>,  payload:<span class="hljs-number">2</span>&#125;)</code></pre><p>上面代码中，reducer函数接收到一个名为ADD的action以后，就返回一个新的State。<br>实际应用中，Reducer不需要像上面这样手动调用，store.dispatch方法会触发reducer的自动执行。为此，Store需要知道reducer函数，做法就是在生成Store的时候，就将reducer传入给createStore方法。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">const</span> store = createStore(reducer);<span class="hljs-comment">//以后每当store.dispatch发送过来一个新的Action,</span><span class="hljs-comment">//就会自动调用Reducer，得到新的State</span></code></pre><p>🐖为什么这个函数被叫做Reducer呢？<br>✨因为它可以作为数组的reduce方法的参数，下面是一个例子，一系列的Action对象按照顺序作为一个数组。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> actions = [  &#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;ADD&#x27;</span>,<span class="hljs-attr">payload</span>:<span class="hljs-number">0</span>&#125;,  &#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;ADD&#x27;</span>,<span class="hljs-attr">payload</span>:<span class="hljs-number">1</span>&#125;,  &#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;ADD&#x27;</span>,<span class="hljs-attr">payload</span>:<span class="hljs-number">2</span>&#125;];<span class="hljs-keyword">const</span> total = actions.reduce(reducer,<span class="hljs-number">0</span>)<span class="hljs-comment">//3</span></code></pre><p>上面代码中，数组actions表示依次有三个 Action，分别是加0、加1和加2。数组的reduce方法接受 Reducer 函数作为参数，就可以直接得到最终的状态3。 </p><p><img src="https://i.bmp.ovh/imgs/2020/11/43ed9499a953d590.png"></p><p><strong>Reducer函数最重要的特征是:它是一个纯函数。</strong><br>==纯函数==： 纯函数是函数式编程的概念，必须遵守以下一些约束。</p><ul><li>不得改写参数</li><li>不能调用系统 I/O的API</li><li>不能调用Date.now()或者Math.random等不纯的方法，因为每次都会得到不一样的结果。</li></ul><p>由于Reducer是纯函数，就可以保证同样的State必定得到同样的View。但也正因为这一点，Reducer函数里面不能改变State，必须返回一个全新的对象。所以，一般常采用 拓展运算符…和Object.assign()对state进行更新。(最好把State对象设为只读)</p><pre><code class="hljs js"><span class="hljs-comment">//1.state是一个对象</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state,action</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign(&#123;&#125;,state,&#123;thingTochange&#125;);  <span class="hljs-comment">//或者</span>  <span class="hljs-keyword">return</span> &#123;...state,...newState&#125;;&#125;<span class="hljs-comment">//2.state是一个数组</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state,action</span>)</span>&#123;  <span class="hljs-keyword">return</span> [...state,newItem]&#125;</code></pre><p>下图综合理解这三个概念，可以看出redux的单向数据流动。<br><img src="https://i.bmp.ovh/imgs/2020/11/9fceb4adcb97b639.png"></p><h3 id="三、redux的几个工具函数"><a href="#三、redux的几个工具函数" class="headerlink" title="三、redux的几个工具函数"></a>三、redux的几个工具函数</h3><p><strong>1.combineReducers:</strong></p><p>将多个reducer结合起来形成新的reducer。</p><p><img src="https://pic.downk.cc/item/5fb1ddf2b18d627113a841a0.jpg"></p><p><strong>2.bindActionCreators:</strong></p><p><img src="https://pic.downk.cc/item/5fb1de1eb18d627113a848fb.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1de6fb18d627113a8563c.jpg"></p><h3 id="四、在React中使用Redux"><a href="#四、在React中使用Redux" class="headerlink" title="四、在React中使用Redux"></a>四、在React中使用Redux</h3><p>redux提供了一个<strong>react-redux</strong>的package，用connect把一个已有的组件连接到store上。</p><p><img src="https://pic.downk.cc/item/5fb1e29cb18d627113a9146f.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1e356b18d627113a93618.jpg"></p><h3 id="五、理解Redux的异步action以及中间件"><a href="#五、理解Redux的异步action以及中间件" class="headerlink" title="五、理解Redux的异步action以及中间件"></a>五、理解Redux的异步action以及中间件</h3><p>中间件截获后去访问一个API，根据访问的结果再dispatch.</p><p><img src="https://pic.downk.cc/item/5fb1eab2b18d627113aabab1.jpg"></p><p>异步的action并不是一个新的action类型, 而是几个同步action的组合使用.</p><p><img src="https://pic.downk.cc/item/5fb1eb4eb18d627113aae915.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1ecf0b18d627113ab5f8a.jpg"></p><h3 id="六、如何在redux中组织Action和Reducer"><a href="#六、如何在redux中组织Action和Reducer" class="headerlink" title="六、如何在redux中组织Action和Reducer"></a>六、如何在redux中组织Action和Reducer</h3><p><img src="https://pic.downk.cc/item/5fb1ede4b18d627113ab90f7.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1ee82b18d627113abad69.jpg"></p><p><img src="https://pic.downk.cc/item/5fb1eec1b18d627113abb8da.jpg"></p><h3 id="七、-Redux的运行基础-不可变数据-immutability"><a href="#七、-Redux的运行基础-不可变数据-immutability" class="headerlink" title="七、 Redux的运行基础:不可变数据(immutability)"></a>七、 Redux的运行基础:不可变数据(immutability)</h3><p><img src="https://pic.downk.cc/item/5fb1efbcb18d627113abe8a3.jpg"></p><h5 id="1-为什么需要不可变数据"><a href="#1-为什么需要不可变数据" class="headerlink" title="1.为什么需要不可变数据?"></a>1.为什么需要不可变数据?</h5><ul><li><p><strong>1.性能优化:</strong><br> &emsp;store变化时会通知组件更新==&gt; store的变化都是由action触发==&gt;action触发在旧的state上形成新的state。不需要比较新旧state值是否变了,只需要判断<strong>前后状态的引用</strong>有没有变化</p></li><li><p><strong>2.易于调试和跟踪:</strong><br>任何时候，store变化时可以记录之前和之后的状态值。</p></li><li><p><strong>3.易于推测:</strong><br>任何时候，都可以找到是什么引起store的变化</p><h5 id="2-如何操作不可变数据"><a href="#2-如何操作不可变数据" class="headerlink" title="2.如何操作不可变数据?"></a>2.如何操作不可变数据?</h5></li></ul><p>==三种方式:==<br><img src="https://pic.downk.cc/item/5fb1f0f2b18d627113ac3540.jpg"></p><p>简单场景：使用原生写法就可以了。</p><p><img src="https://pic.downk.cc/item/5fb1f37cb18d627113acb0d5.jpg"></p><p>复杂场景：需要借助一些类库。</p><p><img src="https://pic.downk.cc/item/5fb1f414b18d627113accfd2.jpg"></p><p>immer: 性能差一点，适用应用程序小，场景简单的情况。<br><img src="https://pic.downk.cc/item/5fb1f44fb18d627113acdf4d.jpg"></p><h3 id="八、梳理Redux的工作流程"><a href="#八、梳理Redux的工作流程" class="headerlink" title="八、梳理Redux的工作流程"></a>八、梳理Redux的工作流程</h3><p><img src="https://pic.downk.cc/item/5fb26119b18d627113c52bcf.jpg"></p><p>1.首先，用户发出Action。</p><pre><code class="hljs js">store.dispatch(action)</code></pre><p>2.然后，Store自动调用Reducer,并且传入两个参数：当前State和收到的Action。Reducer会返回新的State</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> nextState = todoApp(previousState,action);</code></pre><p>State一旦有变化，Store就会调用监听函数</p><pre><code class="hljs js"><span class="hljs-comment">//设置监听函数</span>store.subscribe(listener);</code></pre><p>listener可以通过store.getState()得到当前状态，如果使用的是React,这时可以触发重新渲染View。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listener</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">let</span> newState = store.getState();  component.setState(newState);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09-打包和部署</title>
    <link href="/2020/11/12/09-%E6%89%93%E5%8C%85%E5%92%8C%E9%83%A8%E7%BD%B2/"/>
    <url>/2020/11/12/09-%E6%89%93%E5%8C%85%E5%92%8C%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h4 id="一-为什么需要打包"><a href="#一-为什么需要打包" class="headerlink" title="一.为什么需要打包?"></a>一.为什么需要打包?</h4><ul><li>1.编译ES6语法特性，编译JSX</li><li>2.整合资源，例如图片svg,Less/Sass</li><li>3.优化代码体积</li></ul><p><img src="https://i.bmp.ovh/imgs/2020/11/ef5409f73d9ca563.png"></p><h4 id="二-打包注意事项"><a href="#二-打包注意事项" class="headerlink" title="二.打包注意事项:"></a>二.打包注意事项:</h4><p>1.设置node.js环境为production<br>2.禁止开发时专用代码，比如logger<br>3.设置应用根路径</p><p>npm run build 执行的就是打包过程。</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-使用脚手架工具创建React项目</title>
    <link href="/2020/11/12/08-%E4%BD%BF%E7%94%A8%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E5%88%9B%E5%BB%BAReact%E9%A1%B9%E7%9B%AE/"/>
    <url>/2020/11/12/08-%E4%BD%BF%E7%94%A8%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E5%88%9B%E5%BB%BAReact%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="1-为什么需要脚手架？"><a href="#1-为什么需要脚手架？" class="headerlink" title="1.为什么需要脚手架？"></a>1.为什么需要脚手架？</h3><p><img src="https://i.bmp.ovh/imgs/2020/11/1df974a0ce1a7435.png"><br>项目越来越复杂，需要用：</p><ul><li><p>react: 做UI，</p></li><li><p>redux: 做状态管理，</p></li><li><p>react-router: 做路由管理</p></li><li><p>babel: 把js新特性翻译为浏览器可以识别的旧语法</p></li><li><p>webpack: 打包</p></li><li><p>eslint: 用于语法检查<br>…<br><img src="https://i.bmp.ovh/imgs/2020/11/611411d14c00f1a4.png"></p><p>&emsp;这些工具背后需要很多的package,我们需要了解每一个package的配置和使用，这使得创建项目非常繁琐。而创建一个项目的过程大致是差不多的，完全可以抽象出来做成一个工具<br>&emsp;===&gt;所以，脚手架应运而生。</p></li></ul><h3 id="2-常见的用于创建React应用的脚手架工具："><a href="#2-常见的用于创建React应用的脚手架工具：" class="headerlink" title="2.常见的用于创建React应用的脚手架工具："></a>2.常见的用于创建React应用的脚手架工具：</h3><ul><li><p><strong>Create React APP</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/6a1c377349d0f209.png"><br>&emsp; facebook 官方推出的，使用了最简策略，用于学习或创建简单的react项目</p></li><li><p><strong>Rekit</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/57aaa6b41498f44a.png"></p><p>&emsp;基于create-react-app,提供了更多的功能，可以开发大型的项目。</p></li><li><p><strong>Codesandbox</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/c18cd49b5e89621e.png"><br>&emsp; Online,在线的创建项目，webpack运行在浏览器端,大大提高打包速度。支持react,vue,angular</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-理解新的ContextAPI及其使用场景</title>
    <link href="/2020/11/11/07-%E7%90%86%E8%A7%A3%E6%96%B0%E7%9A%84ContextAPI%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2020/11/11/07-%E7%90%86%E8%A7%A3%E6%96%B0%E7%9A%84ContextAPI%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>Context解决的是：组件之间的通信问题</strong></p><p>Context提供了一个无需为每层组件手动添加props,就能在组件树间进行数据传递的方法。</p><p><img src="https://i.bmp.ovh/imgs/2020/11/c51c0b02a804b0fb.png"></p><h4 id="1-设计目的"><a href="#1-设计目的" class="headerlink" title="1.设计目的"></a>1.设计目的</h4><p>&emsp;Context设计的目的：为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或者首选语言。<br>&emsp;在一个典型的React应用中，数据是通过props属性自上而下（由父亲到儿子）进行传递的，但是这种做法对于某些属性是及其繁琐的（比如上文说的UI主题，），这些属性是应用程序中许多组件都需要的。</p><p><strong>==&gt;</strong> 所以，Context被设计出来，提供了一种在组件间共享“全局”数据的方式，从而不必显示地通过组件树逐层地传递props.</p><h4 id="2-使用Context前的考虑"><a href="#2-使用Context前的考虑" class="headerlink" title="2.使用Context前的考虑"></a>2.使用Context前的考虑</h4><p><strong>Context主要应用场景</strong>：很多不同层级之间的组件需要访问同样的一些数据。(但是需要谨慎使用，因为这会让组件的复用性变差。)<br>如果只是想避免层层传递一些属性，<a href="https://zh-hans.reactjs.org/docs/composition-vs-inheritance.html">组件组合（component composition）</a>有时是一个比Context更好的解决方案。</p><h4 id="3-相关的API"><a href="#3-相关的API" class="headerlink" title="3.相关的API"></a>3.相关的API</h4><p> <strong><em>(1) React.createContext</em></strong><br>  <pre><code class="hljs js"><span class="hljs-keyword">const</span> MyContext = React.createContext(defaultValue);</code></pre></p><ul><li>createContext函数创建一个Context对象，当React渲染一个订阅了这个Context对象的组件时，这个组件会从组件树中离自身最近的匹配到的Provider中读取当前的context值。<br>…</li><li><em>defaultValue</em>: 只有当组件所处的组件树中没有匹配到Provider时，其defaultValue参数才起作用。即使Provider中的value值是”undefined”，消费组件的defaultValue也不会生效。<br>（defaultValue有助于在不使用Provider包装组件的情况下，对组件进行测试）</li></ul><p><strong><em>(2)Context.Provider</em></strong></p><pre><code class="hljs js">&lt;MyContext.Provider value=&#123;<span class="hljs-comment">/*某个值*/</span>&#125;&gt;</code></pre><ul><li><p>每个Context对象都会返回一个Provider React组件，它允许消费组件订阅context的变化。</p></li><li><p>一个Provider可以和多个消费组件有对应关系。多个Provider也可以嵌套使用，里面的会覆盖外层的数据。</p></li><li><p>Provider有一个value属性，传递给消费组件。当value值发生变化时，Provider内部的所有消费组件都会重新渲染。<br>（Provider及其内部的消费组件都不受制于shouldComponentUpdate函数，所以当消费组件在其祖先组件推出更新的情况下也能更新）</p></li><li><p>通过新旧值检测确定变化，使用了和 Object.is相同的算法。</p></li></ul><p><strong><em>(3) Class.contextType</em></strong></p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">this</span>.context;    <span class="hljs-comment">/* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */</span>  &#125;  <span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">this</span>.context;    <span class="hljs-comment">/* ... */</span>  &#125;  <span class="hljs-function"><span class="hljs-title">componentWillUnmount</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">this</span>.context;    <span class="hljs-comment">/* ... */</span>  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">this</span>.context;    <span class="hljs-comment">/* 基于 MyContext 组件的值进行渲染 */</span>  &#125;&#125;MyClass.contextType = MyContext;</code></pre><ul><li>挂载在class上的contextType属性会被重新赋值为一个由React.createContext()创建的Context对象。所以使用this.context可以消费最近Context上的那个值，我们可以任何生命周期访问到this.context，包括render函数。</li><li>通过class.contextType只能订阅一个context</li></ul><p><strong><em>(4) Context.Consumer</em></strong></p><pre><code class="hljs js">&lt;MyContext.Consumer&gt;    &#123;<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span><span class="hljs-comment">/*基于context值进行渲染*/</span>&#125;&lt;/MyContext.Consumer&gt;</code></pre><ul><li><p>这是一个可以订阅context的变更的React组件，它在函数式组件中可以订阅一个context。</p></li><li><p>这种方法需要一个<a href="https://zh-hans.reactjs.org/docs/render-props.html#using-props-other-than-render">函数作为子元素（function as a child)</a>,这个函数接收当前的context值，并返回一个React节点。</p></li><li><p> 传递给Consumer的value值也就是组件树上方离context最近的Provider提供的value值，如果没有对应的Provider,就用createContext()中的defaultValue.</p></li></ul><p><strong><em>(5) Context.displayName</em></strong></p><p>示例，下述组件在DevTools中将是显示MyDisplayName:</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> MyContext = React.createContext(<span class="hljs-comment">/*some value*/</span>);MyContext.displayName = <span class="hljs-string">&#x27;MyDisplayName&#x27;</span>;&lt;MyContext.Provider&gt; <span class="hljs-comment">// &quot;MyDisplayName.Provider&quot; 在 DevTools 中</span>&lt;MyContext.Consumer&gt; <span class="hljs-comment">// &quot;MyDisplayName.Consumer&quot; 在 DevTools 中</span></code></pre><ul><li>context对象接受一个名为displayName的属性，类型为字符串。React DevTools使用该字符串来确定context要显示的内容。</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-两种组件设计模式</title>
    <link href="/2020/11/11/06-%E4%B8%A4%E7%A7%8D%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/11/11/06-%E4%B8%A4%E7%A7%8D%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="组件复用的另外两种形式："><a href="#组件复用的另外两种形式：" class="headerlink" title="组件复用的另外两种形式："></a>组件复用的另外两种形式：</h4><p>（除了常规的组件复用之外）</p><ul><li><strong>高阶组件</strong></li><li><strong>函数作为子组件</strong></li></ul><h4 id="一-高阶组件"><a href="#一-高阶组件" class="headerlink" title="一.高阶组件"></a>一.高阶组件</h4><p><img src="https://i.bmp.ovh/imgs/2020/11/f50691752374e779.png"></p><p><strong>高阶组件(HOC)</strong> 是React中复用组件逻辑的一种高级技巧，它本身不是React API的一部分，而是基于React的组合特性形成的一种设计模式。高阶组件以组件为参数，并返回一个新组件。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponenent)</code></pre><p>==区分:== &emsp;组件是将props转换为UI，高阶组件是将组件转换为另一个组件。</p><p>具体参见：<a href="https://zh-hans.reactjs.org/docs/higher-order-components.html">React官方文档–高阶组件</a></p><h4 id="二-函数作为子组件"><a href="#二-函数作为子组件" class="headerlink" title="二.函数作为子组件"></a>二.函数作为子组件</h4><p><img src="https://i.bmp.ovh/imgs/2020/11/17246cbcf6e05f4d.png"></p><p><strong>总结：</strong></p><p>1、高阶组件和函数作为子组件都是设计模式（并不是新的组件类型）</p><p>2、可以实现更多场景的组件复用</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-理解VirtualDOM及key属性的作用</title>
    <link href="/2020/11/11/05-%E7%90%86%E8%A7%A3VirtualDOM%E5%8F%8Akey%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2020/11/11/05-%E7%90%86%E8%A7%A3VirtualDOM%E5%8F%8Akey%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>JSX的基础：虚拟DOM</p><p><img src="https://i.bmp.ovh/imgs/2020/11/6244a9607b4da0d0.png"></p><p><img src="https://i.bmp.ovh/imgs/2020/11/314414dd61ae46e0.png"></p><p>从根节点开始比较，针对不同情况，diff算法有不同的处理方式：</p><p><strong>1. 属性变化及顺序：</strong><br>   <img src="https://i.bmp.ovh/imgs/2020/11/231a0e379e4ef3a4.png"></p><p>==处理方式==：根据key属性，交换A与B的位置</p><p><strong>2. 节点类型发生变化：</strong><br>   <img src="https://i.bmp.ovh/imgs/2020/11/c65c14d031817b7e.png"></p><p>==处理方式==：暴力删除F节点（不管他是否在其他地方用到），创建一个新的G节点，append到A节点上。</p><p><strong>3. 节点跨层级移动：</strong><br>    <img src="https://i.bmp.ovh/imgs/2020/11/06f09ef16c9da001.png"></p><p>==处理方式==：diff算法直接删除左边B下面的D节点（以及其子树），到了右边，React直接创建一个新的D节点。</p><h4 id="虚拟DOM的两个假设："><a href="#虚拟DOM的两个假设：" class="headerlink" title="虚拟DOM的两个假设："></a>虚拟DOM的两个假设：</h4><p><strong>1、组件的DOM结构是相对稳定的（一般很少出现跨层级移动的情况）</strong></p><p>&emsp;&emsp;跨层级的节点移动，react的diff算法是直接删除。</p><p><strong>2、类型相同的兄弟节点可以被唯一标识（key属性）。</strong></p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>算法复杂度为O(n)</li><li>虚拟DOM如何计算diff</li><li>key属性的作用</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-react的生命周期</title>
    <link href="/2020/11/10/04-react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2020/11/10/04-react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="React的生命周期图"><a href="#React的生命周期图" class="headerlink" title="React的生命周期图"></a>React的生命周期图</h3><p><img src="https://i.bmp.ovh/imgs/2020/11/32b8163f9eadfd47.png"></p><p>🐖：mounting到底意味着什么？<br>答： When we talk about mounting， we’re talking about the process of converting the virtual components into actual DOM elements that are placed in the DOM by React.（其实就是React将虚拟DOM转化为真实DOM的过程)</p><p><strong>1.constructor:</strong></p><ul><li>用于初始化内部状态，很少使用</li><li>唯一可以直接修改state的地方</li></ul><p><strong>2.getDerivedStateFromProps:</strong></p><ul><li>当state需要从props初始化时使用。</li><li>尽量不要使用：维护两者状态一致性会增加复杂度。</li><li>每次render都会调用。</li><li>典型场景：表单控件获取默认值。</li></ul><p><strong>3.componentDidMount:</strong></p><ul><li>UI渲染完成后调用</li><li>只执行一次</li><li>典型场景：获取外部资源</li></ul><p><strong>4.componeWillUnmout:</strong></p><ul><li>组件移除时被调用</li><li>典型场景：资源释放</li></ul><p><strong>5.getSnapshotBeforeUpdate:</strong></p><ul><li>在页面render之前调用，state已经更新</li><li>典型场景：获取render之前的DOM状态</li></ul><p><strong>6.componentDidUpdate:</strong></p><ul><li>每次UI更新时被调用</li><li>典型场景：页面需要根据props变化重新获取数据</li></ul><p><strong>7.shouldComponentUpdate:</strong></p><ul><li>决定Vitual DOM是否重绘</li><li>一般由PureComponent自动实现</li><li>典型场景：性能优化</li></ul>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-JSX的本质是语法糖</title>
    <link href="/2020/11/10/03-JSX%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <url>/2020/11/10/03-JSX%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    
    <content type="html"><![CDATA[<p>###理解JSX</p><p><em>JSX：在javaScript代码中直接写HTML标记。</em></p><pre><code class="hljs js"><span class="hljs-keyword">const</span> name=<span class="hljs-string">&#x27;jane&#x27;</span><span class="hljs-keyword">const</span> element=<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello,&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></code></pre><p><strong>1.JSX的本质</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/5e744edbbade47d2.png"></p><p><strong>2.在JSX中使用表达式</strong><br><img src="https://i.bmp.ovh/imgs/2020/11/87d92de0fdbd6f36.png"></p><p><strong>3.JSX的优点</strong></p><ul><li>声明创建界面的直观</li><li>代码动态创建界面的灵活</li><li>无需学习新的模板语言</li></ul><p><strong>约定：自定义组件首字母大写</strong><br>1.react认为小写的tag是原生DOM节点，如div<br>2.大写字母开头的组件是自定义节点<br>3.JSX标记可以直接使用属性语法，如&lt;menu.Item /&gt;</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-react以组件方式考虑UI的构建</title>
    <link href="/2020/11/10/02-react%E4%BB%A5%E7%BB%84%E4%BB%B6%E6%96%B9%E5%BC%8F%E8%80%83%E8%99%91UI%E7%9A%84%E6%9E%84%E5%BB%BA/"/>
    <url>/2020/11/10/02-react%E4%BB%A5%E7%BB%84%E4%BB%B6%E6%96%B9%E5%BC%8F%E8%80%83%E8%99%91UI%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.bmp.ovh/imgs/2020/11/b28d10e0a2054aec.png"></p><p><strong>一、构建一个组件需要考虑的三件事情：</strong></p><p>1、组件的UI( 一些外在的表现形式 )<br>2、组件的状态管理（放在哪？）<br>3、组件的交互</p><p><img src="https://i.bmp.ovh/imgs/2020/11/f878479d2f41ffb4.png"></p><p><strong>二、何时创建组件：单一职责原则</strong></p><p>1、一个组件只负责一个功能<br>2、复杂的组件应该进行拆分</p><p><strong>三、数据状态管理原则：DRY原则</strong></p><p>1.能计算得到的状态不应该单独存储<br>2.组件尽量无状态，尽量通过props获取.</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-React的历史背景及特点</title>
    <link href="/2020/11/10/01-React%E7%9A%84%E5%8E%86%E5%8F%B2%E8%83%8C%E6%99%AF/"/>
    <url>/2020/11/10/01-React%E7%9A%84%E5%8E%86%E5%8F%B2%E8%83%8C%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="1-React-出现的历史背景"><a href="#1-React-出现的历史背景" class="headerlink" title="1. React 出现的历史背景"></a>1. React 出现的历史背景</h3><h4 id="A-UI方面的——"><a href="#A-UI方面的——" class="headerlink" title="A.UI方面的——"></a>A.UI方面的——</h4><p>传统WebUI存在的问题：</p><ul><li>传统UI关注太多的细节</li><li>应用程序的状态分散在各处，难以追踪和维护</li></ul><p><strong>=&gt;</strong> <strong>React的解决方案</strong>：react 始终整体”刷新”页面，无需关心细节。它只判断前后两个状态是否变化，并不关注背后的哪个细节发生了变化。<br><img src="https://i.bmp.ovh/imgs/2020/11/981310a92f37e99e.png"></p><h4 id="B-数据方面的——"><a href="#B-数据方面的——" class="headerlink" title="B.数据方面的——"></a>B.数据方面的——</h4><p>传统的MVC难以扩展和维护，太多的model和view，关系错综复杂且双向绑定，当出现了问题，很难追踪是model还是view层出现了问题。<br><img src="https://i.bmp.ovh/imgs/2020/11/0520d5fd55b9ac16.png"> </p><p><strong>=&gt;</strong> <strong>React的解决方案</strong>，提出了单向数据流架构flux.(后面衍生出redux和mobx)<br><img src="https://i.bmp.ovh/imgs/2020/11/1d93a50d7d4e112b.png"></p><h3 id="2-React-的特点："><a href="#2-React-的特点：" class="headerlink" title="2. React 的特点："></a>2. React 的特点：</h3><p>1个新概念<br>4个必须的API<br>单向数据流<br>完善的错误提示</p>]]></content>
    
    
    <categories>
      
      <category>极客时间React教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>my-first-blog</title>
    <link href="/2020/11/09/%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/"/>
    <url>/2020/11/09/%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="前端学习路线及资源"><a href="#前端学习路线及资源" class="headerlink" title=" 前端学习路线及资源"></a><center> 前端学习路线及资源</h2><p align='right'>——————左耳听风<p>&nbsp;&emsp;对于前端的学习和提高，我的基本思路是这样的。首先，前端的三个最基本的东西 HTML 5、CSS 3 和 JavaScript（ES6）是必须要学好的。这其中有很多很多的技术，比如，CSS 3 引申出来的 Canvas（位图）、SVG（矢量图） 和 WebGL（3D 图），以及 CSS 的各种图形变换可以让你做出非常丰富的渲染效果和动画效果。<br>&nbsp;&emsp; ES6 简直就是把 JavaScript 带到了一个新的台阶，JavaScript 语言的强大，大大释放了前端开发人员的生产力，让前端得以开发更为复杂的代码和程序，于是像 React 和 Vue 这样的框架开始成为前端编程的不二之选。<br>&nbsp;&nbsp; 我一直认为学习任何知识都要从基础出发，所以这篇文章我会着重介绍基础知识和基本原理，尤其是如下的这些知识，都是前端程序员需要花力气啃下来的硬骨头。JavaScript 的核心原理。这里我会给出好些网上很不错的讲 JavaScript </p><ul><li><p><strong>JavaScript 的核心原理</strong>。这里我会给出好些网上很不错的讲 JavaScript 的原理的文章或图书，你一定要学好语言的特性，并且详细了解其中的各种坑。</p></li><li><p><strong>浏览器的工作原理</strong>。这也是一块硬骨头，我觉得这是前端程序员需要了解和明白的关键知识点，不然，你将无法深入下去。</p></li><li><p><strong>网络协议 HTTP</strong>。也是要着重了解的，尤其是 HTTP/2，还有 HTTP 的几种请求方式：短连接、长连接、Stream 连接、WebSocket 连接。</p></li><li><p><strong>前端性能调优</strong>。有了以上的这些基础后，你就可以进入前端性能调优的主题了，我相信你可以很容易上手各种性能调优技术的。</p></li><li><p><strong>框架学习</strong>。我只给了 React 和 Vue 两个框架。就这两个框架来说，Virtual DOM 技术是其底层技术，组件化是其思想，管理组件的状态是其重点。而对于 React 来说，函数式编程又是其编程思想，所以，这些基础技术都是你需要好好研究和学习的。</p></li><li><p><strong>UI 设计</strong>。设计也是前端需要做的一个事，比如像 Google 的 Material UI，或是比较流行的 Atomic Design 等应该是前端工程师需要学习的。</p><p>&nbsp;而对于工具类的东西，这里我基本没怎么涉及，因为本文主要还是从原理和基础入手。那些工具我觉得都很简单，就像学习 Java 我没有让你去学习 Maven 一样，因为只要你去动手了，这种知识你自然就会获得，我们还是把精力重点放在更重要的地方。  </p><p>下面我们从前端基础和底层原理开始讲起。先来讲讲 HTML5 相关的内容。</p><h3 id="HTML-5"><a href="#HTML-5" class="headerlink" title="HTML 5"></a>HTML 5</h3><p>HTML 5 主要有以下几本书推荐。</p><ul><li><a href="https://book.douban.com/subject/25786074/">HTML 5 权威指南</a>，本书面向初学者和中等水平 Web 开发人员，是牢固掌握 HTML 5、CSS 3 和 JavaScript 的必读之作。书看起来比较厚，是因为里面的代码很多。</li><li><a href="https://book.douban.com/subject/24533314/">HTML 5 Canvas 核心技术 </a>，如果你要做 HTML 5 游戏的话，这本书必读。</li><li>对于 SVG、Canvas 和 WebGL 这三个对应于矢量图、位图和 3D 图的渲染来说，给前端开发带来了重武器，很多 HTML5 小游戏也因此蓬勃发展。所以，你可以学习一下。学习这三个技术，我个人觉得最好的地方是 MDN。</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/SVG">SVG: Scalable Vector Graphics</a></li><li><a href="https://developer.mozilla.org/kab/docs/Web/API/Canvas_API">Canvas API</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">The WebGL API: 2D and 3D graphics for the web</a></li></ul></li></ul><p>  最后是几个资源列表。</p><ul><li><a href="https://github.com/diegocard/awesome-html5">Awesome HTML5</a> 。GitHub 上的 Awesome HTML5，其中有大量的资源和技术文章。</li><li><a href="https://github.com/willianjusten/awesome-svg">Awesome SVG</a></li><li><a href="https://github.com/raphamorim/awesome-canvas">Awesome Canvas</a></li><li><a href="https://github.com/sjfricke/awesome-webgl">Awesome WebGL</a></li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>在《程序员练级攻略》系列文章最开始，我们就推荐过 CSS 的在线学习文档，这里再推荐一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">MDN Web Doc - CSS </a>。我个人觉得只要你仔细读一下文档，CSS 并不难学。绝大多数觉得难的，一方面是文档没读透，另一方面是浏览器支持的标准不一致。所以，学好 CSS 最关键的还是要仔细地读文档。之后，在写 CSS 的时候，你会发现，你的 CSS 中有很多看起来相似的东西。你的 DRY - Don’t Repeat Yourself 洁癖告诉你，这是不对的。所以，你需要学会使用 <a href="http://lesscss.org/">LESS</a> 和 <a href="http://sass-lang.com/">SaSS</a> 这两个 CSS 预处理工具，其可以帮你提高很多效率。然后，你需要学习一下 CSS 的书写规范，前面的《程序员修养》一文中提到过一些，这里再补充几个:</p><ul><li><p><a href="https://github.com/necolas/idiomatic-css">Principles of writing consistent, idiomatic CSS</a></p></li><li><p><a href="https://github.com/grvcoelho/css-styleguide">Opinionated CSS styleguide for scalable applications</a></p></li><li><p><a href="https://google.github.io/styleguide/htmlcssguide.html">Google HTML/CSS Style Guide</a></p><p>&emsp;如果你需要更有效率，那么你还需要使用一些 CSS Framework，其中最著名的就是 Twitter 公司的 Bootstrap，其有很多不错的 UI 组件，页面布局方案，可以让你非常方便也非常快速地开发页面。除此之外，还有，主打清新 UI 的 Semantic UI 、主打响应式界面的 Foundation 和基于 Flexbox 的 Bulma。<br>&emsp;当然，在使用 CSS 之前，你需要把你浏览器中的一些 HTML 标签给标准化掉。所以，推荐几个 Reset 或标准化的 CSS 库：Normalize、MiniRest.css、sanitize.css 和 unstyle.css。关于更多的 CSS 框架，你可以参看<a href="https://github.com/troxler/awesome-css-frameworks">Awesome CSS Frameworks</a> 上的列表。接下来，是几个公司的 CSS 相关实践，供你参考:</p></li><li><p><a href="https://codepen.io/chriscoyier/post/codepens-css"> CodePen’s CSS</a></p></li><li><p><a href="https://markdotto.com/2014/07/23/githubs-css/">Github 的 CSS</a></p></li><li><p>Medium’s CSS is actually pretty f***ing good()</p></li><li><p>CSS at BBC Sport</p></li><li><p><a href="https://blog.trello.com/refining-the-way-we-structure-our-css-at-trello">Refining The Way We Structure Our CSS At Trello</a></p><p>&emsp; 最后是一个可以写出可扩展的 CSS 的阅读列表 <a href="https://github.com/davidtheclark/scalable-css-readin">A Scalable CSS Reading List</a> 。</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>下面是学习 JavaScript 的一些图书和文章。</p></li><li><p><a href="">JavaScript: The Good Parts</a> ，中文翻译版为《JavaScript 语言精粹》。这是一本介绍 JavaScript 语言本质的权威图书，值得任何正在或准备从事 JavaScript 开发的人阅读，并且需要反复阅读。学习、理解、实践大师的思想，我们才可能站在巨人的肩上，才有机会超越大师，这本书就是开始。</p></li><li><p><a href="">Secrets of the JavaScript Ninja</a> ，中文翻译版为《JavaScript 忍者秘籍》，本书是 jQuery 库创始人编写的一本深入剖析 JavaScript 语言的书。适合具备一定 JavaScript 基础知识的读者阅读，</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
